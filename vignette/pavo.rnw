\documentclass{article}

% Definitions
\newcommand{\pavo}{{\tt pavo}}  % you can use \pavo{} to print pavo in code text formatting
\newcommand{\code}[1]{{\tt #1}}  % text formate for code
\setlength{\parindent}{0in}
\setlength{\parskip}{.1in}
\setlength{\textwidth}{140mm}
\setlength{\oddsidemargin}{10mm}
\usepackage[fleqn]{amsmath}
\usepackage{hyperref}
\usepackage{float}
\usepackage{authblk}
\usepackage[usenames,dvipsnames]{color}
\usepackage{graphicx}
\usepackage{caption}
\usepackage{subcaption}
\usepackage[utf8]{inputenc}
\usepackage{array}
\usepackage{geometry} 
\geometry{letterpaper, textwidth=5.5in, textheight=8.5in, marginparsep=7pt, marginparwidth=.6in}
%\setlength\parindent{0in}

\usepackage{booktabs}
\usepackage{natbib}


% define colors
\hypersetup{
  colorlinks,
  citecolor=violet,
  linkcolor=black,
  urlcolor=MidnightBlue
  }
\renewcommand{\thefootnote}{\textcolor{Gray}{\arabic{footnote}}}

\begin{document}


\SweaveOpts{concordance=TRUE, prefix.string=fig/pavo}
%\VignetteIndexEntry{pavo} 

<<echo=FALSE, results=hide>>=
library(pavo)
ps.options(pointsize=12)
options(width=60)
@

\title{\pavo{}: {\bf P}erceptual {\bf A}nalysis, {\bf V}isualization and {\bf O}rganization of Spectral Color Data in R}
\author[1]{Rafael Maia}
\author[2]{Pierre-Paul Bitton}
\author[1]{Chad Eliason}
\affil[1]{Integrated Bioscience PhD Program, University of Akron, Akron OH}
\affil[2]{Department of Biological Sciences, University of Windsor, Windsor ON}
\maketitle

\addtolength{\parskip}{-.08in}
\tableofcontents
\addtolength{\parskip}{.08in}

\section{Introduction}

\pavo{} is an \code{R} package developed with the goal of establishing a flexible and integrated workflow
for working with spectral color data. It includes functions that take advantage of new data classes
in order to work seamlessly from importing raw data to visualization and analysis.

Although \pavo{} deals largely, in its examples, with spectral reflectance data from bird feathers,
it is meant  to be applicable for a range of taxa and applications. It provides flexible ways to
input spectral data from a variety of equipment manufacturers, process these data, extract
variables, and produce publication-quality graphics.

\pavo{} was written with the following workflow in mind:

% numbered list of things
\begin{enumerate}
\item {\bf Organize} spectral data by inputting files and processing spectra (e.g., to remove
noise, negative values, smooth curves, etc...).
\item {\bf Analyze} the resulting files, either using typical tristimulus color variables (hue,
saturation, brightness) or using visual models based on perceptual data from the taxon of 
interest.
\item {\bf Visualize} the output, with multiple options provided for exploratory analyses.
\end{enumerate}

Below we will show the main functions in the package in an example workflow. The development
version of \pavo{} can be found on \href{https://github.com/rmaia/pavo}{github}.

\section{Dataset Description}

The data used in this example are available from \href{http://github.com}github by clicking 
\href{https://github.com/rmaia/pavo/blob/master/vignette_data/vignette_data.zip}
{here}\footnote{in case you printed this out and thus can't click the link:\\ 
\url{https://github.com/rmaia/pavo/blob/master/vignette_data/vignette_data.zip}}. 
You can download and extract it to follow the vignette.

The data consist of reflectance spectra, obtained using Avantes equipment and software, from seven
bird species: Northern Cardinal (\emph{Cardinalis cardinalis}), Wattled Jacana (\emph{Jacana
jacana}), Baltimore Oriole (\emph{Icterus galbula}), Peach-fronted Parakeet (\emph{Aratinga aurea}),
American Robin (\emph{Turdus migratorius}), and Sayaca Tanager (\emph{Thraupis sayaca}). Several
individuals were measured (sample size varies by species), and 3 spectra were collected from each
individual. However, the number of individuals measured per species is uneven and the data have
additional peculiarities that should emphasize the flexibility \pavo{} offers, as we'll see below.

In addition, \pavo{} includes two datasets that can be called with the \code{data} function.
\code{data(teal)} will be used in this vignette, but \code{data(sicalis)} is also available. See
help for more information (\code{help(package="pavo")}).

\section{Organizing and Processing Spectral Data}

\subsection{Importing Data}

The first thing we need to do is import the spectral data into R using the function
\code{getspec()}. Since the spectra were obtained using Avantes software, we will need to  specify
that the files have the ``\code{.ttt}'' extension. Further, the data is organized in  subdirectories
for each species. \code{getspec} does recursive sampling, and may include the  names of the
subdirectories in the spectra name if desired. A final issue with the data is that  it was collected
using a computer with international numbering input, which means it uses commas  instead of periods
as a decimal separator. We can specify that in the function call.

The files were downloaded and placed in a directory called 
``\nolinkurl{/github/pavo/vignette_data}''. By default, \code{getspec} will search for files in 
the current folder, but a different one can be specified:

<<>>=
specs <- getspec("~/github/pavo/vignette_data/", ext="ttt", decimal=",", 
                 subdir=T, subdir.names=F)
specs[1:10,1:4]
dim(specs) # the data set has 213 spectra, from 300 to 700 nm, plus a 'wl' column
@

When \pavo{} imports spectra, it creates an object of class \code{rspec}, which inherits attributes
from the \code{data.frame} class:

<<>>=
is.rspec(specs)
@

If you already have multiple spectra in a single data frame that you'd like to use with \pavo{}
functions, you can use the command \code{as.rspec} to convert it to an rspec object. The  function
will attempt to identify the wavelength variable or, if it doesn't have one, it can be  specified in
the function call. As an example, we will create some fake reflectance data, name the column
containing wavelengths ``wavelength'' rather than ``wl'' (required for \pavo{} functions to work) and
also put the column containing wavelengths third rather than first.

<<>>=
# Create some fake reflectance data with wavelength column arbitrarily titled and not
# first in the data frame:
fakedat <- data.frame(refl1=rnorm(n=401), refl2=rnorm(n=401), wavelength=c(300:700))
head(fakedat)
is.rspec(fakedat)
fakedat <- as.rspec(fakedat)
is.rspec(fakedat)
head(fakedat)
@

As can be seen, \code{as.rspec} renames the column containing wavelengths, places it first and sets the class of the object to \code{rspec}.

\subsection{Processing Data}

\subsubsection{Averaging Spectra}

As previously described, our data constitutes of multiple individuals, and each was measured  three
times, as is common to avoid measurement bias. A good way to visualize the  repeatability
of our measurements is to plot the spectra of each individual separately. The  function
\code{explorespec} provides an easy way of doing so. You may specify the number of  spectra to be
plotted in the same panel using the argument \code{specreps}, and the function  will adjust the
number of panels per page accordingly. We will exemplify this function using  only the 12 cardinal
individuals measured:

<<label=explorespecfig, fig=TRUE, include=FALSE, width=8, height=6.33>>=
explorespec(specs[,1:37], by=3, lwd=2) 
# 36 spectra plus the first (wl) column
@
\begin{figure}[H] % h=here, t=top, b=bottom, p=floating page
\begin{center}
\includegraphics[width=5in]{fig/pavo-explorespecfig}
\end{center}
\caption{Result from \code{explorespec}, showing the three measurements for each individual cardinal in separate panels}
\label{figure:explorespec}
\end{figure}

So our first step would be to take the average of each of these three measurements to
obtain average individual spectra to be used in further analyses. This easily accomplished using the
\code{aggspec} function. The \code{by} argument can be either a number (specifying how many specs
should be  averaged for each new sample) or a vector specifying the identities of the spectra to be
combined (see below):

<<>>=
mspecs <- aggspec(specs, by=3, FUN=mean)
mspecs[1:5, 1:4]
dim(mspecs) #data now has 72 spectra, one for each individual
@

Now we'll use the \code{aggspec} function again, but this time to take the average spectrum for
each species. However, each species has a different number of samples, so we can't use the
\code{by} argument as before. Instead we will use regular expressions to create a species name
vector by removing the numbers that identify individual spectra:

<<>>=
# create a vector with species identity names
spp <- gsub('\\.[0-9].*$','',names(mspecs))[-1]
table(spp)
@

Instead, we are going to use the \code{spp} vector we created to tell the \code{aggspec} 
function how to average the spectra in \code{mspec}:

<<label=exploresppmeans, fig=TRUE, include=FALSE>>=
sppspec <- aggspec(mspecs, by=spp, FUN=mean)
round(sppspec[1:5, ],2)
explorespec(sppspec, by=6, lwd=3)
@
\begin{figure}[H]
\begin{center}
\includegraphics[width=3in]{fig/pavo-exploresppmeans}
\end{center}
\caption{Result from \code{explorespec} for species means}
\label{figure:sppmeans}
\end{figure}

 \subsubsection{Normalizing and Smoothing Spectra}

Data obtained from spectrometers often requires further processing before analysis and/or
publication. For example, electrical noise can produce unwanted ``spikes'' in reflectance curves.
The \pavo{} function \code{procspec} can handle a variety of processing techniques. For example, the
reflectance curve from the parakeet is noisy in the short (300-400 nm) and long (650-700  nm)
wavelength ranges (see Figure \ref{figure:specsmooth}, black line). To eliminate this noise, we will
use local regression smoothing implemented by the \code{loess.smooth} function in \code{R}, wrapped
in the \code{opt="smooth"} argument of \code{procspec}.

But first, let's use the \code{plotsmooth} function to determine a suitable smoothing parameter
(\code{span}). This function allows you to set a minimum and maximum smoothing parameter to try and
plots the resulting curves against the unsmoothed (raw) data in a convenient multipanel figure.

<<label=plotsmooth,fig=TRUE,include=FALSE,width=6,height=4>>=
plotsmooth(sppspec, minsmooth = 0.05, maxsmooth = 0.5, curves = 5, ask = F)
@

\begin{figure}[H]
\begin{center}
\includegraphics[width=5in]{fig/pavo-plotsmooth}
\end{center}
\caption{Diagnostic plots produced with \code{plotsmooth} to determine optimal smoothing parameter. Each panel shows raw spectral data (lower curve) and smoothed curves with sequentially higher smoothing parameters.}
\label{figure:plotsmooth}
\end{figure}

From the resulting plot, we can see that \code{span}=0.2 is the minimum amount of smoothing to
remove spectral noise while preserving the original spectral shape (Figure \ref{figure:plotsmooth}).
Based on this value, we will now use the \code{opt} argument in \code{procspec} to smooth data for
further plotting and analysis (see Figure \ref{figure:specsmooth}, red line).

<<label=specsmooth,fig=TRUE,include=FALSE,results=hide>>=
spec.sm <- procspec(sppspec, opt='smooth', span = 0.2)
plot(sppspec[, 5]~sppspec[, 1], type='l', lwd=10, col='grey', 
     xlab="Wavelength (nm)", ylab="Reflectance (%)")
lines(spec.sm[, 5]~sppspec[, 1], col='red', lwd=2)
@
\begin{figure}[H]
\begin{center}
\includegraphics[width=3in]{fig/pavo-specsmooth}
\end{center}
\caption{Result for raw (grey line) and smoothed (red line) reflectance data for the parakeet.}
\label{figure:specsmooth}
\end{figure}

We can also try different normalizations. Options include subtracting the minimum reflectance
of a  spectrum at all wavelengths (effectively making the minimum reflectance equal to zero,
\code{opt="min"}, Figure \ref{figure:specnorm} left panel) and making the reflectance at all
wavelength proportional to the maximum reflectance (i.e. setting maximum reflectance to 1;
\code{opt="max"}, Figure \ref{figure:specnorm} center panel). Note that the user can specify
multiple  processing options that will be applied sequentially to the spectral data by
\code{procspec} (Figure  \ref{figure:specnorm} right panel).

<<results=hide>>=
# Run some different normalizations
specs.max <- procspec(sppspec, opt='max')
specs.min <- procspec(sppspec, opt='min')
specs.str <- procspec(sppspec, opt=c('min', 'max'))  # multiple options
@

<<label=specnorm,fig=TRUE,include=FALSE,width=7,height=2.7>>=
# plot results
par(mfrow=c(1,3), mar=c(2,2,2,2), oma=c(3,3,0,0))
plot(specs.min[,5]~c(300:700), xlab="", ylab="", type='l')
abline(h=0, lty=2)
plot(specs.max[, 5]~c(300:700), ylim=c(0,1), xlab="", ylab="", type='l')
abline(h=1, lty=2)
plot(specs.str[,5]~c(300:700), type='l', xlab="", ylab="")
abline(h=c(0,1), lty=2)
mtext("Wavelength (nm)", side=1, outer=T, line=1)
mtext("Reflectance (%)", side=2, outer=T, line=1)
@
\begin{figure}[H]
\begin{center}
\includegraphics[width=6in]{fig/pavo-specnorm}
\end{center}
\caption{Results for max (left), min (center), and both normalizations (right).}
\label{figure:specnorm}
\end{figure}

\subsubsection{Binning and PCA Analysis of Spectral Shape}

Another intended usage of \code{procspec} is preparation of spectral data for variable reduction
(for example, using Principal Component Analysis, or PCA). Following Cuthill (1999), we can use 
\code{opt = 'center'} to center spectra to have a mean reflectance of zero (thus removing brightness 
as a dominant variable in the PCA) and then bin the spectra into user-defined bins (using the 
\code{opt= 'bins'} argument) to obtain a dataframe suitable for the PCA.

<<results=hide>>=
# pca analysis
spec.bin <- procspec(sppspec, opt=c('bin', 'center'))
head(spec.bin)
spec.bin <- t(spec.bin)  # transpose so wavelength are variables for the PCA
colnames(spec.bin) <- spec.bin[1,]  # names variables as wavelength bins
spec.bin <- spec.bin[-1, ]  # remove 'wl' column
# spec.bin[1:6, 1:3]
pca1 <- prcomp(spec.bin, scale=T)
summary(pca1)
@

As can be seen by the summary, PC1 explains approximately 64\% of the variation in spectral shape
and describes the relative amount of long wavelengths reflected (see Figure \ref{figure:pcaplot},
left). The flexibility of \code{R} and \code{pavo}'s plotting capabilities allows you to sort
spectra by another variable (e.g., PC1 loading) and then plot in a stacked format using the
\code{plot} function.

<<label=pcaplot,fig=TRUE,include=FALSE,width=8,height=4>>=
# generate colors from spectra
colr <- spec2rgb(sppspec)
wls <- as.numeric(colnames(spec.bin))
# rank specs by PC1
sel <- rank(pca1$x[,1])
sel <- match(names(sort(sel)), names(sppspec))
# plot results
par(mfrow=c(1,2), mar=c(2,4,2,2), oma=c(2,0,0,0))
plot(pca1$r[,1]~wls, type='l', ylab="PC1 loading")
abline(h=0, lty=2)
plot(sppspec, select=sel, type='s', col=spec2rgb(sppspec))
mtext("Wavelength (nm)", side=1, outer=T, line=1)
@
\begin{figure}[H]
\begin{center}
\includegraphics[width=5in]{fig/pavo-pcaplot}
\end{center}
\caption{Plot of PC1 loading versus wavelength (left) and species mean spectra sorted 
vertically from lowest to highest PC1 value (right; values on right hand axis are column identities).}
\label{figure:pcaplot}
\end{figure}

\subsubsection{Dealing With Negative Values in Spectra}

Negative values in spectra are unwanted, as they are uninterpretable (how can there be less than
zero light reflected by a surface?) and can affect estimates of color variables. Nonetheless,
certain spectrometer manufacturers allow negative values to be saved. To handle negative values, the
\code{procspec} function has an argument called \code{fixneg}. The two options available are (1)
adding the absolute value of the most negative value to the whole spectrum (\code{addmin}) and (2)
changing all negative values to zero (\code{zero}).

<<results=hide>>=
# Create a duplicate spectrum and add some negative values
refl <- sppspec[, 7] - 20
testspecs <- as.rspec(cbind(c(300:700), refl))
# Apply two different processing options
testspecs.fix1 <- procspec(testspecs, fixneg='addmin')
testspecs.fix2 <- procspec(testspecs, fixneg='zero')
@

<<label=fixneg, fig=T, include=F, width=6, height=4>>=
par(mar=c(2,2,2,2), oma=c(3,3,0,0))
layout(cbind(c(1,1),c(2,3)), widths=c(2,1,1))
plot(testspecs, select = 2, ylim=c(-10,30))
abline(h=0, lty=3)
plot(testspecs.fix1, select = 2, ylim=c(-10,30))
abline(h=0, lty=3)
plot(testspecs.fix2, select = 2, ylim=c(-10,30))
abline(h=0, lty=3)
mtext("Wavelength (nm)", side=1, outer=T, line=1)
mtext("Reflectance (%)", side=2, outer=T, line=1)
@
\begin{figure}[H]
\begin{center}
\includegraphics[width=5in]{fig/pavo-fixneg}
\end{center}
\caption{Plots showing original reflectance curve including negative values (left) and two processed curves using \code{fixneg=addmin} (top right) and \code{fixneg=zero} (bottom right).}
\label{figure:neg}
\end{figure}

These may have different effects on the final spectra, as can be seen in Figure \ref{figure:neg},
which the user should keep in mind and use according to the final goal of the analysis. For example,
by adding the minimum reflectance to all other wavelength, the shape of the curve is preserved, but
the  maximum reflectance is much higher (Figure \ref{figure:neg}, top). On the other hand,
substituting  negative values with zero preserves absolute reflectance values, but may cause the
spectral shape to  be lost (Figure \ref{figure:neg}, bottom). The ``best'' transformation will
depend on the severity of  the problem of negative values and the goal of the analysis (e.g. will
reflectance intensity be used?  What is more important, to preserve reflectance values or the total
shape of the curve?). The decision of which correction to use would also depend on the source of the
negative values. If they are thought to originate from improper calibration of the spectrophotometer
using a white diffuse standard, \code{addmin} would be more appropriate. If they are thought to
originate from electric noise, \code{zero} would be more appropriate.

\section{Visualizing Spectral Data}

\pavo{} offers three main plotting functions. The main one is \code{plot}, which combines
several different options in a flexible framework for most commonly used purposes. The
\code{explorespec} function aims at providing initial exploratory analysis, as demonstrated in
Section 1, Figures \ref{figure:explorespec} and \ref{figure:sppmeans}. Finally \code{aggplot}
provides a simple framework for publication-quality plots of aggregated spectral data.

\subsection{The \code{plot} Function Options}

Since \pavo{} uses the class \code{rspec} to identify spectral data, the function \code{plot.rspec}
can be called simply by calling \code{plot(data)}. If the object is not of class \code{rspec} the
multivariate visualization methods will not work as expected, so it might be useful to check the
data using \code{is.rspec} and convert with \code{as.rspec} if necessary.

We have implemented three methods of visualizing spectral data using \code{plot}:

\begin{itemize}
	\item{\code{Overlay} - all spectra plotted with same x- and y-axis}
	\item{\code{Stack} - spectra plotted with same x-axis but arranged vertically along y-axis}
	\item{\code{Heatmap} - false color map to illustrate three dimensional data}
\end{itemize}

These options are in addition to the exploratory plotting offered by \code{explorespec}, as seen 
in Figures
\ref{figure:explorespec} and \ref{figure:sppmeans}. To showcase the capabilities of
\code{plot.rspec},  we will use the \code{teal} dataset included in \pavo{}. This dataset consists
of reflectance spectra from the iridescent wing patch of a green-winged teal (\emph{Anas
carolinensis}). Reflectance measurements were taken between 300 and 700 nm at different incident
angles, ranging from 15\ensuremath{^\circ} to 70\ensuremath{^\circ} (in 5\ensuremath{^\circ}
increments).

\subsubsection{The \code{overlay} Option}

We can start out by visualizing these spectra with the \code{overlay} option in plot. Another neat
option \pavo{} offers is to convert reflectance spectra to their approximate perceived color, by
using the function \code{spec2rgb}. This can make for some very interesting plots and even
exploratory data analysis, as shown in Figure \ref{figure:overlay}.

<<label=overlay,fig=T,include=F,width=7,height=5>>=
par(mar=c(4,4,2,2))
data(teal)
plot(teal, type='o', col=spec2rgb(teal))
@

\begin{figure}[H]
\begin{center}
\includegraphics[width=4in]{fig/pavo-overlay}
\end{center}
\caption{Overlay plot of the teal angle-dependent reflectance with colors of each curve
being an approximation of the perceived color.}
\label{figure:overlay}
\end{figure}

\subsubsection{The \code{stack} Option}

Another option is the \code{stack} plot (again, with human vision approximations of the color
produced by the spectra using \code{spec2rgb}).

<<label=stack,fig=T,include=F,results=hide>>=
teal.norm <- procspec(teal, opt=c('min', 'max'))
par(mfrow=c(1,2), mar=c(2,2,2,2), oma=c(2,2,0,0))
plot(teal, type='s', col=spec2rgb(teal))
plot(teal.norm, type='s', col=spec2rgb(teal))
mtext("Wavelength (nm)", side=1, outer=T, line=1)
mtext("Cumulative reflectance (A.U.)", side=2, outer=T, line=1)
@
\begin{figure}[H]
\begin{center}
\includegraphics[width=4in]{fig/pavo-stack}
\end{center}
\caption{Stack plot of the raw (left) and normalized (right) teal angle-dependent reflectance}
\label{figure:stack}
\end{figure}

Note that in Figure \ref{figure:stack}, the y axis to the right includes the index of each spectrum.
This makes it easier to identify and subset specific spectra or groups of spectra using the
\code{select} argument in \code{plot.rspec}. Note also that the first index is actually 2,
preserving  the sequence in the original dataset (since the first column is wavelength). Though this
may seem  confusing at first (``why is my first spec number 2?'') this preserves subsetting
hierarchy: using  \code{plot(teal, select=2)} will show the same spectra that would be selected if
you use  \code{teal[ ,2]}.

\subsubsection{The \code{heatmap} Option}

Since this dataset is three-dimensional (containing wavelengths, reflectance values and incident
angles) we can also use the \code{heatmap} function. First, it will be necessary to define a vector
for the incident angles each spectrum was measured at:

<<>>=
angles <- seq(15, 70, by = 5)
@

 Next, we will smooth the data with \code{procspec} and plot as a false color map (heatmap):
 
<<label=heatmap,fig=T,include=F>>=
teal.sm <- procspec(teal, opt=c('smooth'))
plot(teal.sm, type = 'h', varying = angles, ylab = expression(paste("Incident angle (", degree, ")")), 
     las = 1, useRaster = TRUE)
@
\begin{figure}[H]
\begin{center}
\includegraphics[width=4in]{fig/pavo-heatmap}
\end{center}
\caption{Heatmap plot for angle-resolved reflectance measurements of the green-winged teal.}
\label{figure:heatmap}
\end{figure}

These plots can be very useful to observe changes over time, for example, or any other type of 
continuous variation.

\subsection{The \code{aggplot} Function}

\code{aggplot} has a very similar interface to \code{aggspec}, allowing for quick plotting of
aggregated spectra combined by a factor, such as species, sex, experimental treatment, and so on.
Its  main output is a plot with lines of group mean spectra outlined by a shaded area indicating
some  measure of variability, such as the standard deviation of the group. Note that functions that
aren't  already implemented in R must be passed like they would be to functions such as \code{apply}
(e.g., \code{function(x)sd(x)/sqrt(length(x))} in the example below).

<<label=aggplot, fig=TRUE, include=FALSE, width=8, height=4>>=
par(mfrow=c(1,2), mar=c(4,4,2,2), oma=c(2,0,0,0))
#plot using median and standard deviation, default colors
aggplot(mspecs, spp, FUN.center=median, lwd=2, alpha=0.3)
#plot using mean and standard error, in greyscale
aggplot(mspecs, spp, FUN.error=function(x)sd(x)/sqrt(length(x)), 
        lwd=2, lty=1:7, lcol=1, shadecol='grey',  alpha=0.7)
@
\begin{figure}[H]
\begin{center}
\includegraphics[width=6in]{fig/pavo-aggplot}
\end{center}
\caption{Example plots created using \code{aggplot}. Left: using median, standard deviation, and colored lines. Right: using mean, standard error, and greyscale}
\label{figure:aggplot}
\end{figure}

\section{Analyzing Spectral Data}

\subsection{Overview}

\pavo{} offers two main approaches for spectral data analysis. First, color variables can be
calculated based on the shape of the reflectance spectra. By using special \code{R} classes for
spectra data frame objects, this can easily be done using the \code{summary} function with an rspec
object (see below). The function \code{peakshape} also
returns descriptors for individual peaks in spectral curves, as outlined below.

Second, reflectance spectra can be analyzed by accounting for the visual system receiving the color
signal, therefore representing reflectance spectra as perceived colors. We have implemented Endler's
(REF) segment classification method, which approximates visual models but does not directly  use
sensory information; the model of Osorio \& Vorobyev (REF), which provides a flexible  framework for
visual modeling; and the tetrahedral color space (GOLDSMITH, ENDLER, STODDARD)  which has been
extensively developed to represent colors in the avian vision color space.

\subsection{Spectral Shape Analysis}

\subsubsection{Trichromatic Variables}

Obtaining trichromatic color variables (peratining to hue, saturation and brightness/value) is
pretty straightforward in \pavo{}. Since reflectance spectra is stored in an object of class
\code{rspec}, the \code{summary} function recognizes the object as such and extracts 23  variables,
as outlined in MONTGOMERIE. Though outlined in a book chapter on bird coloration,  these variables
are broadly applicable to any reflectance data, particularly if the taxon of  interest has color
vision within the UV-human visible range.

The description and formulas for these variables can be found in Table \ref{table:tristim}.

<<results=hide>>=
summary(spec.sm)
@


<<echo=FALSE>>=
round(summary(spec.sm),2)
@

\begin{table}
\begin{center}
\setlength{\extrarowheight}{4pt}
\begin{tabular}{l l} \hline
{\bf Color variable} & {\bf Description} \\ 
\hline
{$B_1 = \sum_{\lambda_{min}}^{\lambda_{max}} R_\lambda$} & \parbox[t]{3in}{\textbf{Total reflectance}: sum of reflectance values over all wavelengths.}  \\
{$B_2 = B_{1}/n_{wl}$} & \parbox[t]{3in}{\textbf{Mean brightness}: average reflectance over all wavelengths.} \\
{$B_3 = R_\text{max}$} & \parbox[t]{3in}{\textbf{Intensity}: Peak reflectance of the spectrum.} \\
{$S_1 = \sum_{\lambda_a}^{\lambda_b} R_\lambda/B_{1}$} & \parbox[t]{3in}{\textbf{Chroma}: segment-specific chroma calculated by dividing the sum of reflectance values over region of interest (e.g., from $\lambda_a$ to $\lambda_b$) by the total reflectance.} \\
{$S_2 = R_\text{max}/R_\text{min}$} & \parbox[t]{3in}{\textbf{Spectral saturation}: ratio of maximum and minimum reflectance values.} \\
{$S_3 = \sum_{\lambda_{R\text{max}}-50}^{\lambda_{R\text{max}}+50} R_i/B_{1}$} & \parbox[t]{3in}{\textbf{Chroma}: sum of reflectance values +/- 50 nm from the wavelength of peak reflectance (hue, $\lambda_\text{max}$)} \\
{$S_4 = |b\text{max}_\text{neg}|$} & \parbox[t]{3in}{\textbf{Spectral purity}: maximum negative slope of spectrum over range of wavelengths.} \\
{$S_5 = \sqrt{(B_r-B_g)^2+(B_y-B_b)^2}$} & \parbox[t]{3in}{\textbf{Chroma}: Euclidean distance from achromatic origin using segment classification method (see section \ref{sec:segclass}).} \\
{$S_6 = R_\text{max}-R_\text{min}$} & \parbox[t]{3in}{\textbf{Contrast/amplitude}: difference in reflectance between high and low points in the spectrum.} \\
{$S_7 = (\sum_{\lambda_{min}}^{\lambda_R{mid}}R_i - \sum_{\lambda_R{mid}}^{\lambda_{max}}R_i)/B_{1}$} & \parbox[t]{3in}{\textbf{Spectral saturation}: reflectance difference between the minimum wavelength and the half-max reflectance and the maximum wavelength and the half-max reflectance. Analogous to the segment classification method (see section \ref{sec:segclass})} \\
{$S_8 = (R_\text{max}-R_\text{min})/B_2$} & \parbox[t]{3in}{\textbf{Chroma}: relative difference between max and min reflectance taking into account the average brightness ($B2$) of the spectrum.} \\
{$S_9 = (R_{\lambda{450}}-R_{\lambda{700}})/R_{\lambda{700}}$} & \parbox[t]{3in}{\textbf{Carotenoid chroma}: relative reflectance in the region of greatest reflectance in carotenoid-based colors} \\
{$S_{10} = [(R_{max}-R_{min})/B_2]\times|b\text{max}_\text{neg}|$} & \parbox[t]{3in}{\textbf{Peaky chroma}: relative contrast (S8) multiplied by the spectral purity (S4). Relatively flat curves will give low vales for this metric, and vice versa.} \\
{$H_1 = \lambda_{R\text{max}}$} & \parbox[t]{3in}{\textbf{Hue}: wavelength of peak reflectance.} \\
{$H_2 = \lambda_{b\text{max}_\text{neg}}$} & \parbox[t]{3in}{\textbf{Hue}: wavelength at location of maximum negative slope in the spectrum.} \\
{$H_3 = \lambda_{R\text{mid}}$} & \parbox[t]{3in}{\textbf{Hue}: wavelength at the midpoint ([$R_\text{max} + R_\text{min}]/2$) in the reflectance spectrum.} \\
{$H_4 = atan\{[(B_y-B_b)/B_1]/[(B_r-B_g)/B_1]\}$} & \parbox[t]{3in}{\textbf{Hue}: the angle from 0\ensuremath{^\circ} (red) calculated by the segment classification method (see section \ref{sec:segclass}).} \\
{$H_5 = \lambda_{b\text{max}_\text{pos}}$} & \parbox[t]{3in}{\textbf{Hue}: wavelength at point in spectrum where curve reaches a maximum postitive slope.} \\
\hline
\end{tabular}
\end{center}
\caption{\label{table:tristim}
The complete set of tristimulus variables calculated by \code{summary} in \pavo{}}
\end{table}

\clearpage{}

\subsubsection{Peak Shape Descriptors}

Particularly in cases of reflectance spectra that have multiple discrete peaks (in which case the
\code{summary} function will only return variables based on the tallest peak in the curve), it might
be useful to obtain variables that describe individual peak's properties. The \code{peakshape}
function identifies the peak location (\code{H1}),  returns the reflectance at that point
(\code{B3}), and identifies the wavelengths at which the reflectance is half that at the peak,
calculating the wavelength bandwith of that interval (the Full Width at Half Maximum, or
\code{FWHM}). The function also returns the half widths, which are useful when the peaks are located
near the edge of the measurement limit and half maximum reflectance can only be reliably estimated
from one of its sides.

If this all sounds too esoteric, fear not: \code{peakshape} has the option of returning plots
indicating what it's calculating. The vertical continuous red line indicates the peak location, the
horizontal continuous red line indicates the half-maximum reflectance, and the distance between the
dashed lines (\code{HWHM.l} and \code{HWHM.r}) is the FWHM:

<<label=fwhm, fig=TRUE, include=FALSE, width=6, height=4>>=
par(mfrow=c(2,3),mar = c(5, 4, 0.5, 0.5) + 0.1)
peakshape(spec.sm, plot=T)
@
\begin{figure}[H] % h=here, t=top, b=bottom, p=floating page
\begin{center}
\includegraphics[width=5in]{fig/pavo-fwhm}
\end{center}
\caption{Plots from \code{peakshape}}
\label{figure:fwhm}
\end{figure}

As it can be seen, the variable FWHM is meaningless if the curve doesn't have a clear peak.
Sometimes, such as in the case of the Cardinal (Figure \ref{figure:fwhm}, first panel), there might
be a  peak which is not the point of maximum reflectance of the entire spectral curve. The half-
width  can also be erroneously calculated when there are two peaks, as can be seen in the case of
the  Tanager (Figure \ref{figure:fwhm}, last panel). In this case, it's useful to set bounds when
calculating the FWHM by using the \code{bounds} argument. \code{peakshape} also offers a
\code{select} argument to facilitate subsetting the spectra data frame to, for example, focus on a
single reflectance peak:

<<label=fwhm2, fig=TRUE, include=FALSE>>=
peakshape(spec.sm, select=2, bounds=c(300,500), plot=T)
@
\begin{figure}[H] % h=here, t=top, b=bottom, p=floating page
\begin{center}
\includegraphics[width=3in]{fig/pavo-fwhm2}
\end{center}
\caption{Plot from \code{peakshape}, setting the bounds to 300-500nm}
\label{figure:fwhm2}
\end{figure}

\subsection{Visual System Models}

\subsubsection{Segment Classification Analysis}
\label{sec:segclass}

The segment classification analysis (Endler 1990) does not assume any particular visual system, but
instead tries to classify colors in a manner that captures common properties of many vertebrate (and
some invertebrate) visual systems. In essence, it breaks down the reflectance spectrum region of
interest into four equally-spaced regions, measuring the relative signal along those regions. This
approximates a trichromatic opponency system with short, medium, and long-wavelength sensitive
photoreceptors.

Though somewhat simplistic, this model captures many of the properties of other, more complex visual
models, but without many of the additional assumptions these make. It also provides results in a fairly
intuitive color space, in which the angle corresponds to hue and the distance from the center
corresponds to chroma (Figure \ref{figure:segplot}; in fact, variables \code{S5} and \code{H4} from
\code{summary.rspec} are calculated from these relative segments, see Table \ref{table:tristim}).
Note  that, while a segment analysis ranging from 300 or 400nm to 700nm corresponds quite closely to
the  human visual system color wheel, any wavelength range can be analyzed in this way, returning a
360\ensuremath{^\circ} hue space delimited by the range used (\code{segclass} (see below) accepts the
argument \code{range} for user-specified limits that don't match the data range).

The segment differences or ``opponents'' are calculated as:

\begin{subequations}\label{eqsegment}
\begin{align}
LM = \frac{ R_\lambda \sum_{\lambda={Q4}} R_\lambda - \sum_{\lambda={Q2}} R_\lambda }{\sum_{\lambda={min}}^{max}R_\lambda} \\
MS = \frac{ R_\lambda \sum_{\lambda={Q3}} R_\lambda - \sum_{\lambda={Q1}} R_\lambda }{\sum_{\lambda={min}}^{max}R_\lambda}
\end{align}
\end{subequations}

Where $Qi$ represent the interquantile distances (e.g. for the human visible range, $Q_1=blue$, $Q_2=green$, $Q_3=yellow$ and $Q_4=red$)

In \pavo{}, the segment classification model is obtained through the function \code{segclass}:

<<>>=
segclass(spec.sm)
@

where \code{LM} and \code{MS} are the segment differences or ``opponents'' (Eqn \ref{eqsegment}). 

The example below uses idealized reflectance spectra to illustrate how the avian color space defined 
from the segment classification maps to the human color wheel:

<<label=segplot, results=hide, fig=TRUE, include=FALSE, width=6, height=4>>=
# creating idealized specs with varying hue
fakedata1 <-  sapply(seq(100,500,by=20), 
                     function(x) rowSums(cbind(dnorm(300:700,x,30), 
                                               dnorm(300:700,x+400,30))))

# creating idealized specs with varying saturation
fakedata2 <- sapply(c(500, 300, 150, 105, 75, 55, 40, 30), 
                     function(x) dnorm(300:700,550,x))

# combining and converting to rspec
fakedata.c <- data.frame(wl=300:700, fakedata1, fakedata2)
fakedata.c <- as.rspec(fakedata.c)
fakedata.c <- procspec(fakedata.c, "max")

fakedata1 <- as.rspec(data.frame(wl=300:700,fakedata1))
fakedata1 <- procspec(fakedata1, "max")
fakedata2 <- as.rspec(data.frame(wl=300:700,fakedata2))
fakedata2 <- procspec(fakedata2, "max")

# segment classification analysis
seg.fdc <- segclass(fakedata.c)

# plot results
layout(cbind(1,2,3), widths=c(1,1,3))
par(mar=c(5,4,2,0.5))
plot(fakedata1, type='stack', col=spec2rgb(fakedata1)) 
par(mar=c(5,2.5,2,1.5))
plot(fakedata2, type='stack', col=spec2rgb(fakedata2)) 
par(mar=c(5,4,2,0.5))
plot(seg.fdc, pch=20, cex=3, col=spec2rgb(fakedata.c))
@
\begin{figure}[H] % h=here, t=top, b=bottom, p=floating page
\begin{center}
\includegraphics[width=5in]{fig/pavo-segplot}
\end{center}
\caption{Idealized reflectance spectra and their projection on the axes of segment classification}
\label{figure:segplot}
\end{figure}

\subsubsection{Photon Catch \& Receptor Noise Model}

Several models have been developed to understand how colors are perceived and discriminated by an
individual's or species' receptor visual system (Described in detail in ENDLER, OSORIO). In essence,
these models take into  account the receptor sensitivity of the different cones that make the visual
system in question and  quantify how a given color would stimulate those cones individually and the
combined effect on the perception of  color. These models also have an important component of
assuming and interpreting the chromatic  component of color (hue and saturation) to be processed
independently of the achromatic (brightness,  or luminance) component. It provides a flexible
framework allowing for a tiered model construction, in  which information on aspects such as
different illumination sources, backgrounds, and visual systems  can be considered and compared.

To apply these models, first we need to quantify cone excitation and then consider how the signal is
being processed, considering the relative density of different cones and the noise-to-signal ratio.

\textbf{Photon Catch.} To quantify the stimulation of cones by the emitted color, we will use the \pavo{} function \code{vismodel}. This function takes an \code{rspec} dataframe as a minimal input, and the user can either select from the available options or input its own data for the additional arguments in the function:

\begin{itemize}
  \item\code{visual}: the visual system to be used. Available options are the avian average UV \& average V visual systems, blue tit, starling and peafowl. Alternatively, the user may include its own dataframe, with the first column being the wavelength range and the following columns being the absorbance at each wavelength for each cone type (see below for an example).
	\item\code{achromatic}: Either a cone's sensitivity data (avaiable options are blue tit and chicken double cones), which can also be user-defined as above; or the sum of the two longest-wavelength cones can be used (with the \code{ml} option). Alternatively, \code{none} can be specified for no achromatic stimulation calculation.
	\item\code{illum}: The illuminant being considered. By default, it considers an ideal white iluminant, but implemented options are a blue sky, standard daylight, and forest shade illuminants. A vector of same length as the wavelength range being considered can also be used as the input.   
  \item\code{bkg}: The background being considered. By default, it considers an idealized background (i.e. wavelength-independent influence of the background on color). A vector of same length as the wavelength range being considered can also be used as the input.
\end{itemize}

(For more information, see \code{?vismodel})

IMPORTANT: The function also has an additional logical argument, \code{relative}. If \code{TRUE}, it 
will make the cone stimulations relative to their sum. \textit{For the photon catch and neural noise 
model, it is important to set} \code{relative=FALSE}.

For this example, we will use the average reflectance of the different species to calculate their 
stimulation of retinal cones, considering the avian average UV visual system, a standard daylight 
illumination, and an idealized background.

<<results=hide>>=
vismod1 <- vismodel(sppspec, visual = "avg.uv", illum='D65', relative=FALSE)
vismod1
@

<<echo=FALSE>>=
sapply(vismod1, function(x) round(x,4))
@

The function returns an object of class \code{vismodel} that lists three components:

\begin{itemize}
\item\code{Qi}: The receptor quantum catches, calculated for  receptor $i$ as:
\begin{equation}
Q_i = \int_\lambda{R_i(\lambda)S(\lambda)I(\lambda)d\lambda} ,
\end{equation}
Where $\lambda$ denotes the wavelength, $R_i(\lambda)$ the spectral sensitivity of receptor $i$, $S(\lambda)$ the reflectance spectrum of the color, and $I(\lambda)$ the illuminant spectrum.

\item\code{qi}: The receptor quantum catches normalized to the background, thus accounting for receptor adaptation, by multiplying $Q_i$ by a constant $k$. The coefficient $k$ describes the von Kries transformation:
\begin{equation}
k_i = \frac{1} { \int_\lambda{R_i(\lambda)S^b(\lambda)I(\lambda)d\lambda }, }
\end{equation}
Where $S^b$ denotes the reflectance spectra of the background.

\item\code{fi}: The receptor quantum catches transformed according to Fechner's law, in which the signal of the receptor is proportional to the logarithm of the quantum catch \textendash i.e. $f_i = ln(Q_i)$
\end{itemize}

We can easily visualize what these models are doing by comparing the reflectance spectra to the quantum catches they are generating:

<<label=usmlplot,fig=T,include=F,width=8.5,height=6.5>>=
par(mfrow=c(2,6), oma=c(3,3,0,0))
layout(rbind(c(2,1,4,3,6,5), c(1,1,3,3,5,5), c(8,7,10,9,12,11), c(7,7,9,9,11,11)))
for (i in 1:6) {
  par(mar=c(2,2,2,2))
  plot(sppspec, select = i + 1, col = spec2rgb(sppspec)[i], lwd = 3, ylim = c(0,100))
  par(mar=c(4.1,2.5,2.5,2))
  barplot(vismod1$qi[i,1:4], yaxt='n', col='black')
}
mtext("Wavelength (nm)", side=1, outer=T, line=1)
mtext("Reflectance (%)", side=2, outer=T, line=1)
@

\begin{figure}[H] % h=here, t=top, b=bottom, p=floating page
\begin{center}
\includegraphics[width=5in]{fig/pavo-usmlplot}
\end{center}
\caption{Plots of species mean reflectance curves with corresponding relative usml cone stimulations (insets).}
\label{figure:usmlplot}
\end{figure}

As described above, \code{vismodel} also accepts user-defined visual systems, background and 
illuminants. We will illustrate this by showcasing the function \code{sensmodel}, which models 
spectral sensitivities of retinas based on their peak cone sensitivity, as described in Govardovskii 
et al. (2000) and Hart \& Vorobyev (2005). \code{sensmodel} takes several optional arguments, but the 
main one is a vector containing the peak sensitivities for the cones being modeled. Let's model an 
idealized dichromat visual system, with cones peaking in sensitivity at 350 and 650 nm:

<<label=dichro, fig=TRUE, include=FALSE>>=
idealizeddichromat <- sensmodel(c(350,650))
plot(idealizeddichromat, col=spec2rgb(idealizeddichromat))
@
\begin{figure}[H] % h=here, t=top, b=bottom, p=floating page
\begin{center}
\includegraphics[width=2in]{fig/pavo-dichro}
\end{center}
\caption{Idealized dichromat photoreceptors created using \code{sensmodel}}
\label{figure:dichro}
\end{figure}

<<results=hide>>=
vismod.idi <- vismodel(sppspec, visual = idealizeddichromat, relative=FALSE)
vismod.idi
@

<<echo=FALSE>>=
sapply(vismod.idi, function(x) round(x,4))
@

\textbf{Receptor Noise.} Color distances can be calculated under this model while considering receptor
noise by using the inverse of the noise-to-signal ratio, known as the Weber fraction ($w_i$ for each
cone $i$). The Weber fraction can  be calculated from the noise-to-signal ratio of cone $i$  ($v_i$)
and the relative number of receptor  cells of type $i$ within the receptor field ($n_i$):

\begin{equation}
w_i = \frac{v_i}{\sqrt{n_i}} 
\end{equation}

Color distances are obtained by weighting the Euclidean distance of the photoreceptor quantum
catches  by the Weber fraction of the cones ($\Delta S$). These measurements are in units of Just
Noticeable  Differences (JNDs), where distances over a certain threshold (usually 1) are considered
to be  discernible under the conditions considered (e.g., backgrounds, illumination). The equations
used in these calculations are:

%\tiny
%\begin{subequations}\label{eqsegment}
%\begin{align}
%\text{for dichromats: }
%\Delta S = \sqrt{\frac{(\Delta f_1 - \Delta f_2)^2}{w_1^2+w_2^2}} \\
%\text{for trichromats: }
%\Delta S = \sqrt{\frac{
%w_1^2(\Delta f_3 - \Delta f_2)^2 + 
%w_2^2(\Delta f_3 - \Delta f_1)^2 + 
%w_3^2(\Delta f_1 - \Delta f_2)^2}
%{(w_1w_2)^2 + (w_1w_3)^2 + (w_2w_3)^2}}\\
%\text{for tetrachromats: }
%\Delta S = \sqrt{\frac{
%(w_1w_2)^2(\Delta f_4 - \Delta f_3)^2 + 
%(w_1w_3)^2(\Delta f_4 - \Delta f_2)^2 +
%(w_1w_4)^2(\Delta f_3 - \Delta f_2)^2 +
%(w_2w_4)^2(\Delta f_3 - \Delta f_1)^2 +
%(w_3w_4)^2(\Delta f_2 - \Delta f_1)^2 }
%{(w_1w_2w_3)^2 + (w_1w_2w_4)^2 + (w_1w_3w_4)^2 + (w_2w_3w_4)^2} }
%\end{align}
%\end{subequations}
%\normalsize

For dichromats:
\begin{equation}
\Delta S = 
\sqrt{
\begin{aligned}
\frac{(\Delta f_1 - \Delta f_2)^2}{w_1^2+w_2^2}
\end{aligned}
}
\end{equation}


For trichromats:
\begin{equation}
\Delta S = 
\sqrt{
\begin{aligned}
\frac{w_1^2(\Delta f_3 - \Delta f_2)^2 + 
w_2^2(\Delta f_3 - \Delta f_1)^2 + 
w_3^2(\Delta f_1 - \Delta f_2)^2 }
{ (w_1w_2)^2 + 
(w_1w_3)^2 + 
(w_2w_3)^2 }
\end{aligned}
}
\end{equation}


For tetrachromats:
\begin{equation}
\Delta S = 
\sqrt{
\begin{aligned}
\Big[(w_1w_2)^2(\Delta f_4 - \Delta f_3)^2 + 
(w_1w_3)^2(\Delta f_4 - \Delta f_2)^2 + 
(w_1w_4)^2(\Delta f_3 - \Delta f_2)^2 + \\ 
(w_2w_3)^2(\Delta f_4 - \Delta f_1)^2 + 
(w_2w_4)^2(\Delta f_3 - \Delta f_1)^2 + 
(w_3w_4)^2(\Delta f_2 - \Delta f_1)^2\Big] & / & \\
\Big[ (w_1w_2w_3)^2 + 
 (w_1w_2w_4)^2 + 
(w_1w_3w_4)^2 + 
(w_2w_3w_4)^2\Big]
\end{aligned}
}
\end{equation}

For the chromatic contrast. The achromatic contrast ($\Delta L$) can be calculated based on the double 
cone or the receptor (or combination of receptors) responsible for chromatic processing by the 
equation (SIDDIQUI 2004):

\begin{equation}
\Delta L =  \left|\frac{\Delta f^2}{w^2}\right|
\end{equation}

\pavo{} implements these calculations in the function \code{coldist}. For the achromatic contrast, 
\code{coldist} uses \code{n4} to calculate $w$ for the achromatic contrast. The user 
can also specify if the function should use $Q_i$, $q_i$ or $f_i$ in the equations (that is, if the 
von Kries correction and Fechner's law transformation should be applied). Note that even if $Q_i$ or 
$q_i$ are chosen, values are still log-transformed. This option is available in case the 
user wants to specify a data frame of quantum catches that was not generated by \code{vismodel} as an 
input.

<<>>=
coldist(vismod1, vis='tetra', qcatch='fi', n1=1, n2=2, n3=2, n4=4, v=0.1)
coldist(vismod.idi, vis='di', qcatch='fi', n1=1, n2=1,  v=0.05)
@

Where \code{dS} is the chromatic contrast ($\Delta S$) and \code{dL} is the achromatic contrast 
($\Delta L$). As expected, values are really high under the avian color vision, since the colors of 
these species are quite different (see Figure \ref{figure:usmlplot}) and because of the enhanced discriminatory ability with four compared to two cones.

\subsubsection{Tetrahedral Color Space Model}

Another visual model representation that has become quite popular, especially in avian biology
studies,  is the color space model. In this model, photon catches are expressed in relative values
(so that the  the quantum catches of all cones involved in chromatic discrimination sum to 1). The
maximum stimulation of each cone $n$ is placed at the vertex of a $(n-1)$-dimensional polygon that
encompasses all theoretical colors that can be perceived by that visual system. Therefore, for the
avian visual system  comprised of 4 cones, all colors can be placed somewhere in the volume of a
tetrahedron, in which each  of the four vertices represents the maximum stimulation of that
particular cone type.  %(Figure \ref{figure:tcs}).

Though this model does not account for receptor noise (and thus does not allow an estimate of JNDs), 
it presents several advantages. First, it makes for a very intuitive
representation of color points accounting for attributes of the color vision of the signal receiver.
Second, and perhaps most importantly, it allows for the calculation of several interesting variables
that represent color. For example, hue can be estimated from the angle of the point relative to the
xy plane (blue-green-red) and the z axis (UV); saturation can be estimated as the distance of the
point from the achromatic center.

In \pavo{} the tetrahedral color space is implemented in the function \code{tcs}, after the 
calculation of relative quantum catches using \code{vismodel} with the (default) option 
\code{relative=TRUE}.

<<echo=TRUE, results=hide>>=
vismod2 <- vismodel(sppspec)
tcs(vismod2)
@

<<echo=FALSE>>=
round(tcs(vismod2), 2)
@

By default, \code{tcs} will use $Q_i$ for the calculations (that is, \emph{not} log-transformed, as 
recommended by STODDARD \& PRUM), but $q_i$ or $f_i$ may be specified if desired 
(e.g. \code{tcs(vismod2\$fi)}).


\code{tcs} returns the original photon catch values; the relative cone stimulation for a given hue
(\code{x.r}; see the supplemental material of STODDARD \& PRUM for more information); the two angles
of  hue (\code{h.theta} and \code{h.phi}) and the distance from the achromatic center
(\code{r.vec});  along with the maximum distance achievable for that hue (\code{r.max}) and the
proportion of that  maximum achieved by the color point (\code{r.achieved}).

\textbf{Summary variables for groups of points}. Another advantage of the tetrahedral color space
model is that it allows for the calculation of useful summary statistics of groups of points, such
as  the centroid of the points, the total volume occupied, the mean and variance of hue span and the
mean  saturation. In \pavo{}, the result of a \code{tcs} call is an object of class tcs, and thus
these  summary statistics can be calculated simply by calling \code{summary}:

<<>>=
summary(tcs(vismod2))
@

In addition, the \code{summary} call can take a \code{by} vector of group identities, so that the
variables are calculated for each group separately. For example we could use the tetrahedral
colorspace  model to represent the spectra of all individuals measured, and calculate the summary
statistics for  these points per species:

<<>>=
tcs.mspecs <- tcs(vismodel(mspecs))
summary(tcs.mspecs, by=spp)
@

\textbf{Plotting options}. There are two useful plots for the tetrahedral color space model. The
first is a three-dimensional plot of the volume, which is implemented in \pavo{} as an interactive
plot that the user can spin around and zoom, and can be called by the function \code{ttplot}:

<<results=hide>>=
ttplot(tcs.mspecs, col=spec2rgb(mspecs), size=0.01)
# rgl.postscript('pavo-tcsplot.pdf',fmt='pdf')
@

The accessory functions \code{ttpoints} and \code{ttvol} can be used, in addition, to plot
additional points or the convex hull determining the volume occupied by the points:

<<results=hide>>=
ttplot(tcs(vismod2), size=0)
ttvol(tcs(vismod2))
# rgl.snapshot('pavo-tcsvolplot.png')
@

\begin{figure}
        \centering
        \begin{subfigure}[b]{0.45\textwidth}
                \centering
                \includegraphics[width=\textwidth]{fig/pavo-tcsplot}
                \caption{Tetrahedral color space plot}
                \label{fig:tcs1}
        \end{subfigure}%
        \begin{subfigure}[b]{0.45\textwidth}
                \centering
                \includegraphics[width=\textwidth]{fig/pavo-tcsvolplot}
                \caption{Tetrahedral plot with convex hull volume}
                \label{fig:tcs2}
        \end{subfigure}
         \caption{Example plots obtained using \code{ttplot}. Plot on the left was exported as pdf, while the one on the right was exported as png.}\label{fig:tcs}
\end{figure}

Another plotting option available is \code{projplot}, which projects color points in the surface of
a  sphere encompassing the tetrahedron. This plot is particularly useful to see differences in hue.
As we  can see in Figure \ref{figure:proj}, points are mostly concentrated in the south and west
``hemispheres'', indicating colors with low UV content and concentrated in green-red areas of
colorspace.

<<label=proj, fig=TRUE, include=FALSE>>=
projplot(tcs.mspecs, pch=20, col=spec2rgb(mspecs))
@

\begin{figure}[H] % h=here, t=top, b=bottom, p=floating page
\begin{center}
\includegraphics[width=4in]{fig/pavo-proj}
\end{center}
\caption{Projection plot from a tetrahedral color space}
\label{figure:proj}
\end{figure}


\textbf{Color Volume Overlap.} Finally, a useful function available in \pavo{} is \code{voloverlap},
which calculates the overlap in tetrahedral color volume between two sets of points. This can be
useful to explore whether different species occupy similar (overlapping) or different (non-
overlapping) "sensory niches" (REF?). To show this  function, we will use the \code{sicalis}
dataset, which includes measurements from the crown (C),  throat (T) and breast (B) of seven stripe-
tailed yellow finches (\textit{Sicalis citrina}).

<<label=sicalis, fig=TRUE, include=FALSE>>=
data(sicalis)
aggplot(sicalis, by=rep(c('C','T','B'), 7))
@

\begin{figure}[H] % h=here, t=top, b=bottom, p=floating page
\begin{center}
\includegraphics[width=3in]{fig/pavo-sicalis}
\end{center}
\caption{\code{aggplot} of the \code{sicalis} data (blue: crown, red: throat, green: breast)}
\label{figure:sicalis}
\end{figure}

We will use this dataset to test for the overlap between the volume determined by the measurements
of those body parts from multiple individuals in the tetrahedral colorspace (note the option
\code{plot} for plotting of the volumes:

<<>>=
tcs.sicalis.C <- tcs(vismodel(sicalis[c(1,grep('\\.C',names(sicalis)))]))
tcs.sicalis.T <- tcs(vismodel(sicalis[c(1,grep('\\.T',names(sicalis)))]))
tcs.sicalis.B <- tcs(vismodel(sicalis[c(1,grep('\\.B',names(sicalis)))]))
#voloverlap(tcs.sicalis.T,tcs.sicalis.B, plot=T)
#voloverlap(tcs.sicalis.T,tcs.sicalis.C, plot=T) 
voloverlap(tcs.sicalis.T,tcs.sicalis.B)
voloverlap(tcs.sicalis.T,tcs.sicalis.C)
@

\code{voverlap} gives the volume ($V$) of the convex hull delimited by the overlap between the two
original volumes, and two proportions are calculated from that: $V_{smallest} = V_{overlap} /
V_{smallest}$ and $V_{both} = V_{overlap} / (V_A + V_B)$. Thus, if one of the volumes is entirely
contained in the other, \code{vsmallest} will equal 1.

So we can clearly see that there is overlap between the throat and breast colors (of about 6\%), but
not between  the throat and the crown colors (Figure \ref{figure:overlap}).

\begin{figure}
        \centering
        \begin{subfigure}[b]{0.45\textwidth}
                \centering
                \includegraphics[width=\textwidth]{fig/pavo-overlap1}
                \caption{Throat and Breast Overlap}
                \label{fig:ov1}
        \end{subfigure}%
        \begin{subfigure}[b]{0.45\textwidth}
                \centering
                \includegraphics[width=\textwidth]{fig/pavo-overlap2}
                \caption{Throat and Crown overlap}
                \label{fig:ov2}
        \end{subfigure}
         \caption{Color volume overlaps. Shaded area in panel \label{fig:ov1} represents the overlap between those two sets of points.}\label{figure:overlap}
\end{figure}

\end{document}