\documentclass{article}

% Definitions
\newcommand{\pavo}{{\tt pavo}}  % you can use \pavo{} to print pavo in code text formatting
\newcommand{\code}[1]{{\tt #1}}  % text formate for code
\setlength{\parindent}{0in}
\setlength{\parskip}{.1in}
\setlength{\textwidth}{140mm}
\setlength{\oddsidemargin}{10mm}
\usepackage{amsmath}
\usepackage{hyperref}
\usepackage{float}
\usepackage{authblk}
\usepackage[usenames,dvipsnames]{color}
\usepackage{graphicx}
\usepackage{caption}
\usepackage{subcaption}
\usepackage[utf8]{inputenc}
\usepackage{array}
\usepackage{geometry} 
\geometry{letterpaper, textwidth=5.5in, textheight=8.5in, marginparsep=7pt, marginparwidth=.6in}
%\setlength\parindent{0in}

% define colors
\hypersetup{
  colorlinks,
  citecolor=violet,
  linkcolor=black,
  urlcolor=MidnightBlue
  }
\renewcommand{\thefootnote}{\textcolor{Gray}{\arabic{footnote}}}


\begin{document}


\SweaveOpts{concordance=TRUE, prefix.string=pavo}

<<echo=FALSE, results=hide>>=
library(pavo)
ps.options(pointsize=12)
options(width=60)
@

\title{\pavo{}: {\bf P}erceptual {\bf A}nalysis, {\bf V}isualization and {\bf O}rganization of Spectral Color Data in R}
\author[1]{Rafael Maia}
\author[2]{Pierre-Paul Bitton}
\author[1]{Chad Eliason}
\affil[1]{Integrated Bioscience PhD Program, University of Akron, Akron OH}
\affil[2]{Department of Biological Sciences, University of Windsor, Windsor ON}
\maketitle

\addtolength{\parskip}{-.08in}
\tableofcontents
\addtolength{\parskip}{.08in}

\section{Introduction}

\pavo{} is an R package developed with the goal of establishing a flexible and integrated  workflow
for working with spectral color data. It includes functions that take advantage of new data classes
in order to work seamlessly from importing raw data to visualization and  analysis.

Although \pavo{} deals largely with spectral reflectance data from bird feathers, it is meant  to be
applicable for a range of taxa and applications. It provides flexible ways to input spectral data
from a variety of equipment manufacturers, process these data, extract variables  and produce
publication-quality graphics.

\pavo{} was written with the following workflow in mind:

% numbered list of things
\begin{enumerate}
\item {\bf Organize} spectral data by inputting files, processing spectra (e.g., to remove
noise, negative values, smooth curves, etc.)
\item {\bf Analyze} the resulting files, either using typical tristimulus color variables (hue,
saturation, brightness) or using visual models based on perceptual data from the taxon of 
interest.
\item {\bf Visualize} the output, with multiple options provided for exploratory analyses.
\end{enumerate}

Below we will show the main functions in the package in an example workflow. The development
version of \pavo{} can be found on \href{https://github.com/rmaia/pavo}{github}.

\section{Dataset Description}

The data used in this example is available from 
\href{https://github.com/rmaia/pavo/blob/master/vignette_data/vignette_data.zip}
{github by clicking here}\footnote{in case you can't click the printed version you have:\\ 
\url{https://github.com/rmaia/pavo/blob/master/vignette_data/vignette_data.zip}}. 
You can download and extract it to follow the vignette.

The data consists of reflectance spectra obtained using Avantes equipment and software from seven
bird species: Northern Cardinal (\emph{Cardinalis cardinalis}), Wattled Jacana (\emph{Jacana
jacana}), Baltimore Oriole (\emph{Icterus galbula}), Peach-fronted Parakeet (\emph{Aratinga
aurea}), American Robin (\emph{Turdus migratorius}),  and Sayaca Tanager  (\emph{Thraupis sayaca}).
Several individuals were measured (sample size varies by species), and  3 spectra were collected
from each individual.

The samples do not have the same sample sizes and have additional peculiarities that should
emphasize the flexibility \pavo{} offers, as we'll see below.

\section{Organizing and Processing Spectral Data}

\subsection{Importing Data}

The first thing we need to do is import the spectral data into R using the funciton
\code{getspec()}. Since the spectra were obtained using Avantes software, we will need to  specify
that the files have the "\code{.ttt}" extension. Further, the data is organized in  subdirectories
for each species. \code{getspec} does recursive sampling, and may include the  names of the
subdirectories in the spectra name if desired. A final issue with the data is that  it was collected
using a computer with international numbering input, which means it uses commas  instead of periods
as a decimal separator. We can specify that in the function call.

I have downloaded the file and placed it in a directory called 
``\nolinkurl{/github/pavo/vignette_data}''. By default, \code{getspec} will search for files in 
the current folder, but a different one can be specified:

<<>>=
specs <- getspec("~/github/pavo/vignette_data/", ext="ttt", decimal=",", 
                 subdir=T, subdir.names=F)
specs[1:10,1:4]
dim(specs) #data has 214 spectra, from 300 to 700 nm
@

When \pavo{} imports spectra, it creates an object of class \code{rspec}, which inherits attributes
from the \code{data.frame} class:

<<>>=
is.rspec(specs)
@

If you already have multiple spectra in a single data frame that you'd like to use with \pavo{} 
functions, you can use the command \code{as.rspec} to convert it to an rspec object. The 
function will attempt to identify the wavelength variable or, if it doesn't have one, it can be 
specified in the function call.

\subsection{Processing Data}

\subsubsection{Averaging Spectra}

As previously described, our data constitutes of multiple individuals, and each was measured 
three times, as is common in order to avoid measurement bias. A good way to visualize the 
repeatability of our measurements is to plot the spectra of each individual separately. The 
function \code{explorespec} provides an easy way of doing so. You may specify the number of 
spectra to be plotted in the same panel using the argument \code{specreps}, and the function 
will adjust the number of panels per page accordingly. We will exemplify this function using 
only the 12 cardinal individuals measured:

<<label=explorespecfig, fig=TRUE, include=FALSE, width=5.5, height=6.5>>=
explorespec(specs[,1:37], specreps=3) 
# 36 spectra plus the first (wl) column
@

\begin{figure}[H] % h=here, t=top, b=bottom, p=floating page
\begin{center}
\includegraphics[width=5in]{pavo-explorespecfig}
\end{center}
\caption{Result from \code{explorespec}, showing the three measurements for each individual in separate panels}
\label{figure:explorespec}
\end{figure}

\clearpage{}

So our first step would be to take the average of each of these three measurements in order to 
obtain average individual spectra to be used in further analyses. The function \code{aggspec} 
does this. The \code{by} argument can be either a number (specifying how many specs should be 
averaged for each new sample) or a vector specifying the identities of the spectra to be 
combined (see below):

<<>>=
mspecs <- aggspec(specs, by=3, FXN=mean)
mspecs[1:5, 1:4]
dim(mspecs) #data now has 72 spectra, one for each individual
@

Now we'll use the \code{aggspec} function again, but this time to take the average spectrum for 
each species. However, each species has a different number of samples, so we can't use the 
\code{by} argument as before. Instead we will use regular expressions to create a species name 
vector by removing the numbers that identify individual spectra:

<<>>=
# create a vector with species identity names
spp <- gsub('\\.[0-9].*$','',names(mspecs))[-1]
table(spp)
@

Instead, we are going to use the \code{spp} vector we created to tell the \code{aggspec} 
function how to average the spectra in \code{mspec}:

<<label=exploresppmeans, fig=TRUE, include=FALSE>>=
sppspec <- aggspec(mspecs, by=spp, FXN=mean)
round(sppspec[1:5, ],2)
explorespec(sppspec, 6)
@

\begin{figure}[H]
\begin{center}
\includegraphics{pavo-exploresppmeans}
\end{center}
\caption{Result from \code{explorespec} for species means}
\label{figure:sppmeans}
\end{figure}


 \subsubsection{Normalizing and Smoothing Spectra}

Data obtained from spectrometers often requires further processing before analysis and/or 
publication. For example, electrical noise can produce unwanted "spikes" in reflectance curves. The 
\pavo{} function \code{procspec} can handle a variety of processing techniques. For example, the 
reflectance curve from the parakeet is noisy in the short (300-400 nm) and long (650-700 
nm) wavelength ranges (Figure \ref{figure:specsmooth}, black line). To eliminate this noise, we can 
use the \code{opt} argument in \code{procspec} to smooth data using local regression, as implemented 
by the \code{loess.smooth} function in \code{R} (Figure \ref{figure:specsmooth}, red line).

<<label=specsmooth,fig=TRUE,include=FALSE,results=hide>>=
spec.sm <- procspec(sppspec, opt='smooth')
plot(sppspec[, 5]~sppspec[, 1], type='l', lwd=10, col='grey', 
     xlab="Wavelength (nm)", ylab="Reflectance (%)")
lines(spec.sm[, 5]~sppspec[, 1], col='red', lwd=2)
@

\begin{figure}[H]
\begin{center}
\includegraphics[width=3in]{pavo-specsmooth}
\end{center}
\caption{Result for raw (grey line) and smoothed (red line) reflectance data for the parakeet.}
\label{figure:specsmooth}
\end{figure}

We can also try some other normalizations. Note that the user can specify multiple processing 
options that will be applied sequentially to the spectral data by \code{procspec}.

<<results=hide>>=
# Run some different normalizations
specs.max <- procspec(sppspec, opt='max')
specs.min <- procspec(sppspec, opt='min')
specs.str <- procspec(sppspec, opt=c('min', 'max'))  # multiple options
@

<<label=specnorm,fig=TRUE,include=FALSE,width=7,height=2.7>>=
# plot results
par(mfrow=c(1,3), mar=c(2,2,2,2), oma=c(3,3,0,0))
plot(specs.max[, 5]~c(300:700), ylim=c(0,1), xlab="", ylab="", type='l')
abline(h=1, lty=2)
plot(specs.min[,5]~c(300:700), xlab="", ylab="", type='l')
abline(h=0, lty=2)
plot(specs.str[,5]~c(300:700), type='l', xlab="", ylab="")
abline(h=c(0,1), lty=2)
mtext("Wavelength (nm)", side=1, outer=T, line=1)
mtext("Reflectance (%)", side=2, outer=T, line=1)
@

\begin{figure}[H]
\begin{center}
\includegraphics[width=6in]{pavo-specnorm}
\end{center}
\caption{Results for max (left), min (center), and max and min normalizations (right).}
\label{figure:specnorm}
\end{figure}

\subsubsection{Binning and PCA Analysis of Spectral Shape}

Another intended usage of \code{procspec} is preparation of spectral data for variable reduction
(using, for example. Principal Component Analysis, or PCA). Following Cuthill, 1999 we can use 
\code{opt = 'center'} to center spectra to have a mean reflectance of zero (thus removing brightness 
as a dominant variable in the PCA) and then bin the spectra into user-defined bins (using the 
\code{opt= 'bins'} argument) to obtain a dataframe suitable for the PCA.

<<results=hide>>=
# pca analysis
specs.bin <- procspec(sppspec, opt=c('bin', 'center'))
specs.bin <- t(specs.bin)  # transpose so wavelength are variables for the PCA
colnames(specs.bin) <- specs.bin[1,]  # names variables as wavelength bins
specs.bin <- specs.bin[-1, ]  # remove 'wl' column
# specs.bin[1:6, 1:3]
pca1 <- prcomp(specs.bin, scale=T)
@

The flexibility of \code{pavo}'s plotting capabilities allows you to sort spectra by another
variable (e.g., PC1 loading) and then plot in a stacked format using the \code{plot.rspec} function.

<<label=pcaplot,fig=TRUE,include=FALSE,width=8,height=4>>=
# generate colors from spectra
colr <- spec2rgb(sppspec)
wls <- as.numeric(colnames(specs.bin))
# rank specs by PC1
sel <- rank(pca1$x[,1])
sel <- match(names(sort(sel)), names(sppspec))
# plot results
par(mfrow=c(1,2), mar=c(2,4,2,2), oma=c(2,0,0,0))
plot(pca1$r[,1]~wls, type='l', ylab="PC1 loading")
abline(h=0, lty=2)
plot(sppspec, select=sel, type='s', col=spec2rgb(sppspec))
mtext("Wavelength (nm)", side=1, outer=T, line=1)
@

\begin{figure}[H]
\begin{center}
\includegraphics[width=5in]{pavo-pcaplot}
\end{center}
\caption{Plot of PC1 loading versus wavelength (left) and species mean spectra sorted vertically 
from lowest to highest PC1 value (right).}
\label{figure:pcaplot}
\end{figure}

\subsubsection{Dealing with negative values in spectra}

Negative values in spectra are unwanted, as they can affect estimates of color variables. Nonetheless, 
certain spectrometer manufacturers allow negative values to be saved. To handle negative values, the
\code{procspec} function has the \code{fixneg} option for the \code{opt} argument. The two options 
available are (1) adding the absolute value of the most negative value to the whole spectrum (\code{fi
xneg = addmin}) and (2) changing all negative values to zero (\code{fixneg = zero}). 

<<results=hide>>=
# Create a duplicate spectrum and add some negative values
refl <- sppspec[, 7] - 20
testspecs <- as.rspec(cbind(c(300:700), refl))
# Apply three different processing options
testspecs.fix1 <- procspec(testspecs, fixneg='addmin')
testspecs.fix2 <- procspec(testspecs, fixneg='zero')
@

<<label=fixneg, fig=T, include=F, width=6, height=4>>=
par(mar=c(2,2,2,2), oma=c(3,3,0,0))
layout(cbind(c(1,1),c(2,3)), widths=c(2,1,1))
plot(testspecs, select = 2, ylim=c(-10,30))
abline(h=0, lty=3)
plot(testspecs.fix1, select = 2, ylim=c(-10,30))
abline(h=0, lty=3)
plot(testspecs.fix2, select = 2, ylim=c(-10,30))
abline(h=0, lty=3)
mtext("Wavelength (nm)", side=1, outer=T, line=1)
mtext("Reflectance (%)", side=2, outer=T, line=1)
@

\begin{figure}[H]
\begin{center}
\includegraphics[width=5in]{pavo-fixneg}
\end{center}
\caption{Plots showing original reflectance curve including negative values (left) and two processed curves using \code{fixneg=addmin} (top) and \code{fixneg=zero} bottom.}
\label{figure:neg}
\end{figure}

These may have different effects on the final spectra, as can be seen in Figure \ref{figure:neg}, 
which the user should keep in mind and use according to the final goal of the analysis. For example, 
by adding the minimum reflectance to all other wavelngth, the shape of the curve is preserved, but the 
maximum reflectance is much higher (Figure \ref{figure:neg}, top). On the other hand, substituting 
negative values with zero preserves absolute reflectance values, but may cause the spectral shape to 
be lost (Figure \ref{figure:neg}, bottom). The ``best'' transformation will depend on the severity of 
the problem of negative values and the goal of the analysis (e.g. will reflectance intensity be used? 
What is more important, to preserve reflectance values or the total shape of the curve?)

\section{Visualizing Spectral Data}

Since \pavo{} uses the class \code{rspec} to identify spectral data, the function \code{plot.rspec} 
can be called simply by calling \code{plot(data)}. If the object is not of class \code{rspec} the 
multivariate visualization methods will not work as expected, so it might be useful to check the data 
using \code{is.rspec} and convert with \code{as.rspec} if necessary.

We have implemented three methods of visualizing spectral data using \code{plot}:

\begin{itemize}
	\item{\code{Overlay} - all spectra plotted with same x- and y-axis}
	\item{\code{Stack} - spectra plotted with same x-axis but arranged vertically along y-axis}
	\item{\code{Heatmap} - false color map to show three dimensional data}
\end{itemize}

Which are in addition to the exploratory plotting offered by \code{explorespec}, as seen in Figues 
\ref{figure:explorespec} and \ref{figure:sppmeans}. To showcase the capabilities of \code{plot.rspec}, 
we will first load some reflectance data. 

% <<>>=
% data(teal)  # TODO add this
% dim(teal)
% @

This dataset consists of reflectance spectra from the iridescent wing patch of a green-winged teal 
(\emph{Anas carolinensis}). Reflectance measurements were taken between 300 and 700 nm
at different incident angles, ranging from 15\ensuremath{^\circ} to 70\ensuremath{^\circ} 
(in 5\ensuremath{^\circ} increments). 

We can start out by visualizing these spectra with \code{overlay} option in plot.rspec. Another neat 
option \pavo{} offers is to convert reflectance spectra to their approximate perceived color, by using 
the function \code{spec2rgb}. This can make for some very interesting plots and even exploratory data 
analysis, as shown in Figure \ref{figure:overlay}.


<<label=overlay,fig=T,include=F>>=
par(mar=c(4,4,2,2))
teal <- readRDS('~/github/pavo/toydata/teal.rda')
teal <- teal[,-14]
#teal <- loadRDS(...)[,-14]
plot(teal, type='o', col=spec2rgb(teal))
@

\begin{figure}[H]
\begin{center}
\includegraphics[width=4in]{pavo-overlay}
\end{center}
\caption{Overlay plot of the teal angle-dependent reflectance}
\label{figure:overlay}
\end{figure}

Another option is the \code{stack} plot (again, with human vision approximations of the color produced by the spectra using \code{spec2rgb}).

<<label=stack,fig=T,include=F>>=
teal.norm <- procspec(teal, opt=c('min', 'max'))
par(mfrow=c(1,2), mar=c(2,2,2,2), oma=c(2,2,0,0))
plot(teal, type='s', col=spec2rgb(teal))
plot(teal.norm, type='s', col=spec2rgb(teal))
mtext("Wavelength (nm)", side=1, outer=T, line=1)
mtext("Cumulative reflectance (A.U.)", side=2, outer=T, line=1)
@

\begin{figure}[H]
\begin{center}
\includegraphics[width=4in]{pavo-stack}
\end{center}
\caption{Stack plot of the raw (left) and normalized (right) teal angle-dependent reflectance}
\label{figure:stack}
\end{figure}

Since this dataset is three-dimensional (containing wavelengths, reflectance values and incident
angles) we can also use the \code{heatmap} function. First, it will be necessary to define a vector
for the incident angles each spectrum was measured at:

<<>>=
angles <- seq(15,70,by=5)
@

 Next, we will smooth the data with \code{procspec} and plot as a false color map (heatmap):
 
<<label=heatmap,fig=T,include=F>>=
teal.sm <- procspec(teal, opt=c('smooth'))
plot(teal.sm, type='h', varying=angles, 
     ylab="Incident angle (º)", las=1, useRaster=TRUE)
@

\begin{figure}[H]
\begin{center}
\includegraphics[width=4in]{pavo-heatmap}
\end{center}
\caption{Heatmap plot for angle-resolved reflectance measurements of the green-winged teal.}
\label{figure:heatmap}
\end{figure}

These plots can be very useful to observe changes over time, for example, or any other type of 
continuous variation.

\section{Analyzing Spectral Data}

\subsection{Overview}

\pavo{} offers two main approaches for spectral data analysis. First, variables can be  calculated
based on the shape of the reflectance spectra. By using special R classes for spectra  data frame
objects, this can easily be done using the \code{summary} function in an rspec  object (see below).
The second function for spectral shape analysis is \code{peakshape}, which returns descriptors for
peaks in spectral curves, as outlined below.

Second, reflectance spectra can be analyzed accounting for the visual system receiving the color
signal, therefore representing reflectance spectra as preceived colors. We have implemented
Endler's (REF) segment analysis model, which approximates visual models but does not directly  use
sensory information; the model of Osorio \& Vorobyev (REF), which provides a flexible  framework for
visual modeling; and the tetrahedral color space (GOLDSMITH, ENDLER, STODDARD)  which has been
extensively developed to represent colors in the avian vision color space.

\subsection{Spectral Shape Analysis}

\subsubsection{Trichromatic variables}

Obtaining trichromatic color variables (related to hue, saturation and value) is pretty
straightforward in \pavo{}. Since reflectance spectra is stored in an object of class  \code{rspec},
the \code{summary} function recognizes the object as such and extracts 23  variables, as outlined in
MONTGOMERIE. Though outlined in a book chapter on bird coloration,  these variables are broadly
applicable to any reflectance data, particularly if the taxon of  interest has color vision within
the UV-human visible range.

The description and formulas for these variables can be found in Table \ref{table:tristim}.

<<results=hide>>=
summary(spec.sm)
@


<<echo=FALSE>>=
round(summary(spec.sm),2)
@


% A table for filling in Montgomerie's color variables
\begin{table}
\begin{center}
\setlength{\extrarowheight}{6pt}
\begin{tabular}{l l} \hline
{\bf Color variable} & {\bf Description} \\ 
\hline
{$B_1 = \sum_{\lambda_{min}}^{\lambda_{max}} R_\lambda$} & \parbox[t]{3in}{Total reflectance: sum of reflectance values over all wavelengths.}  \\
{$B_2 = B_{1}/n_{wl}$} & \parbox[t]{3in}{Mean brightness: average reflectance over all wavelengths.} \\
{$B_3 = R_\text{max}$} & \parbox[t]{3in}{Intensity: Peak reflectance of the spectrum.} \\
{$S_1 = \sum_{\lambda_a}^{\lambda_b} R_\lambda/B_{1}$} & \parbox[t]{3in}{Chroma: segment-specific chroma calculated by dividing the sum of reflectance values over region of interest (e.g., from $\lambda_a$ to $\lambda_b$) by the total reflectance.} \\
{$S_2 = R_\text{max}/R_\text{min}$} & \parbox[t]{3in}{Spectral saturation: ratio of maximum and minimum reflectance values.} \\
{$S_3 = \sum_{\lambda_{R\text{max}}-50}^{\lambda_{R\text{max}}+50} R_i/B_{1}$} & \parbox[t]{3in}{Chroma: sum of reflectance values +/- 50 nm from the wavelength of peak reflectance (hue, $\lambda_\text{max}$)} \\
{$S_4 = |b\text{max}_\text{neg}|$} & \parbox[t]{3in}{Spectral purity: maximum negative slope of spectrum over range of wavelengths.} \\
{$S_5 = \sqrt{(B_r-B_g)^2+(B_y-B_b)^2}$} & \parbox[t]{3in}{Chroma: Euclidean distance from achromatic origin using segment classification method (see section XX).} \\
{$S_6 = R_\text{max}-R_\text{min}$} & \parbox[t]{3in}{Contrast/amplitude: difference in reflectance between high and low points in the spectrum.} \\
{$S_7 = (\sum_{\lambda_{min}}^{\lambda_R{mid}}R_i - \sum_{\lambda_R{mid}}^{\lambda_{max}}R_i)/B_{1}$} & \parbox[t]{3in}{Spectral saturation: reflectance difference between the minimum wavelength and the half-max reflectance and the maximum wavelength and the half-max reflectance. Analogous to the segment classification method (see section XX)} \\
{$S_8 = (R_\text{max}-R_\text{min})/B_2$} & \parbox[t]{3in}{Chroma: relative difference between max and min reflectance taking into account the average brightness ($B2$) of the spectrum.} \\
{$S_9 = (R_{\lambda{450}}-R_{\lambda{700}})/R_{\lambda{700}}$} & \parbox[t]{3in}{Carotenoid chroma: relative reflectance in the region of greatest reflectance in carotenoid-based colors} \\
{$S_{10} = [(R_{max}-R_{min})/B_2]\times|b\text{max}_\text{neg}|$} & \parbox[t]{3in}{Peaky chroma: relative contrast (S8) multiplied by the spectral purity (S4). Relatively flat curves will give low vales for this metric, and vice versa.} \\
{$H_1 = \lambda_{R\text{max}}$} & \parbox[t]{3in}{Hue: wavelength of peak reflectance.} \\
{$H_2 = \lambda_{b\text{max}_\text{neg}}$} & \parbox[t]{3in}{Hue: wavelength at location of maximum negative slope in the spectrum.} \\
{$H_3 = \lambda_{R\text{mid}}$} & \parbox[t]{3in}{Hue: wavelength at the midpoint ([$R_\text{max} + R_\text{min}]/2$) in the reflectance spectrum.} \\
{$H_4 = atan\{[(B_y-B_b)/B_1]/[(B_r-B_g)/B_1]\}$} & \parbox[t]{3in}{Hue: the angle from 0º (red) calculated by the segment classification method (see section XX).} \\
{$H_5 = \lambda_{b\text{max}_\text{pos}}$} & \parbox[t]{3in}{Hue: wavelength at point in spectrum where curve reaches a maximum postitive slope.} \\
\hline
\end{tabular}
\end{center}
\caption{\label{table:tristim}
The complete set of tristimulus variables calculated by \code{summary} in \pavo{}}
\end{table}

\clearpage{}

\subsubsection{Peak shape descriptors}

Particularly in cases of reflectance spectra that have a single, discrete peak, it might be useful
to obtain variables that describe that peak's properties. The \code{peakshape} function identifies
the peak location (\code{H1}),  returns the reflectance at that point (\code{B3}), and identifies
the wavelengths at which the reflectance is half that at the peak, calculating the wavelength
bandwith of that interval (the \textbf{Full Width at Half Maximum}, or \code{FWHM}). The function
also returns the half widths, which are useful when the peaks are located near the edge of the
measurement limit and half maximum reflectance can only be reliably estimated from one of its sides.

If this all sounds too esoteric, fear not: \code{peakshape} has the option of returning plots
indicating what it's calculating. The vertical continuous red line indicates the peak location, the
horizontal continuous red line indicates the half-maximum reflectance, and the distance between the
dashed lines is the FWHM:

<<label=fwhm, fig=TRUE, include=FALSE, width=6, height=4>>=
par(mfrow=c(2,3),mar = c(5, 4, 0.5, 0.5) + 0.1)
peakshape(spec.sm, plot=T)
@

\begin{figure}[H] % h=here, t=top, b=bottom, p=floating page
\begin{center}
\includegraphics[width=5in]{pavo-fwhm}
\end{center}
\caption{Plots from \code{peakshape}}
\label{figure:fwhm}
\end{figure}

As it can be seen, the variable is meaningless if the curve doesn't have a clear peak. Sometimes ,
such as in the case of the Cardinal (Figure \ref{figure:fwhm}, first panel), there might be a  peak
which is not the point of maximum reflectance of the entire spectral curve. The half-width  can also
be erroneously calculated when there are two peaks, as can be seen in the case of the  Tanager
(Figure \ref{figure:fwhm}, last panel). In this case, it's useful to set bounds when  calculating
the FWHM, using the \code{bounds} argument. \code{peakshape} also offers a  \code{select} argument
to facilitate subsetting the spectra data frame:

<<label=fwhm2, fig=TRUE, include=FALSE>>=
peakshape(spec.sm, select=2, bounds=c(300,500), plot=T)
@


\begin{figure}[H] % h=here, t=top, b=bottom, p=floating page
\begin{center}
\includegraphics[width=3in]{pavo-fwhm2}
\end{center}
\caption{Plot from \code{peakshape}, setting the bounds to 300-500nm}
\label{figure:fwhm2}
\end{figure}

\subsection{Visual System Models}

\subsubsection{Segment Classification Analysis}

The segment classification analysis (Endler 1990) does not assume any particular visual system, but 
instead tries to classify colors in a manner that captures common properties of many vertebrate (and 
some invertebrate) visual systems. In essence, it breaks down the reflectance spectrum region of 
interest into four equally-spaced regions, measuring the relative strength along those. This 
approximates a trichromatic opponency system with short, medium, and long-wavelength sensitive 
photoreceptors. 

Though somewhat simplistic, this model captures many of the properties of other, more complex ones, 
but without many of the additional assumptions these make. It also provides results in a fairly 
intuitive color space, in which the angle corresponds to hue and the distance from the center 
corresponds to choma (Figure \ref{figure:segplot}; in fact, variables \code{S5} and \code{H4} from 
\code{summary.rspec} are calculated from these relative segments, see Table \ref{table:tristim}). Note 
that, while a segment analysis ranging from 300 or 400nm to 700nm corresponds quite closely to the 
human visual system color wheel, any wavelength range can be analyzed in this way, returning a 
360\ensuremath{^\circ} hue space delimited by the range used (\code{segclass} accepts the argument 
\code{range} for user-specified limits that don't match the data range).

The segment differences or ``opponents'' are calculated as:

\begin{subequations}\label{eqsegment}
\begin{align}
LM = \frac{ R_\lambda \sum_{\lambda={Q4}} R_\lambda - \sum_{\lambda={Q2}} R_\lambda }{\sum_{\lambda={min}}^{max}R_\lambda} \\
MS = \frac{ R_\lambda \sum_{\lambda={Q3}} R_\lambda - \sum_{\lambda={Q1}} R_\lambda }{\sum_{\lambda={min}}^{max}R_\lambda}
\end{align}
\end{subequations}

Where $Qi$ represent the interquantile distances (e.g. for the human visible range, $Q_1=blue$, $Q_2=green$, $Q_3=yellow$ and $Q_4=red$)

In \pavo{}, the segment classification model is obtained through the function \code{segclass}:

<<>>=
segclass(spec.sm)
@

where \code{LM} and \code{MS} are the segment differences or ``opponents'' (Eqn \ref{eqsegment}). 

The example below uses idealized reflectance spectra to illustrate how the avian color space defined 
from the segment classification maps to the human color wheel:

<<label=segplot, results=hide, fig=TRUE, include=FALSE, width=6, height=4>>=
# creating idealized specs with varying hue
fakedata1 <-  sapply(seq(100,500,by=20), 
                     function(x) rowSums(cbind(dnorm(300:700,x,30), 
                                               dnorm(300:700,x+400,30))))

# creating idealized specs with varying saturation
fakedata2 <- sapply(c(500, 300, 150, 105, 75, 55, 40, 30), 
                     function(x) dnorm(300:700,550,x))

# combining and converting to rspec
fakedata.c <- data.frame(wl=300:700, fakedata1, fakedata2)
fakedata.c <- as.rspec(fakedata.c)
fakedata.c <- procspec(fakedata.c, "max")

fakedata1 <- as.rspec(data.frame(wl=300:700,fakedata1))
fakedata1 <- procspec(fakedata1, "max")
fakedata2 <- as.rspec(data.frame(wl=300:700,fakedata2))
fakedata2 <- procspec(fakedata2, "max")

# segment classification analysis
seg.fdc <- segclass(fakedata.c)

# plot results
layout(cbind(1,2,3), widths=c(1,1,3))
par(mar=c(5,4,2,0.5))
plot(fakedata1, type='stack', col=spec2rgb(fakedata1)) 
par(mar=c(5,2.5,2,1.5))
plot(fakedata2, type='stack', col=spec2rgb(fakedata2)) 
par(mar=c(5,4,2,0.5))
plot(seg.fdc, pch=20, cex=3, col=spec2rgb(fakedata.c))
@

\begin{figure}[H] % h=here, t=top, b=bottom, p=floating page
\begin{center}
\includegraphics[width=5in]{pavo-segplot}
\end{center}
\caption{Idealized reflectance spectra and their projection on the axes of segment classification}
\label{figure:segplot}
\end{figure}

\subsubsection{Photon Catch Model}

\subsubsection{Tetrahedral Color Space Model}

\end{document}