setwd("~/Documents/pavo")
getwd("")
getwd()
setwd("/R")
setwd("~/Documents/pavo/R")
tetraplot<- function(tcsres, size=0.02, col='black', new=T, hspin=T, vspin=F, floor=T) {if(new)   open3d(FOV=1, mouseMode=c('zAxis','yAxis','zoom'))# can't figure out how to change the character typettv=pavo::ttvertexcu=t(col2rgb('#984EA3'))/255cs=t(col2rgb('#377EB8'))/255cm=t(col2rgb('#4DAF4A'))/255cl=t(col2rgb('#E41A1C'))/255plot3d(unlist(ttv[c('xu','xs','xm','xl')]),		unlist(ttv[c('yu','ys','ym','yl')]),		unlist(ttv[c('zu','zs','zm','zl')]), type='s', lit=F,		radius=0.02, box=F, axes=F, xlab='',ylab='',zlab='',		col=c(rgb(cu[1],cu[2],cu[3]), rgb(cs[1],cs[2],cs[3]), 		rgb(cm[1],cm[2],cm[3]), rgb(cl[1],cl[2],cl[3])))#
segments3d(ttv[c('xu','xs')], ttv[c('yu','ys')], ttv[c('zu','zs')], color='lightgrey')segments3d(ttv[c('xu','xm')], ttv[c('yu','ym')], ttv[c('zu','zm')], color='lightgrey')segments3d(ttv[c('xu','xl')], ttv[c('yu','yl')], ttv[c('zu','zl')], color='lightgrey')segments3d(ttv[c('xs','xm')], ttv[c('ys','ym')], ttv[c('zs','zm')], color='lightgrey')segments3d(ttv[c('xs','xl')], ttv[c('ys','yl')], ttv[c('zs','zl')], color='lightgrey')segments3d(ttv[c('xl','xm')], ttv[c('yl','ym')], ttv[c('zl','zm')], color='lightgrey')spheres3d(0,0,0,col='grey', radius=0.01, lit=F)spheres3d(tcsres$tcs[,c('x','y','z')], radius=size, color=col, lit=F)if(floor){  vertices <- c(       -0.7, -0.5, -0.3, 1.0,       0.7, -0.5, -0.3, 1.0,       0.7,  1, -0.3, 1.0,      -0.7,  1, -0.3, 1.0  				)  indices <- c( 1, 2, 3, 4 )#
 wire3d( qmesh3d(vertices,indices), lit=F )	}#
if(hspin)   play3d(spin3d(axis=c(0,0,1), rpm=20), duration=3)if(vspin)   play3d(spin3d(axis=c(1,0,0), rpm=20), duration=3)}#
require(pavo)require(rgl) a=getspec('~/github/pavo/examplespec') b=getspec('~/github/pavo/examplespec','ttt') a=data.frame(cbind(a,b)) rm(b) vis.a=vismodel(a) tcs.a=tcs(vis.a)#
ttvol <- function(tcsres){vol <- t(convhulln(tcsres$tcs[,c('x','y','z')],options='FA')$hull)coords <- tcsres$tcs[,c('x','y','z')]ind <- t(combn(unique(c(vol)),2))for(i in 1:nrow(ind)){segments3d(coords[ind[i,],'x'],coords[ind[i,],'y'],coords[ind[i,],'z'])	}rgl.triangles(coords[vol,1],coords[vol,2],coords[vol,3], alpha=0.1)#rgl.triangles(coords[vol,1],coords[vol,2],coords[vol,3], color='lightgrey')}tetraplot(tcs.a, new=T,hspin=F, size=0.01)ttvol(tcs.a)#
#saving options seem very limitedrgl.postscript('testplot.pdf',fmt='pdf')rgl.snapshot('testplot.png')
' Import spectra files#' #' Finds and imports spectra files from a folder. Currently tested and working#' for reflectance files generated in Ocean Optics SpectraSuite (USB2000,#' USB4000 and Jaz spectrometers), CRAIC software (after exporting) and #' Avantes (after exporting).#' #" @param where (required) folder in which files are located.#' @param ext file extension to be searched for, without the "." #' (defaults to "txt").#' @param lim a vector with two numbers determining the wavelength limits to be#' considered (defaults to 300 and 700).#' @param decimal character to be used to identify decimal plates #' (defaults to ".")#' @param negative how to handle negative reflectance. \code{zero}, transforms #' negative values by rounding them up to 0; \code{min} transforms by adding the lowest #' negative reflectance value for that spectrum to the reflectance at remaining #' wavelengths; \code{raw} does not transform and leaves negative values as is#' (not recommended). \code{zero} is recommended when negative values are a product #' ofnoise, whereas \code{min} is recommended when negative values are a product#' of bad reference calibration. (defaults to \code{zero})#' @param subdir Should subdirectories within the \code{where} folder be#' included in the search? (defaults to \code{FALSE})#' @param subdir.names Should subdirectory path be included in the name of the#' spectra? (defaults to \code{FALSE})#' @return a data frame containing individual imported spectral files as columns.#' Reflectance values are interpolated to the nearest wavelength integer.#' @export#' @examples \dontrun{#' getspec('/examplespec', lim=c(400,900))	#' getspec('/examplespec', ext='ttt')}#' @author Rafael Maia \email{rm72@@zips.uakron.edu}#' @references Montgomerie R (2006) Analyzing colors. In: Hill G, McGraw K (eds) #' Bird coloration. Harvard University Press, Cambridge, pp 90-147.#
#clumsy: if subdir=T, column name includes subdir name (desired?)# CME: can we have this automatically set the lower and upper limits based on the spec #      files? These files are usually a pain to view in a text editor to see what wl #      range was used.# RM: hm.. not sure I like this idea very much. two problems: (1) if specs have different #     ranges they can't be added to the same matrix without adding NAs; (2) If saved spec#     includes a range that the spec can't actually read, it will be very noisy and may #     mess corrections (depending on how these are handled).#   suggested solution: a secondary function that examines files and returns recorded WL #     range (in a dataframe or table)getspec <- function(where, ext='txt', lim=c(300,700), decimal=".",            negative=c('zero','min', 'raw'), subdir=FALSE, subdir.names=FALSE){negative <- match.arg(negative)makenegzero<-function(x) {x[x[,2]<0,2] = 0; x}separ=ifelse(ext=='ttt',';','\t')extension <- paste('.', ext, sep='')file_names <- list.files(where, pattern=extension, recursive=subdir, include.dirs=subdir)files <- paste(where,'/',file_names,sep='')if(subdir.names){	file_names <- gsub(extension,'',file_names)}else{	file_names <- gsub(extension,'',basename(file_names))	 }if(length(file_names)==0){	stop('No files found. Try a different ext')	} range <- lim[1]:lim[2]final <- data.frame(matrix(nrow=length(range), ncol=length(file_names)+1))final[,1] <- range#
for(i in 1:length(files)){raw <- scan(file=files[i], what='', quiet=T, dec=decimal, sep='\n')#ToDo we can actually use this raw string to import metadata if we wantstart <- grep(separ,raw)[1] - 1end <- length(grep(separ,raw))#Avantes ttt files don't use tab-delimiting, but semicolon-delimiting#also has two lines with semicolon that are not dataif(extension=='.ttt'){	start <- grep(separ,raw)[3] -1	end <- length(grep(separ,raw)) + start -1}#jaz output file is weird. has 5 columns and an extra line in bottomif(extension=='.jaz'){	tempframe <- read.table(files[i], dec=decimal, sep=separ, skip=start, nrows=end-1, 							header=T)	tempframe <- tempframe[c('W','P')]	}else{tempframe <- read.table(files[i], dec=decimal, sep=separ, skip=start, nrows=(end-start-1))			}interp<-data.frame(approx(tempframe[,1], tempframe[,2], xout=range))names(interp) <- c("wavelength", strsplit(file_names[i], extension) )#SpectraSuite sometimes allows negative values. Remove those:# CME: I don't know if this is the right way to go about this. If some specs have neg #      values while others don't their relative brightnesses will be meaningless. #      Maybe replace with NAs or zeros?# RM: Done: include with for option as to how to change this (zero, min or raw)if(min(interp[,2], na.rm=T) < 0) {	interp[,2] <- switch(negative,	raw = interp[,2],	zero = makenegzero(interp)[,2],	min = interp[,2] + abs(min(interp[,2], na.rm=T)),	)}final[,i+1] <- interp[,2]}names(final) <- c('wl',gsub(extension,'',file_names))class(final) <- c('spec','data.frame')#
final}
' Visual Models#' #' Applies the visual models of Vorobyev et al. (1998) to calculate quantum #' catches at each photoreceptor. Relative values may also be obtained, in which#' case the model reduces to the color space as described in Endler & Mielke (2005)#' and Stoddard & Prum (2008).#' #' @param specdata (required) Data frame containing reflectance spectra at each column.#' must contain a \code{wl} column identifying the wavelengths for the reflectance values.#' @param visual The visual system to be used. Currently implemented system are: #' \code{avg.uv}: average avian UV system; \code{avg.v}: average avian V system; #' \code{bt}: Blue tit \emph{Cyanistes caeruleus} (REF); \code{star}: Starling#' \emph{Sturnus vulgaris} (REF); and \code{pfowl}: the peafowl #' \emph{Pavo cristatus} (REF).#' @param relative Should relative quantum catches be returned (i.e. is it a color#' space model? Defaults to \code{TRUE})#' @param ilum A vector containing the iluminant. Must be the same length as the columns#' in \code{specdata}. (Default assumes an idealized iluminant of 1)#' @param bkg A vector containing the background. Must be the same length as the columns#' in \code{specdata}. (Default assumes an idealized background of 1)#' @return A list containing the following data frames:#' @return \code{descriptive}: descriptive statistics of maximum and normalized #' reflectance, and wavelength of maximum reflectance (hue)#' @return \code{Qi}: Quantum catch for each photoreceptor (which sum to 1 if #' \code{relative = TRUE})#' @return \code{qi}: Quantum catch normalized to the adaptingbackground according #' to the von Kries transformation.#' @return \code{fi}: Quantum catch according to Fechner law (the signal of the receptor#' channel is proportional to the logarithm of the quantum catch)#' @export#' @examples \dontrun{#' #INCLUDE EXAMPLE}#' @author Rafael Maia \email{rm72@@zips.uakron.edu}#' @references Vorobyev, M., Osorio, D., Bennett, A., Marshall, N., & Cuthill, I. (1998). Tetrachromacy, oil droplets and bird plumage colours. Journal Of Comparative Physiology A-Neuroethology Sensory Neural And Behavioral Physiology, 183(5), 621-633.#' @references Hart, N. S. (2001). The visual ecology of avian photoreceptors. Progress In Retinal And Eye Research, 20(5), 675-703.#' @references Stoddard, M. C., & Prum, R. O. (2008). Evolution of avian plumage color in a tetrahedral color space: A phylogenetic analysis of new world buntings. The American Naturalist, 171(6), 755-776.#' @references Endler, J. A., & Mielke, P. (2005). Comparing entire colour patterns as birds see them. Biological Journal Of The Linnean Society, 86(4), 405–431.vismodel<-function(specdata, visual=c("avg.uv", "avg.v", "bt", "star", "pfowl"), relative=TRUE, ilum=ideal, bkg=ideal){# remove & save colum with wavelengthswl_index <- which(names(specdata)=='wl')wl <- specdata[,wl_index]y <- specdata[,-wl_index]sens<- pavo::vissyst# check if wavelength range matches  if(!identical(wl,sens$wl))    stop('wavelength in spectra table and visual system chosen do not match')# get visual system to usevisual <- match.arg(visual)S <- sens[,grep(visual,names(sens))]names(S) <- gsub(paste(visual,'.',sep=''),'',names(S))#DEFINING ILUMINANT & BACKGROUNDideal <- rep(1,dim(specdata)[1])# brightnessnorm.B <- colSums(y)/(dim(y)[1]*100)max.B <- apply(y,2,max)# wavelength of maximum reflectancelambdamax <- wl[max.col(t(y))]descriptive <- data.frame(lambdamax,norm.B,max.B)# scale to maximum reflectance = 1yscale <- apply(y,2,function(x) x/max(x))#SEM NORMALIZAR#x<-y/100 #só transformando em proporção, ao invés de porcentabem (assim 100% reflectance = 1.0 )#Qi# at the moment this will only work for avian type visual systems. # could not figure out yet a way of automating without using loopso if more or# les than the 4 columns of the avian system.Qi <- matrix(NA,nrow=dim(y)[2], ncol=4)Qi[,1] <- colSums(y*S[,1]*ilum)Qi[,2] <- colSums(y*S[,2]*ilum)Qi[,3] <- colSums(y*S[,3]*ilum)Qi[,4] <- colSums(y*S[,4]*ilum)Qi <- as.data.frame(Qi, row.names=names(y))names(Qi) <- names(S)if(relative){  Qi <- Qi/rowSums(Qi)# Place dark specs in achromatic center?# blacks <- which(norm.B < 0.05) #find dark specs# Qi[blacks,] <- 0.2500 #place dark specs in achromatic center}#qi # von Kries correction (constant adapting background)k <- 1/colSums(S*bkg*ilum)# quantum catch normalized to the background (qi = k*Qi)qi <- t(t(Qi)*k)# fechner law (signal ~ log quantum catch)fi <- log(qi)#
#OUTPUTres<-list(descriptive=descriptive,Qi=Qi, qi=qi, fi=fi)class(res) <- 'vismodel'res}
' Tetracolorspace avian visual model#'#' calculates coordinates and colorimetric variables that represent reflectance spectra#' in the avian tetrahedral color space.#'#' @param vismodeldata (required) Quantum catch color data. Can be either the result#' from \code{vismodel} or independently calculated data (in the form of a data frame#' with four columns, representing the avian cones).#' @param by Either a single value specifying the range of color points for which#' summary colorspace variables should be calculated (for example, \code{by} = 3 #' indicates summary will be calculated for groups of 3 consecutive color points (rows)#' in the quantum catch color data frame) or a vector containing identifications for #' the rows in the quantum catch color data frame (in which case summaries will be #' calculated for each group of points sharing the same identification). If \code{by} #' is left blank, the summary statistics are calculated accross all color points in the#' data. #' @param qcatch Quantum catch values to use in the model. Can be either \code{Qi}, #' \code{qi} or \code{fi} (defaults to \code{Qi}).#' #' @return a data frame consisting of the following rows:#' @return \code{u}, \code{s}, \code{m}, \code{l}: the quantum catch data used to#' calculate the remaining variables. NOTE: even if visual sistem is of type V-VIS,#' the output column will be labeled \code{u}.#' @return \code{u.r}, \code{s.r}, \code{m.r}, \code{l.r}: relative cone stimulation,#' for a given hue, as a function of saturation. See Stoddard & Prum (2008) for details.#' @return \code{x}, \code{y}, \code{z}: cartesian coordinates for the points in the#' tetrahedral color space.#' @return \code{h.theta}, \code{h.phi}: angles theta and phi, in radians, determining#' the hue of the color.#' @return \code{r.vec}: the r vector (saturation, distance from the achromatic center).#' @return \code{r.max}: the maximum r vector achievable for the color's hue.#' @return \code{r.achieved}: the relative r distance from the achromatic center, in#' relation to the maximum distance achievable (\code{r.vec/r.max})#' @export#' @examples \dontrun{#' #INCLUDE EXAMPLE}#' @author Rafael Maia \email{rm72@@zips.uakron.edu}#' @references Stoddard, M. C., & Prum, R. O. (2008). Evolution of avian plumage color in a tetrahedral color space: A phylogenetic analysis of new world buntings. The American Naturalist, 171(6), 755-776.#' @references Endler, J. A., & Mielke, P. (2005). Comparing entire colour patterns as birds see them. Biological Journal Of The Linnean Society, 86(4), 405–431.tcs<- function(vismodeldata, by=NULL, qcatch=c('Qi','qi','fi')){#
if(class(vismodeldata)=='vismodel'){	qcatch <- match.arg(qcatch)	dat <- data.frame(vismodeldata[qcatch])  }else{  	dat <- vismodeldata  	}#
# make relative (in case not inherited relative)dat <- dat/rowSums(dat)u <- dat[,1]s <- dat[,2]m <- dat[,3]l <- dat[,4]# cartesian coordinates#
x <- ((1-2*s-m-u)/2)*sqrt(3/2)y <- (-1+3*m+u)/(2*sqrt(2))z <- u-(1/4)#
# vertex cartesian coordinates & their spherical datattvx <- pavo::ttvertex#
# spherical coordinates for the data points# S&P suggest values with reflectance lower than a treshold (0.05) not have # hue & r . not implemented.#
r.vec<- sqrt(x*x + y*y + z*z)r.vec[r.vec==0] = NaN#
h.theta<- atan2(y,x)h.phi<- asin(z/r.vec)#
#Rmax & Robtained#
cosalpha.u <- cos(h.phi)*cos(ttvx$Huephi.u)*cos(h.theta-ttvx$Huetheta.u) +  sin(h.phi)*sin(ttvx$Huephi.u)cosalpha.s <- cos(h.phi)*cos(ttvx$Huephi.s)*cos(h.theta-ttvx$Huetheta.s) +  sin(h.phi)*sin(ttvx$Huephi.s)cosalpha.m <- cos(h.phi)*cos(ttvx$Huephi.m)*cos(h.theta-ttvx$Huetheta.m) +  sin(h.phi)*sin(ttvx$Huephi.m)cosalpha.l <- cos(h.phi)*cos(ttvx$Huephi.l)*cos(h.theta-ttvx$Huetheta.l) +  sin(h.phi)*sin(ttvx$Huephi.l)#
allcosalpha <- data.frame(cosalpha.u,cosalpha.s,cosalpha.m,cosalpha.l)#
cosalphamax <- apply(allcosalpha,1,min)r.max<- (0.25)/(-(cosalphamax))#
r.achieved <- r.vec/r.max#
# cone stimulation (for a given hue as a function of saturation, see S&P ESM)# this is not really used, ever -- should we include it?#
u.r<-r.vec*cosalpha.us.r<-r.vec*cosalpha.sm.r<-r.vec*cosalpha.ml.r<-r.vec*cosalpha.l#
res.p <- data.frame(u, s, m, l, u.r , s.r, m.r, l.r,                   x, y, z, h.theta, h.phi,                   r.vec, r.max, r.achieved,                  row.names=rownames(dat))#names(res)[1:4] <- names(dat)####################SUMMARY VARIABLES####################if(!is.null(by)){#
	if(length(by)==1){	by.many <- by	by <- rep(1:(dim(res.p)[1]/by),each=by)	by <- factor(by,labels=row.names(res.p)[seq(1,length(row.names(res.p)),by=by.many)])    }  by <- factor(by)  res.c <- data.frame(t(sapply(levels(by),function(z)tcssum(res.p[which(by==z),]))))  row.names(res.c) <- levels(by)#
}else{	res.c <- data.frame(t(tcssum(res.p)))	row.names(res.c) <- 'all.points'}#
res<-list(tcs=res.p,summary=res.c)res}
getspec("~/Documents/School/PhD/Projects/Duck color evolution/data/2012-05-07 FMNH/spectra/dissected")
specs <- getspec("~/Documents/School/PhD/Projects/Duck color evolution/data/2012-05-07 FMNH/spectra/dissected", ext="ttt")
head(specs)
class(specs)
tcs(specs)
vismodel(specs, visual="avg.v")
install.packages('devtools')
require(devtools)
require(pavo)
install.packages("source('~/Documents/pavo/R/pavo-package.R', chdir = TRUE)", type='source')
pavo::
rm(ls())
ls
rm(all)
rm("all")
?rm
rm(list=ls())
install.packages("~/Documents/pavo/R/pavo-package.R", type='source')
install.packages("~/Documents/pavo/R/pavo-package.R", type='source', respos=NULL)
devtools
install.packages("source('~/Documents/pavo', chdir = TRUE)", type='source')
ls()
install.packages("source('~/Documents/pavo/R', chdir = TRUE)", type='source')
install.packages("/Documents/pavo/R", type='source')
install.packages("/Documents/pavo", type='source')
install.packages("pavo", "/Documents/pavo/R", type='source')
pavo
install_github('coloRtools', 'rmaia')
install.packages("~/Documents/pavo", type='source')
