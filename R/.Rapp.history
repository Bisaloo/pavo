formatC(testframe)
paste(testframe[,1],testframe[,2])
sapply(testframe,paste)
?paste
unlist(testframe)
paste(unlist(testframe))
do.call('paste',testframe)
paste(testframe)
do.call('paste',testframe,sep='.')
do.call('paste',args=list(x=testframe,sep='.'))
?do.call
paste(testframe,collapse='.')
paste(testframe,collapse=' ')
apply(testframe,1,paste,collapse='.')
apply(vec1,1,paste,collapse='.')
apply(testframe,1,paste,collapse='.')
sapply(testframe,paste,collapse='.')
apply(testframe,1,paste,collapse='.')
30/3
integer(30/2)
integer(30/3)
is.integer(30)
?is.integer
30
30/3
seq(1:30/3)
seq(1:30/3,each=3)
rep(1:30/3,each=3)
1/30
1:30/3
1:(30/3)
rep(1:(30/3),each=3)
length(30)==1
1:30
seq(1,30,by=3)
names(sptest)[seq(1,length(names(sptest)),by=2)]
names)sptest
names(sptest)
Function to calculate average of columns given a column index (by)#
# Returns a matrix with column names as the by's and rows as averaged values for each wl#
# Input column 1 should be wavelengths#
#
# RM tip: Always provide useful defaults. If you don't want to provide one #
#     (i.e. there is no meaningful default), leave arg empty. Default is to return #
#     error. But if there's an implemented default (i.e. for FUN), use it.#
#
agg <- function(x, by, FXN = mean) {#
#
#BEGIN RM EDIT#
# check: user may have removed 'wl' function already.#
# (data.frame doesn't allow duplicate names anymore, so this should work)#
#
wl_index <- which(names(x)=='wl')#
#
if(length(wl_index>0)){#
	wl <- x[,wl_index]#
	y <- x[,-wl_index]#
	}else{#
		y <- x#
		}#
#
# retain original values#
by0 <- by#
#
if(length(by)==1){#
	by0 <- names(y)[seq(1,length(names(y)),by=by)]#
	by <- rep(1:(length(y)/by),each=by)#
}#
#
# check: does x have the same number of columns as the by vector?#
#
if(dim(y)[2]!=length(by)) #
stop(paste('\n',dQuote(deparse(substitute(by))),'is not of same length as columns in',dQuote(deparse(substitute(x)))))#
#
#END RM EDIT#
#BEGIN RM EDIT#
#(unvectorized backup version is below)#
#
by <- factor(by)#
#
dat <- sapply(levels(by),function(z)apply(y[which(by==z)],1,FXN))#
#
#END RM EDIT#
#
colnames(dat) <- unique(by0)#
data.frame(cbind(wl=wl, dat))#
}#
#BACKUP#
# allow for numeric, character data#
# by <- as.numeric(factor(by))  #
#
# dat <- matrix(data = NA, nrow = nrow(y), ncol = length(unique(by)))#
#
# for (i in seq(along = unique(by))) {#
# # apply can't avg single columns#
	# if (is.null(dim(y[,by==i]))) {#
	   # dat[,i] <- apply(cbind(y[,by==i], y[,by==i]), 1, FUN)#
	# }else{#
		# dat[,i] <- apply(y[,by==i], 1, FUN)#
		# }#
# }
names(sptest)
agg(sptest[,-8],2)
agg(sptest[,-8],c(1,2,1,2,1,2))
agg(sptest[,-8],3)
agg(sptest[,-8],4)
agg(sptest[,-8],3)
names(sptest[,-8])
agg(sptest,3)
agg(sptest,2)
install.packages('roxygen2'')
install.packages('roxygen2')
require(roxygen2)
roxygenize('~/github/rebird')
install.packages('wordcloud')
install.packages('XML')
source('~/github/rebird/R/geo_recent.R')
?geo_recent
?ebird_geo
install.packages('~/github/rebird',type='source',repos=NULL)
require(rebird)
?geo_recent
?mean
roxygenize('~/github/rebird')
install.packages('~/github/rebird',type='source',repos=NULL)
?geo_recent
a=NULL
length(a)
require(pavo)#
#
a=getspec('~/github/pavo/examplespec')#
b=getspec('~/github/pavo/examplespec','ttt')#
a=data.frame(cbind(a,b))#
rm(b)#
vis.a=vismodel(a)#
tcs.a=tcs(vis.a)#
testdf=vis.a$Qi
testdf
dim(tesdfg)
dim(tesdf)
dim(testdf)
testdf=rbind(testdf,testdf,testdf)
dim(testdf)
load("/Users/rmaia/github/pavo/R/sysdata.rda")
ls()
require(roxygen)
require(roxygen2)
roxygenize('~/github/pavo')
require(roxygen2)
roxygenize('~/github/pavo')
install.packages('~/github/pavo',repos=NULL,type='source')
?pavo::voloverlap
roxygenize('~/github/pavo')
install.packages('~/github/pavo',repos=NULL,type='source')
?pavo::voloverlap
require(devtools)
dev_mode()
kak
?dev_mode()
install_github('pavo','rmaia')
dev_mode()
require(pavo)
?voloverlap
require(ggplot2)#
#
ranking = read.csv('~/Desktop/EBJClub Results.csv')#
#
ranking_valid = ranking[ranking$valid==1,]#
#
tapply(ranking$rank,ranking$paper,mean)#
plot( tapply(ranking$rank,ranking$paper,mean) ~ tapply(ranking$rank,ranking$paper,median))#
#
plot( tapply(ranking$rank,ranking$paper,mean) ~ tapply(ranking_valid$rank,ranking_valid$paper,mean))#
#
plot( tapply(ranking$rank,ranking$paper,median) ~ tapply(ranking_valid$rank,ranking_valid$paper,median))#
head(sort(tapply(ranking$rank,ranking$paper,mean)),10)#
head(sort(tapply(ranking$rank,ranking$paper,median)),10)#
#
head(sort(tapply(ranking_valid$rank,ranking_valid$paper,mean)),10)#
head(sort(tapply(ranking_valid$rank,ranking_valid$paper,median)),10)#
ggplot(data=ranking,aes(x=paper,y=rank)) + geom_violin(fill='darkgrey') + xlim(names(sort(tapply(ranking$rank,ranking$paper,median)))) + theme_bw()#
ggplot(data=ranking_valid,aes(x=paper,y=rank)) #
#
head(sort(tapply(ranking$rank,ranking$paper,median)),11)[-1]#
#
tail(sort(tapply(ranking$rank,ranking$paper,median)),6)#
#
bestranked = head(sort(tapply(ranking$rank,ranking$paper,median)),11)[-1]#
bestranked=names(bestranked)#
#
set.seed(13071982)
sample(bestranked,4)
set.seed(13071982)
sample(bestranked,8)
sample(bestranked,10)
sample(bestranked,12)
set.seed(13071982)
sample(bestranked,11)
sample(bestranked,10)
voloverlap2 <- function(tcsres1,tcsres2, plot=FALSE){#
#
if(class(tcsres1)=='tcs'){#
  dat1 <- tcsres1$tcs[, c('x', 'y', 'z')]	#
  }else{#
    dat1 <- tcsres1[, c('x', 'y', 'z')]#
    }#
#
if(class(tcsres2)=='tcs'){#
  dat2 <- tcsres2$tcs[, c('x', 'y', 'z')]	#
  }else{#
    dat2 <- tcsres2[, c('x', 'y', 'z')]#
    }#
#
# calculate their volumes#
#
vol1 <- convhulln(dat1, 'FA')$vol#
vol2 <- convhulln(dat2, 'FA')$vol#
rat1 <- d2q(cbind(0, cbind(1, as.matrix(dat1))))#
rat2 <- d2q(cbind(0, cbind(1, as.matrix(dat2))))#
#
vert1 <- redundant(rat1, representation = "V")$output#
vert2 <- redundant(rat2, representation = "V")$output#
#
Hvert1 <- scdd(vert1, representation = "V")$output#
Hvert2 <- scdd(vert2, representation = "V")$output#
#
Hinter <- rbind(Hvert1, Hvert2)#
Vinter <- scdd(Hinter, representation = "H")$output#
#
Voverlap <- data.frame(q2d(Vinter[ , - c(1, 2)]))#
names(Voverlap) = c('x','y','z')#
#
if(dim(Voverlap)[1]>3){#
  overlapVol <- convhulln(Voverlap, 'FA')$vol#
  }else{#
    overlapVol <- 0#
    }#
#
psmallest <- overlapVol/min(c(vol1,vol2))#
#
pboth <- overlapVol/sum(c(vol1,vol2))#
#
if(plot==T){#
  open3d(FOV=1, mouseMode=c('zAxis','xAxis','zoom'))#
  ttvol(overlapVol)#
  ttvol(dat1, col='red', fill=F)#
  ttvol(dat2, col='blue', fill=F)#
  }#
#
data.frame(vol1, vol2, psmallest,pboth)#
#
}
require(pavo)
data(sicalis)
tcs.sicalis.C <- tcs(vismodel(sicalis[c(1,grep('\\.C',names(sicalis)))]))
tcs.sicalis.T <- tcs(vismodel(sicalis[c(1,grep('\\.T',names(sicalis)))]))
tcs.sicalis.B <- tcs(vismodel(sicalis[c(1,grep('\\.B',names(sicalis)))]))
voloverlap2(tcs.sicalis.T,tcs.sicalis.B)
require(rcpp)
require(rcdd)
voloverlap2(tcs.sicalis.T,tcs.sicalis.B)
voloverlap2(tcs.sicalis.T,tcs.sicalis.C)
voloverlap2(tcs.sicalis.T,tcs.sicalis.C, plot=T)
ttvol
' Color volume overlap#
#'#
#' calculates the overlap between the volumes defined by two sets of points in cartesian#
#' space#
#'#
#' @export#
#' @param tcsres1 (required) data frame, possibly a result from the \code{tcs} #
#' function, containing#
#' values for the 'x', 'y' and 'z' coordinates as columns (labeled as such)#
#' @param tcsres2 (required) data frame, possibly a result from the \code{tcs} #
#' function, containing#
#' values for the 'x', 'y' and 'z' coordinates as columns (labeled as such)#
#' @param nsamp number of simulated points#
#' @param plot Should the volumes and points be plotted? (defaults to \code{FALSE}.)#
#' @param size Size of the spheres in the 3D volume plot (if called)#
#' @return Calculates the overlap between the volumes defined by two set of points in#
#' colorspace. This is done by simulating points from a uniform distribution defined by#
#' the combined values of the points, and obtaining the frequency of simulated values that#
#' fall inside the volumes defeined by both sets of color points. This frequency is then#
#' compared to (1) the frequency of values that fall within the smallest volume#
#' (Stoddard & Stevens 2011), and (2) the combined volume of both sets of color points.#
#'#
#' @note Stoddard & Stevens (2011) calculate the volume overlap relative to one of the#
#' volumes compared (i.e. how many of the simulated points that fall in volume 1 also #
#' fall in volume 2), and we return this value (which is always relative to the smallest#
#' volume). However, this value may not be what one expects to obtain if (1) the two #
#' volumes differ considerably in size, or (2) one of the volumes is entirely contained#
#' within the other. For this reason, we also report p(both)/(p(vol1)+p(vol2)), which#
#' may be more adequate in those cases.#
#' @note The simulation process requires the calculation of many convex hulls, and#
#' therefore may be computationally intensive and take considerably long if many points#
#' are simulated. Given that depending on the shape of the color volumes many of the points#
#' simulated may fall outside either volumes, make sure to check the output to see if a#
#' decent sample size is falling withing the volumes and being used in calculations.#
#' @examples \dontrun{#
#' data(sicalis)#
#' tcs.sicalis.C <- tcs(vismodel(sicalis[c(1,grep('\\.C',names(sicalis)))]))#
#' tcs.sicalis.T <- tcs(vismodel(sicalis[c(1,grep('\\.T',names(sicalis)))]))#
#' tcs.sicalis.B <- tcs(vismodel(sicalis[c(1,grep('\\.B',names(sicalis)))]))#
#' voloverlap(tcs.sicalis.T,tcs.sicalis.B, nsamp=5000)#
#' voloverlap(tcs.sicalis.T,tcs.sicalis.C, plot=T) }#
#' @author Rafael Maia \email{rm72@@zips.uakron.edu}#
#' @references Stoddard, M. C., & Prum, R. O. (2008). Evolution of avian plumage color in a tetrahedral color space: A phylogenetic analysis of new world buntings. The American Naturalist, 171(6), 755-776.#
#' @references Stoddard, M. C., & Stevens, M. (2011). Avian vision and the evolution of egg color mimicry in the common cuckoo. Evolution, 65(7), 2004-2013.#
voloverlap2 <- function(tcsres1,tcsres2, plot=FALSE){#
#
if(class(tcsres1)=='tcs'){#
  dat1 <- tcsres1$tcs[, c('x', 'y', 'z')]	#
  }else{#
    dat1 <- tcsres1[, c('x', 'y', 'z')]#
    }#
#
if(class(tcsres2)=='tcs'){#
  dat2 <- tcsres2$tcs[, c('x', 'y', 'z')]	#
  }else{#
    dat2 <- tcsres2[, c('x', 'y', 'z')]#
    }#
#
# calculate their volumes#
#
vol1 <- convhulln(dat1, 'FA')$vol#
vol2 <- convhulln(dat2, 'FA')$vol#
rat1 <- d2q(cbind(0, cbind(1, as.matrix(dat1))))#
rat2 <- d2q(cbind(0, cbind(1, as.matrix(dat2))))#
#
vert1 <- redundant(rat1, representation = "V")$output#
vert2 <- redundant(rat2, representation = "V")$output#
#
Hvert1 <- scdd(vert1, representation = "V")$output#
Hvert2 <- scdd(vert2, representation = "V")$output#
#
Hinter <- rbind(Hvert1, Hvert2)#
Vinter <- scdd(Hinter, representation = "H")$output#
#
Voverlap <- data.frame(q2d(Vinter[ , - c(1, 2)]))#
names(Voverlap) = c('x','y','z')#
#
if(dim(Voverlap)[1]>3){#
  overlapVol <- convhulln(Voverlap, 'FA')$vol#
  }else{#
    overlapVol <- 0#
    }#
#
psmallest <- overlapVol/min(c(vol1,vol2))#
#
pboth <- overlapVol/sum(c(vol1,vol2))#
#
if(plot==T){#
  open3d(FOV=1, mouseMode=c('zAxis','xAxis','zoom'))#
  if(dim(Voverlap)[1]>3)#
    ttvol(overlapVol)#
  ttvol(dat1, col='red', fill=F)#
  ttvol(dat2, col='blue', fill=F)#
  }#
#
data.frame(vol1, vol2, psmallest,pboth)#
#
}
voloverlap2(tcs.sicalis.T,tcs.sicalis.C, plot=T)
voloverlap2(tcs.sicalis.T,tcs.sicalis.B, plot=T)
ttvol
tcsres1=tcs.sicalis.B
if(class(tcsres1)=='tcs'){#
  dat1 <- tcsres1$tcs[, c('x', 'y', 'z')]	#
  }else{#
    dat1 <- tcsres1[, c('x', 'y', 'z')]#
    }
dat1
open3d(FOV=1, mouseMode=c('zAxis','xAxis','zoom'))
ttvol(dat1, col='red', fill=F)
tcsres2=tcs.sicalis.T
if(class(tcsres2)=='tcs'){#
  dat2 <- tcsres2$tcs[, c('x', 'y', 'z')]	#
  }else{#
    dat2 <- tcsres2[, c('x', 'y', 'z')]#
    }
class(dat2)
vol1 <- convhulln(dat1, 'FA')$vol#
vol2 <- convhulln(dat2, 'FA')$vol#
rat1 <- d2q(cbind(0, cbind(1, as.matrix(dat1))))#
rat2 <- d2q(cbind(0, cbind(1, as.matrix(dat2))))#
#
vert1 <- redundant(rat1, representation = "V")$output#
vert2 <- redundant(rat2, representation = "V")$output#
#
Hvert1 <- scdd(vert1, representation = "V")$output#
Hvert2 <- scdd(vert2, representation = "V")$output#
#
Hinter <- rbind(Hvert1, Hvert2)#
Vinter <- scdd(Hinter, representation = "H")$output#
#
Voverlap <- data.frame(q2d(Vinter[ , - c(1, 2)]))#
names(Voverlap) = c('x','y','z')
Voverlap
open3d(FOV=1, mouseMode=c('zAxis','xAxis','zoom'))
ttvol(overlapVol)
if(dim(Voverlap)[1]>3){#
  overlapVol <- convhulln(Voverlap, 'FA')$vol#
  }else{#
    overlapVol <- 0#
    }
overlapvol
overlapVol
ttvol(Voverlap)
ls()
rm(list=ls())
voloverlap2 <- function(tcsres1,tcsres2, plot=FALSE){#
#
if(class(tcsres1)=='tcs'){#
  dat1 <- tcsres1$tcs[, c('x', 'y', 'z')]	#
  }else{#
    dat1 <- tcsres1[, c('x', 'y', 'z')]#
    }#
#
if(class(tcsres2)=='tcs'){#
  dat2 <- tcsres2$tcs[, c('x', 'y', 'z')]	#
  }else{#
    dat2 <- tcsres2[, c('x', 'y', 'z')]#
    }#
#
# calculate their volumes#
#
vol1 <- convhulln(dat1, 'FA')$vol#
vol2 <- convhulln(dat2, 'FA')$vol#
rat1 <- d2q(cbind(0, cbind(1, as.matrix(dat1))))#
rat2 <- d2q(cbind(0, cbind(1, as.matrix(dat2))))#
#
vert1 <- redundant(rat1, representation = "V")$output#
vert2 <- redundant(rat2, representation = "V")$output#
#
Hvert1 <- scdd(vert1, representation = "V")$output#
Hvert2 <- scdd(vert2, representation = "V")$output#
#
Hinter <- rbind(Hvert1, Hvert2)#
Vinter <- scdd(Hinter, representation = "H")$output#
#
Voverlap <- data.frame(q2d(Vinter[ , - c(1, 2)]))#
names(Voverlap) = c('x','y','z')#
#
if(dim(Voverlap)[1]>3){#
  overlapVol <- convhulln(Voverlap, 'FA')$vol#
  }else{#
    overlapVol <- 0#
    }#
#
psmallest <- overlapVol/min(c(vol1,vol2))#
#
pboth <- overlapVol/sum(c(vol1,vol2))#
#
if(plot==T){#
  open3d(FOV=1, mouseMode=c('zAxis','xAxis','zoom'))#
  if(dim(Voverlap)[1]>3)#
    ttvol(Voverlap)#
  ttvol(dat1, col='red', fill=F)#
  ttvol(dat2, col='blue', fill=F)#
  }#
#
data.frame(vol1, vol2, psmallest,pboth)#
#
}
data(sicalis)
tcs.sicalis.C <- tcs(vismodel(sicalis[c(1,grep('\\.C',names(sicalis)))]))
tcs.sicalis.T <- tcs(vismodel(sicalis[c(1,grep('\\.T',names(sicalis)))]))
tcs.sicalis.B <- tcs(vismodel(sicalis[c(1,grep('\\.B',names(sicalis)))]))
voloverlap(tcs.sicalis.T,tcs.sicalis.B)
voloverlap2(tcs.sicalis.T,tcs.sicalis.B)
voloverlap2(tcs.sicalis.T,tcs.sicalis.C)
voloverlap2(tcs.sicalis.B,tcs.sicalis.C)
voloverlap2(tcs.sicalis.B,tcs.sicalis.B)
vcombined <- convhulln(rbind(dat1,dat2), 'FA')$vol
voloverlap2 <- function(tcsres1,tcsres2, plot=FALSE){#
#
if(class(tcsres1)=='tcs'){#
  dat1 <- tcsres1$tcs[, c('x', 'y', 'z')]	#
  }else{#
    dat1 <- tcsres1[, c('x', 'y', 'z')]#
    }#
#
if(class(tcsres2)=='tcs'){#
  dat2 <- tcsres2$tcs[, c('x', 'y', 'z')]	#
  }else{#
    dat2 <- tcsres2[, c('x', 'y', 'z')]#
    }#
#
# calculate their volumes#
#
vol1 <- convhulln(dat1, 'FA')$vol#
vol2 <- convhulln(dat2, 'FA')$vol#
#
vcombined <- convhulln(rbind(dat1,dat2), 'FA')$vol#
rat1 <- d2q(cbind(0, cbind(1, as.matrix(dat1))))#
rat2 <- d2q(cbind(0, cbind(1, as.matrix(dat2))))#
#
vert1 <- redundant(rat1, representation = "V")$output#
vert2 <- redundant(rat2, representation = "V")$output#
#
Hvert1 <- scdd(vert1, representation = "V")$output#
Hvert2 <- scdd(vert2, representation = "V")$output#
#
Hinter <- rbind(Hvert1, Hvert2)#
Vinter <- scdd(Hinter, representation = "H")$output#
#
Voverlap <- data.frame(q2d(Vinter[ , - c(1, 2)]))#
names(Voverlap) = c('x','y','z')#
#
if(dim(Voverlap)[1]>3){#
  overlapVol <- convhulln(Voverlap, 'FA')$vol#
  }else{#
    overlapVol <- 0#
    }#
#
psmallest <- overlapVol/min(c(vol1,vol2))#
#
pboth <- overlapVol/vcombined#
#
if(plot==T){#
  open3d(FOV=1, mouseMode=c('zAxis','xAxis','zoom'))#
  if(dim(Voverlap)[1]>3)#
    ttvol(Voverlap)#
  ttvol(dat1, col='red', fill=F)#
  ttvol(dat2, col='blue', fill=F)#
  }#
#
data.frame(vol1, vol2, psmallest,pboth)#
#
}
voloverlap2(tcs.sicalis.B,tcs.sicalis.B)
voloverlap2(tcs.sicalis.B,tcs.sicalis.C)
voloverlap2(tcs.sicalis.B,tcs.sicalis.T)
CHVintersect<-function(set1,set2) {#
#################################
# loading required libraries   # #
library(geometry)              ##
library(rcdd)                  ##
#################################
############################
# checking inputs         ##
############################
# number of dimensions#
if(ncol(set1)!=ncol(set2)) stop("error : different number of dimensions in the two set of points") #
#
# number of points#
if (nrow(set1)<=ncol(set1))  stop(paste("error : 'set1' must contain at least ",ncol(set1)+1, " points",sep=""))#
if (nrow(set2)<=ncol(set2))  stop(paste("error : 'set2' must contain at least ",ncol(set2)+1, " points",sep=""))#
#
# checking absence of NA#
if (length(which(is.na(set1)==T))!=0) stop(paste("error : NA are not allowed in coordinates of 'set1'",sep=""))#
if (length(which(is.na(set2)==T))!=0) stop(paste("error : NA are not allowed in coordinates of 'set2'",sep=""))#
#
###############################################################################
# tranforming coordinates in true rational number written as character string#
set1rep <- d2q(cbind(0, cbind(1, set1)))#
set2rep <- d2q(cbind(0, cbind(1, set2)))#
# reduce set of points to vertices only using redundant function#
polytope1 <- redundant(set1rep, representation = "V")$output#
polytope2 <- redundant(set2rep, representation = "V")$output#
# changing polytope representation: vertices to inequality constraints#
H_chset1 <- scdd(polytope1, representation = "V")$output#
H_chset2 <- scdd(polytope2, representation = "V")$output#
# intersection between the two polytopes#
H_inter <- rbind(H_chset1, H_chset2)#
V_inter <- scdd(H_inter, representation = "H")$output#
# extracting coordinates of vertices#
vert_set1 <- q2d(polytope1[ , - c(1, 2)])#
vert_set2 <- q2d(polytope2[ , - c(1, 2)])#
vert_inter <- q2d(V_inter[ , - c(1, 2)])#
# computing convex hull volume of the two polytopes and of their intersection if it exists (no intersection if one vertex in common)#
vol<-rep(0,3) ; names(vol)<-c("vol_set1","vol_set2","vol_inter")#
vol["vol_set1"]<-convhulln(vert_set1,"FA")$vol#
vol["vol_set2"]<-convhulln(vert_set2,"FA")$vol#
if (is.matrix(vert_inter)==T) # vector if one vertex in common#
      if( nrow(vert_inter)>ncol(vert_inter) ) vol["vol_inter"]<-convhulln(vert_inter,"FA")$vol#
#################################################################################
# results#
#
res<-list(vert_set1=vert_set1, vert_set2=vert_set2, vert_inter=vert_inter, vol=vol)#
return(res)    #
} # end of function CHVintersect
trivial example in 2D with 4 communities#
A<-cbind( c(6,10,12,10,6), c(6,6,8,10,9) ) ; B<-cbind( c(4,8,9,9,5,4), c(4,4,6,7,7,5) )#
C<-cbind( c(3,5,7,7,5,3), c(6,4,5,8,10,9) ) ; D<-cbind( c(10,12,12,10), c(3,3,8,8) )#
#
# graphic#
col<-c("#FF570A", "#4B8AEF", "#11A123", "#ADAEAE")#
plot(rbind(A,B,C,D),type="n", xlab="Trait 1", ylab="Trait 2",xlim=c(2.5,12.5),ylim=c(2.5,10.5) )#
abline(v=1:12, lty=2, col="grey") ; abline(h=1:12, lty=2, col="grey") # grid to "see" surfaces#
points(A,pch=21,col=col[1],bg=col[1],cex=1.5) ; points(B,pch=21,col=col[2],bg=col[2],cex=1)#
points(C,pch=21,col=col[3],bg=col[3],cex=1) ; points(D,pch=21,col=col[4],bg=col[4],cex=1)#
polygon(A,border=col[1],col=paste(col[1],80,sep=""), lwd=2 )#
polygon(B,border=col[2],col=paste(col[2],80,sep=""), lwd=2 ) #
polygon(C,border=col[3],col=paste(col[3],80,sep=""), lwd=2 )#
polygon(D,border=col[4],col=paste(col[4],80,sep=""), lwd=2 )#
text(9,8,"A",col=col[1],cex=3) ; text(7.5,5.5,"B",col=col[2],cex=3)#
text(4.5,8,"C",col=col[3],cex=3) ; text(11,5.5,"D",col=col[4],cex=3)
AB<-CHVintersect(A,B) #
print("#########  AB") ; print(AB)
' Color volume overlap#
#'#
#' calculates the overlap between the volumes defined by two sets of points in cartesian#
#' space#
#'#
#' @export#
#' @param tcsres1 (required) data frame, possibly a result from the \code{tcs} #
#' function, containing#
#' values for the 'x', 'y' and 'z' coordinates as columns (labeled as such)#
#' @param tcsres2 (required) data frame, possibly a result from the \code{tcs} #
#' function, containing#
#' values for the 'x', 'y' and 'z' coordinates as columns (labeled as such)#
#' @param nsamp number of simulated points#
#' @param plot Should the volumes and points be plotted? (defaults to \code{FALSE}.)#
#' @param size Size of the spheres in the 3D volume plot (if called)#
#' @return Calculates the overlap between the volumes defined by two set of points in#
#' colorspace. This is done by simulating points from a uniform distribution defined by#
#' the combined values of the points, and obtaining the frequency of simulated values that#
#' fall inside the volumes defeined by both sets of color points. This frequency is then#
#' compared to (1) the frequency of values that fall within the smallest volume#
#' (Stoddard & Stevens 2011), and (2) the combined volume of both sets of color points.#
#'#
#' @note Stoddard & Stevens (2011) calculate the volume overlap relative to one of the#
#' volumes compared (i.e. how many of the simulated points that fall in volume 1 also #
#' fall in volume 2), and we return this value (which is always relative to the smallest#
#' volume). However, this value may not be what one expects to obtain if (1) the two #
#' volumes differ considerably in size, or (2) one of the volumes is entirely contained#
#' within the other. For this reason, we also report p(both)/(p(vol1)+p(vol2)), which#
#' may be more adequate in those cases.#
#' @note The simulation process requires the calculation of many convex hulls, and#
#' therefore may be computationally intensive and take considerably long if many points#
#' are simulated. Given that depending on the shape of the color volumes many of the points#
#' simulated may fall outside either volumes, make sure to check the output to see if a#
#' decent sample size is falling withing the volumes and being used in calculations.#
#' @examples \dontrun{#
#' data(sicalis)#
#' tcs.sicalis.C <- tcs(vismodel(sicalis[c(1,grep('\\.C',names(sicalis)))]))#
#' tcs.sicalis.T <- tcs(vismodel(sicalis[c(1,grep('\\.T',names(sicalis)))]))#
#' tcs.sicalis.B <- tcs(vismodel(sicalis[c(1,grep('\\.B',names(sicalis)))]))#
#' voloverlap(tcs.sicalis.T,tcs.sicalis.B, nsamp=5000)#
#' voloverlap(tcs.sicalis.T,tcs.sicalis.C, plot=T) }#
#' @author Rafael Maia \email{rm72@@zips.uakron.edu}#
#' @references Stoddard, M. C., & Prum, R. O. (2008). Evolution of avian plumage color in a tetrahedral color space: A phylogenetic analysis of new world buntings. The American Naturalist, 171(6), 755-776.#
#' @references Stoddard, M. C., & Stevens, M. (2011). Avian vision and the evolution of egg color mimicry in the common cuckoo. Evolution, 65(7), 2004-2013.#
voloverlap2 <- function(tcsres1,tcsres2, plot=FALSE){#
#
if(class(tcsres1)=='tcs'){#
  dat1 <- tcsres1$tcs[, c('x', 'y', 'z')]	#
  }else{#
    dat1 <- tcsres1[, c('x', 'y', 'z')]#
    }#
#
if(class(tcsres2)=='tcs'){#
  dat2 <- tcsres2$tcs[, c('x', 'y', 'z')]	#
  }else{#
    dat2 <- tcsres2[, c('x', 'y', 'z')]#
    }#
#
# calculate their volumes#
#
vol1 <- convhulln(dat1, 'FA')$vol#
vol2 <- convhulln(dat2, 'FA')$vol#
rat1 <- d2q(cbind(0, cbind(1, as.matrix(dat1))))#
rat2 <- d2q(cbind(0, cbind(1, as.matrix(dat2))))#
#
vert1 <- redundant(rat1, representation = "V")$output#
vert2 <- redundant(rat2, representation = "V")$output#
#
Hvert1 <- scdd(vert1, representation = "V")$output#
Hvert2 <- scdd(vert2, representation = "V")$output#
#
Hinter <- rbind(Hvert1, Hvert2)#
Vinter <- scdd(Hinter, representation = "H")$output#
#
Voverlap <- data.frame(q2d(Vinter[ , - c(1, 2)]))#
names(Voverlap) = c('x','y','z')#
#
if(dim(Voverlap)[1]>3){#
  overlapVol <- convhulln(Voverlap, 'FA')$vol#
  }else{#
    overlapVol <- 0#
    }#
#
psmallest <- overlapVol/min(c(vol1,vol2))#
#
pboth <- overlapVol/(sum(c(vol1,vol2))-overlapVol)#
#
if(plot==T){#
  open3d(FOV=1, mouseMode=c('zAxis','xAxis','zoom'))#
  if(dim(Voverlap)[1]>3)#
    ttvol(Voverlap)#
  ttvol(dat1, col='red', fill=F)#
  ttvol(dat2, col='blue', fill=F)#
  }#
#
data.frame(vol1, vol2, psmallest,pboth)#
#
}
voloverlap2(tcs.sicalis.B,tcs.sicalis.T)
voloverlap2(tcs.sicalis.B,tcs.sicalis.C)
voloverlap2(tcs.sicalis.B,tcs.sicalis.B)
voloverlap2(tcs.sicalis.B,tcs.sicalis.C, plot=T)
voloverlap2(tcs.sicalis.B,tcs.sicalis.T, plot=T)
?scdd
require(scdd)
require(rcdd)
?scdd
require(rcc)
require(rccd)
require(rcdd)
require(roxygen2)
roxygenize('~/github/pavo')
require(devtools)
dev_mode()
install.packages('~/github/pavo', repos=NULL, type='source')
require(pavo)
?voloverlap2
data(sicalis)#
tcs.sicalis.C <- tcs(vismodel(sicalis[c(1,grep('\\.C',names(sicalis)))]))#
tcs.sicalis.T <- tcs(vismodel(sicalis[c(1,grep('\\.T',names(sicalis)))]))#
tcs.sicalis.B <- tcs(vismodel(sicalis[c(1,grep('\\.B',names(sicalis)))]))#
voloverlap2(tcs.sicalis.T,tcs.sicalis.B)
require(pavo)
hums = getspec('~/Desktop/Hummers-microspec', lim=c(280,950), negative='min')
names(hums)
plot.spec.curves <- function (x, specreps) {#
#
plotnumber <- 1#
nplots <- ((ncol(x)-1)/specreps)#
par(mfrow=c(3,4),ask=TRUE)#
#
for (i in 1:nplots){#
#
	bloc <-x[,(((plotnumber-1)*specreps)+2):((plotnumber*specreps)+1)]#
	specs <- c(1:ncol(bloc))#
	yaxismin <-min(bloc)#
	yaxismax <-max(bloc)#
	plot(x[,1],bloc[,1],cex=0.1,ylim=c(yaxismin,yaxismax+5),col=1,xlab="Wavelength (nm)",ylab="% Reflectance")#
	legend (280,yaxismax+6,legend=names(bloc),cex=0.7,text.col = specs,bty="n", xjust=0)#
#
nextplot = 2#
		while (nextplot < ncol(bloc)+1) { 						#
			lines (x[,1],bloc[,nextplot],cex=0.1, col = nextplot)#
			nextplot<- nextplot+1}#
#
plotnumber=plotnumber+1}#
}
plot.spec.curves(humms)
ls()
plot.spec.curves(hums,5)
hums = getspec('~/Desktop/Hummers-microspec', lim=c(280,950), negative='min')
dim(hms)
dim(hums)
plot.spec.curves(hums,5)
plotnumber <- 1
nplots <- ((ncol(hums)-1)/5)
nplots
hums = getspec('~/Desktop/Hummers-microspec', lim=c(280,950), negative='min')
dim(hums)
plotnumber <- 1
nplots <- ((ncol(hums)-1)/5)
nplots
par(mfrow=c(3,4),ask=TRUE)
i=1
bloc <-x[,(((plotnumber-1)*specreps)+2):((plotnumber*specreps)+1)]
x=hums
bloc <-x[,(((plotnumber-1)*specreps)+2):((plotnumber*specreps)+1)]
specreps=5
bloc <-x[,(((plotnumber-1)*specreps)+2):((plotnumber*specreps)+1)]
head(bloc)
head(hums[,1:5])
tail(hums)
tail(hums[,1:5])
hums = getspec('~/Desktop/Hummers-microspec', lim=c(281,949), negative='min')
bloc <-x[,(((plotnumber-1)*specreps)+2):((plotnumber*specreps)+1)]
head(bloc)
x=hums
bloc <-x[,(((plotnumber-1)*specreps)+2):((plotnumber*specreps)+1)]
head(bloc)
specs <- c(1:ncol(bloc))
yaxismin <-min(bloc)
yaxismax <-max(bloc)
plot(x[,1],bloc[,1],cex=0.1,ylim=c(yaxismin,yaxismax+5),col=1,xlab="Wavelength (nm)",ylab="% Reflectance")
ls()
rm(list=ls()[-2])
ls()
plot.spec.curves <- function (x, specreps) {#
#
plotnumber <- 1#
nplots <- ((ncol(hums)-1)/5)#
par(mfrow=c(3,4),ask=TRUE)#
#
for (i in 1:nplots){#
#
	bloc <-x[,(((plotnumber-1)*specreps)+2):((plotnumber*specreps)+1)]#
	specs <- c(1:ncol(bloc))#
	yaxismin <-min(bloc)#
	yaxismax <-max(bloc)#
	plot(x[,1],bloc[,1],cex=0.1,ylim=c(yaxismin,yaxismax+5),col=1,xlab="Wavelength (nm)",ylab="% Reflectance")#
	legend (280,yaxismax+6,legend=names(bloc),cex=0.7,text.col = specs,bty="n", xjust=0)#
#
nextplot = 2#
		while (nextplot < ncol(bloc)+1) { 						#
			lines (x[,1],bloc[,nextplot],cex=0.1, col = nextplot)#
			nextplot<- nextplot+1}#
#
plotnumber=plotnumber+1}#
}
plot.spec.curves(hums,5)
hums = apply(hums,2,function(x) x/max(x))
plot.spec.curves(hums,5)
head(hums[,1:5])
hums=x
hums = getspec('~/Desktop/Hummers-microspec', lim=c(281,949), negative='min')
hums[,-1] = apply(hums[,-1],2,function(x) x/max(x))
head(hums[,1:5])
plot.spec.curves(hums,5)
plot.spec.curves <- function (x, specreps) {#
#
plotnumber <- 1#
nplots <- ((ncol(hums)-1)/5)#
par(mfrow=c(3,4),ask=TRUE)#
#
for (i in 1:nplots){#
#
	bloc <-x[,(((plotnumber-1)*specreps)+2):((plotnumber*specreps)+1)]#
	specs <- c(1:ncol(bloc))#
	yaxismin <-min(bloc)#
	yaxismax <-max(bloc)#
	plot(x[,1],bloc[,1],cex=0.1,ylim=c(yaxismin,yaxismax+5),col=1,xlab="Wavelength (nm)",ylab="% Reflectance")#
	legend (280,900,legend=names(bloc),cex=0.7,text.col = specs,bty="n", xjust=0)#
#
nextplot = 2#
		while (nextplot < ncol(bloc)+1) { 						#
			lines (x[,1],bloc[,nextplot],cex=0.1, col = nextplot)#
			nextplot<- nextplot+1}#
#
plotnumber=plotnumber+1}#
}
plot.spec.curves(hums,5)
plot.spec.curves <- function (x, specreps) {#
#
plotnumber <- 1#
nplots <- ((ncol(hums)-1)/5)#
par(mfrow=c(3,4),ask=TRUE)#
#
for (i in 1:nplots){#
#
	bloc <-x[,(((plotnumber-1)*specreps)+2):((plotnumber*specreps)+1)]#
	specs <- c(1:ncol(bloc))#
	yaxismin <-min(bloc)#
	yaxismax <-max(bloc)#
	plot(x[,1],bloc[,1],cex=0.1,ylim=c(yaxismin,yaxismax),col=1,xlab="Wavelength (nm)",ylab="% Reflectance")#
	legend (900,1,legend=names(bloc),cex=0.7,text.col = specs,bty="n", xjust=0)#
#
nextplot = 2#
		while (nextplot < ncol(bloc)+1) { 						#
			lines (x[,1],bloc[,nextplot],cex=0.1, col = nextplot)#
			nextplot<- nextplot+1}#
#
plotnumber=plotnumber+1}#
}
plot.spec.curves(hums,5)
plot.spec.curves <- function (x, specreps) {#
#
plotnumber <- 1#
nplots <- ((ncol(hums)-1)/5)#
par(mfrow=c(3,4),ask=TRUE)#
#
for (i in 1:nplots){#
#
	bloc <-x[,(((plotnumber-1)*specreps)+2):((plotnumber*specreps)+1)]#
	specs <- c(1:ncol(bloc))#
	yaxismin <-min(bloc)#
	yaxismax <-max(bloc)#
	plot(x[,1],bloc[,1],cex=0.1,ylim=c(yaxismin,yaxismax),col=1,xlab="Wavelength (nm)",ylab="% Reflectance")#
	legend (850,1,legend=names(bloc),cex=0.7,text.col = specs,bty="n", xjust=0)#
#
nextplot = 2#
		while (nextplot < ncol(bloc)+1) { 						#
			lines (x[,1],bloc[,nextplot],cex=0.1, col = nextplot)#
			nextplot<- nextplot+1}#
#
plotnumber=plotnumber+1}#
}#
#
plot.spec.curves(hums[,1:6],5)
plot.spec.curves <- function (x, specreps) {#
#
plotnumber <- 1#
nplots <- ((ncol(hums)-1)/5)#
par(mfrow=c(3,4),ask=TRUE)#
#
for (i in 1:nplots){#
#
	bloc <-x[,(((plotnumber-1)*specreps)+2):((plotnumber*specreps)+1)]#
	specs <- c(1:ncol(bloc))#
	yaxismin <-min(bloc)#
	yaxismax <-max(bloc)#
	plot(x[,1],bloc[,1],cex=0.1,ylim=c(yaxismin,yaxismax),col=1,xlab="Wavelength (nm)",ylab="% Reflectance")#
	legend (850,1,legend=names(bloc),cex=0.7,text.col = specs,bty="n", xjust=0)#
#
nextplot = 2#
		while (nextplot < ncol(bloc)+1) { 						#
			lines (x[,1],bloc[,nextplot],cex=0.1, col = nextplot)#
			nextplot<- nextplot+1}#
#
plotnumber=plotnumber+1}#
}#
#
plot.spec.curves(hums,5)
plot.spec.curves <- function (x, specreps) {#
#
plotnumber <- 1#
nplots <- ((ncol(hums)-1)/5)#
par(mfrow=c(3,4),ask=TRUE)#
#
for (i in 1:nplots){#
#
	bloc <-x[,(((plotnumber-1)*specreps)+2):((plotnumber*specreps)+1)]#
	specs <- c(1:ncol(bloc))#
	yaxismin <-min(bloc)#
	yaxismax <-max(bloc)#
	plot(x[,1],bloc[,1],cex=0.1,ylim=c(yaxismin,yaxismax),col=1,xlab="Wavelength (nm)",ylab="% Reflectance")#
	legend (700,0.5,legend=names(bloc),cex=0.7,text.col = specs,bty="n", xjust=0)#
#
nextplot = 2#
		while (nextplot < ncol(bloc)+1) { 						#
			lines (x[,1],bloc[,nextplot],cex=0.1, col = nextplot)#
			nextplot<- nextplot+1}#
#
plotnumber=plotnumber+1}#
}#
#
plot.spec.curves(hums,5)
plot.spec.curves <- function (x, specreps) {#
#
plotnumber <- 1#
nplots <- ((ncol(hums)-1)/5)#
par(mfrow=c(3,4),ask=TRUE)#
#
for (i in 1:nplots){#
#
	bloc <-x[,(((plotnumber-1)*specreps)+2):((plotnumber*specreps)+1)]#
	specs <- c(1:ncol(bloc))#
	yaxismin <-min(bloc)#
	yaxismax <-max(bloc)#
	plot(x[,1],bloc[,1],cex=0.1,ylim=c(yaxismin,yaxismax),col=1,xlab="Wavelength (nm)",ylab="% Reflectance")#
	legend (700,0.5,legend=names(bloc),cex=0.7,text.col = specs,bty="n")#
#
nextplot = 2#
		while (nextplot < ncol(bloc)+1) { 						#
			lines (x[,1],bloc[,nextplot],cex=0.1, col = nextplot)#
			nextplot<- nextplot+1}#
#
plotnumber=plotnumber+1}#
}#
#
plot.spec.curves(hums,5)
plot.spec.curves <- function (x, specreps) {#
#
plotnumber <- 1#
nplots <- ((ncol(hums)-1)/5)#
par(mfrow=c(3,4),ask=TRUE)#
#
for (i in 1:nplots){#
#
	bloc <-x[,(((plotnumber-1)*specreps)+2):((plotnumber*specreps)+1)]#
	specs <- c(1:ncol(bloc))#
	yaxismin <-min(bloc)#
	yaxismax <-max(bloc)#
	plot(x[,1],bloc[,1],cex=0.1,ylim=c(yaxismin,yaxismax),col=1,xlab="Wavelength (nm)",ylab="% Reflectance",  main=names(bloc)[1])#
#
nextplot = 2#
		while (nextplot < ncol(bloc)+1) { 						#
			lines (x[,1],bloc[,nextplot],cex=0.1, col = nextplot)#
			nextplot<- nextplot+1}#
#
plotnumber=plotnumber+1}#
}#
#
plot.spec.curves(hums,5)
plot.spec.curves <- function (x, specreps) {#
#
plotnumber <- 1#
nplots <- ((ncol(hums)-1)/5)#
par(mfrow=c(3,4),ask=TRUE)#
#
for (i in 1:nplots){#
#
	bloc <-x[,(((plotnumber-1)*specreps)+2):((plotnumber*specreps)+1)]#
	specs <- c(1:ncol(bloc))#
	yaxismin <-min(bloc)#
	yaxismax <-max(bloc)#
	plot(x[,1],bloc[,1],cex=0.1,ylim=c(yaxismin,yaxismax),col=1,xlab="Wavelength (nm)",ylab="% Reflectance",  main=names(bloc)[1], type='l')#
	abline(v=300,lty=2)#
	abline(v=700,lty=2)#
nextplot = 2#
		while (nextplot < ncol(bloc)+1) { 						#
			lines (x[,1],bloc[,nextplot],cex=0.1, col = nextplot)#
			nextplot<- nextplot+1}#
#
plotnumber=plotnumber+1}#
}#
#
plot.spec.curves(hums,5)
plot.spec.curves(hums,5)
hums = getspec('~/Desktop/Hummers-microspec', lim=c(281,949), negative='min')
hums[,-1] = apply(hums[,-1],2,function(x) x/max(x))
plot.spec.curves(hums,5)
dim(hums)
155/5
?switch
ttdist2 <-function(vismodeldata, qcatch=c('Qi','qi','fi'), n1=1, n2=2, n3=2, n4=4, v=0.1, asdist=FALSE)#
{#
#
if(class(vismodeldata)=='vismodel'){#
	qcatch <- match.arg(qcatch)#
	dat <- data.frame(vismodeldata[qcatch])#
	names(dat) <- gsub(paste(qcatch,'.',sep=''),'',names(dat))#
	if(attr(vismodeldata,'relative'))#
	  warning('Quantum catch are relative, distances may not be meaningful')#
  }else{#
	qcatch <- match.arg(qcatch)#
  	dat <- vismodeldata#
  	}#
#
dat <- switch(qcatch,#
              Qi = log(dat),#
              qi = log(dat)#
              fi = dat)#
#
w1e=v/sqrt(n1)#
w2e=v/sqrt(n2)#
w3e=v/sqrt(n3)#
w4e=v/sqrt(n4)#
#
# ToDo: this can be later subset if the user doesn't want all comparisons#
pairsid <- t(combn(nrow(dat),2))#
#
dS <- apply(pairsid,1,function(x) #
  ttdistcalc(dat[x[1],], dat[x[2],], #
  w1=w1e, w2=w2e, w3=w3e, w4=w4e) )#
#
patch1 <- row.names(dat)[pairsid[,1]]#
patch2 <- row.names(dat)[pairsid[,2]]#
#
res <- data.frame(patch1,patch2,dS)#
#
nams2 <- with(res, unique(c(as.character(patch1), as.character(patch2))))#
#
if(asdist)#
  res <- with(res, structure(dS, #
                            Size = length(nams2),#
                            Labels = nams2,#
                            Diag = FALSE,#
                            Upper = FALSE,#
                            method = "user", #
                            class = "dist"))#
#
res#
}
ttdist2 <-function(vismodeldata, qcatch=c('Qi','qi','fi'), n1=1, n2=2, n3=2, n4=4, v=0.1, asdist=FALSE)#
{#
#
if(class(vismodeldata)=='vismodel'){#
	qcatch <- match.arg(qcatch)#
	dat <- data.frame(vismodeldata[qcatch])#
	names(dat) <- gsub(paste(qcatch,'.',sep=''),'',names(dat))#
	if(attr(vismodeldata,'relative'))#
	  warning('Quantum catch are relative, distances may not be meaningful')#
  }else{#
	qcatch <- match.arg(qcatch)#
  	dat <- vismodeldata#
  	}#
#
dat <- switch(qcatch,#
              Qi = log(dat),#
              qi = log(dat),#
              fi = dat)#
#
w1e=v/sqrt(n1)#
w2e=v/sqrt(n2)#
w3e=v/sqrt(n3)#
w4e=v/sqrt(n4)#
#
# ToDo: this can be later subset if the user doesn't want all comparisons#
pairsid <- t(combn(nrow(dat),2))#
#
dS <- apply(pairsid,1,function(x) #
  ttdistcalc(dat[x[1],], dat[x[2],], #
  w1=w1e, w2=w2e, w3=w3e, w4=w4e) )#
#
patch1 <- row.names(dat)[pairsid[,1]]#
patch2 <- row.names(dat)[pairsid[,2]]#
#
res <- data.frame(patch1,patch2,dS)#
#
nams2 <- with(res, unique(c(as.character(patch1), as.character(patch2))))#
#
if(asdist)#
  res <- with(res, structure(dS, #
                            Size = length(nams2),#
                            Labels = nams2,#
                            Diag = FALSE,#
                            Upper = FALSE,#
                            method = "user", #
                            class = "dist"))#
#
res#
}
require(pavo)
