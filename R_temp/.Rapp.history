R450 <- as.numeric(specdata[which(wl==450), ])#
R700 <- as.numeric(specdata[which(wl==700), ])#
Carotchroma <- (R450-R700)/R700
output.mat
output.mat[, 1] <- B1#
  output.mat[, 2] <- B2#
  output.mat[, 3] <- B3#
  output.mat[, 6] <- Bluechroma#
  output.mat[, 7] <- Greenchroma#
  output.mat[, 8] <- Yellowchroma#
  output.mat[, 9] <- Redchroma#
  output.mat[, 10] <- S2#
  output.mat[, 11] <- S3#
  output.mat[, 12] <- bmaxneg#
  output.mat[, 13] <- S5#
  output.mat[, 14] <- S6#
  output.mat[, 15] <- S7#
  output.mat[, 16] <- S8#
  output.mat[, 17] <- Carotchroma#
  output.mat[, 18] <- S10
output.mat
output.mat[, 19] <- H1#
  output.mat[, 20] <- lambdabmaxneg #
  output.mat[, 21] <- Rmid#
  output.mat[, 22] <- H4#
  output.mat[, 23] <- lambdabmax
output.mat
lambdamin
if(lambdamin <= 300){#
  lminuv <- 300#
  UVchromamat <- as.matrix(specdata[which(wl==lminuv):which(wl==400),])#
  UVchroma <- (apply(UVchromamat,2,sum))/B1 # S1 UV#
  output.mat [, 4] <- UVchroma#
  Vchromamat <- as.matrix(specdata[which(wl==lminuv):which(wl==415),])#
  Vchroma <- (apply(Vchromamat,2,sum))/B1 # S1 Violet#
  output.mat[, 5] <- Vchroma#
  }#
if(lambdamin > 300 & lambdamin < 400){#
  warning(paste('Minimum wavelength is', lambdamin,'UV-related variables may not be meaningful'), call.=FALSE)#
  lminuv <- lambdamin#
  UVchromamat <- as.matrix(specdata[which(wl==lminuv):which(wl==400),]) #
  UVchroma <- (apply(UVchromamat,2,sum))/B1 # S1 UV#
  output.mat [, 4] <- UVchroma#
#
  Vchromamat <- as.matrix(specdata[which(wl==lminuv):which(wl==415),])#
  Vchroma <- (apply(Vchromamat,2,sum))/B1 # S1 Violet#
  output.mat[, 5] <- Vchroma#
  }
color.var <- data.frame(output.mat, row.names=names(specdata))
color.var
names(color.var) <- c("B1", "B2", "B3", "S1.UV", "S1.violet", "S1.blue", "S1.green", #
                      "S1.yellow", "S1.red", "S2", "S3", "S4", "S5", "S6", "S7", "S8", #
                      "S9", "S10", "H1", "H2", "H3", "H4", "H5")
color.var
ls()
rm(list=ls())
data(sicalis)
test<- function (specdata, wlrange=c(300,700), #
                smooth=TRUE, span=0.2, plot=FALSE) {#
#
wl_index <- which(names(specdata)=='wl')#
wl <- specdata[,wl_index]#
lambdamin <- min(wl)#
specdata <- specdata[,-wl_index]#
#
output.mat <- matrix (nrow=(dim(specdata)[2]), ncol=23)#
#
# Three measures of brightness#
B1 <- sapply(specdata, sum)#
#
B2 <- sapply(specdata, mean)#
Redchromamat <- as.matrix(specdata[which(wl==605):which(wl==700),]) # red 605-700nm inclusive#
Redchroma <- as.vector(apply(Redchromamat,2,sum))/B1 # S1 red#
#
Yellowchromamat <- as.matrix(specdata[which(wl==550):which(wl==625),]) #yellow 550-625nm#
Yellowchroma <- as.vector(apply(Yellowchromamat,2,sum))/B1 # S1 yellow#
#
Greenchromamat <- as.matrix(specdata[which(wl==510):which(wl==605),]) # green 510-605nm inlusive#
Greenchroma <- (apply(Greenchromamat,2,sum))/B1 # S1 green#
#
Bluechromamat <- as.matrix(specdata[which(wl==400):which(wl==510),]) # blue 400-510nm inclusive#
  Bluechroma <- (apply(Bluechromamat,2,sum))/B1 # S1 blue#
segmts <- trunc(as.numeric(quantile(wlrange[1]:wlrange[2])))#
#
Q1 <- which(wl==segmts[1]):which(wl==segmts[2])#
Q2 <- which(wl==segmts[2]):which(wl==segmts[3])#
Q3 <- which(wl==segmts[3]):which(wl==segmts[4])#
Q4 <- which(wl==segmts[4]):which(wl==segmts[5])#
#
S5R <- apply(specdata[Q4, ],2,sum)#
S5Y <- apply(specdata[Q3, ],2,sum)#
S5G <- apply(specdata[Q2, ],2,sum)#
S5B <- apply(specdata[Q1, ],2,sum)#
S5 <- sqrt((S5R-S5G)^2+(S5Y-S5B)^2)#
#
H4 <- atan(((S5Y-S5B)/B1)/((S5R-S5G)/B1))#
#
#carotchroma#
R450 <- as.numeric(specdata[which(wl==450), ])#
R700 <- as.numeric(specdata[which(wl==700), ])#
Carotchroma <- (R450-R700)/R700#
#
# S7#
sum_min_mid <- apply(specdata, 2, function(x) #
                     sum(x[which.min(x):round((which.max(x) + which.min(x))/2)]))#
sum_mid_max <- apply(specdata, 2, function(x) #
                     sum(x[round((which.max(x) + which.min(x))/2):which.max(x)]))#
#
S7 <- (sum_min_mid - sum_mid_max)/(B1)#
# S3#
#
plus50 <- apply(specdata,2,function(x) min(c(which.max(x)+50,which.max(wl))))#
minus50 <- apply(specdata,2,function(x) max(c(which.max(x)-50,which.min(wl))))#
pmindex <- 1:dim(specdata)[2]#
#
S3 <- sapply(pmindex, function(x) sum(specdata[minus50[x]:plus50[x],x]))/B1#
#Metrics that involve bmax with or without smoothing#
data <- specdata#
#
if(smooth){#
  smoothspecs <- data.frame(apply(specdata,2, function(x) loess.smooth(wl, x, #
                                    span=span, degree=1, evaluation=length(wl))$y) )#
  }else{#
    smoothspecs <- specdata#
    warning('Spectral curves not smoothened - #
    variables that rely on derivatives (S4, S10, H2 and H5) are not meaningful', call.=FALSE)#
    }#
#
# PPB B3, S2, S6 are now smoothed #
# RM H1 as well#
B3 <- sapply(smoothspecs, max)#
#
# Spectral saturation#
Rmin <- sapply(smoothspecs, min)#
S2 <- B3/Rmin #S2#
#
S8  <- (B3-Rmin)/B2 # S8#
#
S6 <- B3-Rmin # S6#
#
# lambda Rmax hue#
H1 <- wl[max.col(t(smoothspecs), ties.method='first')]#
#
# H3 #
lambdaRmin <- wl[apply(specdata, 2, which.min)]  # H3#
  Rmid <- round((H1+lambdaRmin)/2)#
diffsmooth <- apply(smoothspecs,2,diff)#
#
lambdabmaxneg <- wl[apply(diffsmooth,2,which.min)] #H2#
bmaxneg <- abs(apply(diffsmooth,2,min)) #S4#
S10 <- S8/bmaxneg #S10#
lambdabmax <- wl[apply(diffsmooth,2,which.max)] #H5#
#
  output.mat[, 1] <- B1#
  output.mat[, 2] <- B2#
  output.mat[, 3] <- B3#
  output.mat[, 6] <- Bluechroma#
  output.mat[, 7] <- Greenchroma#
  output.mat[, 8] <- Yellowchroma#
  output.mat[, 9] <- Redchroma#
  output.mat[, 10] <- S2#
  output.mat[, 11] <- S3#
  output.mat[, 12] <- bmaxneg#
  output.mat[, 13] <- S5#
  output.mat[, 14] <- S6#
  output.mat[, 15] <- S7#
  output.mat[, 16] <- S8#
  output.mat[, 17] <- Carotchroma#
  output.mat[, 18] <- S10 #
  output.mat[, 19] <- H1#
  output.mat[, 20] <- lambdabmaxneg #
  output.mat[, 21] <- Rmid#
  output.mat[, 22] <- H4#
  output.mat[, 23] <- lambdabmax#
#
# PPB added S1v and S1Y#
#
if(lambdamin <= 300){#
  lminuv <- 300#
  UVchromamat <- as.matrix(specdata[which(wl==lminuv):which(wl==400),])#
  UVchroma <- (apply(UVchromamat,2,sum))/B1 # S1 UV#
  output.mat [, 4] <- UVchroma#
  Vchromamat <- as.matrix(specdata[which(wl==lminuv):which(wl==415),])#
  Vchroma <- (apply(Vchromamat,2,sum))/B1 # S1 Violet#
  output.mat[, 5] <- Vchroma#
  }#
if(lambdamin > 300 & lambdamin < 400){#
  warning(paste('Minimum wavelength is', lambdamin,'UV-related variables may not be meaningful'), call.=FALSE)#
  lminuv <- lambdamin#
  UVchromamat <- as.matrix(specdata[which(wl==lminuv):which(wl==400),]) #
  UVchroma <- (apply(UVchromamat,2,sum))/B1 # S1 UV#
  output.mat [, 4] <- UVchroma#
#
  Vchromamat <- as.matrix(specdata[which(wl==lminuv):which(wl==415),])#
  Vchroma <- (apply(Vchromamat,2,sum))/B1 # S1 Violet#
  output.mat[, 5] <- Vchroma#
  }#
#
color.var <- data.frame(output.mat, row.names=names(specdata))#
#
names(color.var) <- c("B1", "B2", "B3", "S1.UV", "S1.violet", "S1.blue", "S1.green", #
                      "S1.yellow", "S1.red", "S2", "S3", "S4", "S5", "S6", "S7", "S8", #
                      "S9", "S10", "H1", "H2", "H3", "H4", "H5")#
#
if(plot)#
  explorespec(cbind(data.frame(wl,smoothspecs)))#
#
color.var#
}
test(sicalis)
test(sicalis, smooth=F)
test(sicalis, smooth=T, plot=T)
segclass(sicalis)
plotsmooth(sicalis)
install_github('pavo','rmaia')
sensmodel(c(400,600))
test <- function(peaksense, range = c(300,700), lambdacut = NULL, Bmid = NULL, #
		             oiltype = NULL, beta = TRUE) {#
#
if (!is.null(lambdacut)){#
 if (is.null(Bmid) & is.null(oiltype)) stop ("Bmid or oiltype must be included when including a lambdacut vector", call.=FALSE)#
 if (length(lambdacut) != length(peaksense)) stop ("lambdacut must be same length as peaksense", call.=FALSE)#
}  #
#
sensecurves <- matrix(ncol = length(peaksense)+1,nrow = (range[2]-range[1]+1))#
sensecurves[,1] <- c(range[1]:range[2])#
#
#Sensitivities w/o oil droplets#
for (i in 1: length(peaksense)){#
#
peak <- 1/(exp(69.7*(.8795+.0459*exp(-(peaksense[i]-range[1])^2/11940)-(peaksense[i]/(range[1]:range[2]))))#
  +exp(28*(.922-peaksense[i]/(range[1]:range[2])))+exp(-14.9*(1.104-(peaksense[i]/(range[1]:range[2]))))+.674)#
#
betaband <- 0.26*exp(-(((range[1]:range[2])#
  -(189+0.315*peaksense[i]))/(-40.5+0.195*peaksense[i]))^2)#
#
if (beta==TRUE)peak <- peak + betaband#
peak <- peak/max(peak)#
#
if (!is.null(lambdacut)& !is.null(Bmid)){#
 if (length(lambdacut) != length(Bmid)) stop ("lambdacut and Bmid must be of same length")#
#
T.oil <- exp(-exp(-2.89*Bmid[i]*(range[1]:range[2]-lambdacut[i])+1.08))#
peak <- peak*T.oil#
}#
#
if (!is.null(lambdacut) & !is.null(oiltype)){#
#
  if (length(lambdacut) != length(oiltype)) stop ("lambdacut and oiltype must be of same length")#
#
  if (oiltype[i] == "C") oil <- c(0.99, 24.38)#
  if (oiltype[i] == "Y") oil <- c(0.9, 70.03)#
  if (oiltype[i] == "R") oil <- c(0.99, 28.65)#
  if (oiltype[i] == "P") oil <- c(0.96, 33.57)#
#
# Oil droplet transmission from Hart and Vorobyev (2005)#
T.oil <- exp(-exp(-2.89*(.5/((oil[1]*lambdacut[i]+oil[2])-lambdacut[i]))*(range[1]:range[2]-lambdacut[i])+1.08))#
#
peak <- peak*T.oil#
}#
#
sensecurves[, (i+1)] <- peak#
  }#
#
sensecurves <- data.frame(sensecurves)#
names(sensecurves) <- c('wl',paste('lmax',peaksense,sep=''))#
#
sensecurves#
}
head(test(c(400,600)))
print(paste('smoothing spectra with a span of',span))
span =2
print(paste('smoothing spectra with a span of',span))
procspec <- function(specs, opt = c('none', 'smooth', 'maximum', 'minimum', 'stretch', #
										 'bin', 'fix', 'sum', 'center'), #
										 # method = c('loess', 'spline'), spar = .65, #
										 span = .15, bins = 20) {#
#
opt <- match.arg(opt, several.ok = TRUE)  	# 'fix' = how to handle negative values#
# method <- match.arg(method)#
#
if (any(opt=='none')) {#
  print('No relevant processing option entered. Returning raw values') #
  specs#
  }#
wl_index <- which(names(specs)=='wl')#
if (length(wl_index > 0)){#
  wl <- specs[, wl_index]#
  specs <- specs[, -wl_index]#
    } else {#
    specs <- specs#
    }#
#
if (any(opt=='smooth')&method=='loess'){#
  specs <- sapply(names(specs), function(z){loess.smooth(x = wl, y = specs[, z], #
           span = span, degree = 2, family = "gaussian", #
           evaluation = length(wl))$y})#
  print(paste('smoothing spectra with a span of',span))#
  }#
#
# if (any(opt=='smooth')&method=='spline')#
  # specs <- sapply(names(specs), function(z){smooth.spline(x = wl, y = specs[, z], #
           # spar = spar)$y})#
#
# if (any(opt=='smooth')&method=='loess')#
  # specs <- sapply(names(specs), function(z){loess.smooth(x = wl, y = specs[, z], #
           # span = span, degree = 2, family = "gaussian", #
           # evaluation = length(wl))$y})#
#
if (any(opt=='minimum')){#
  specs <- sapply(1:ncol(specs), function(z)specs[, z] - min(specs[, z]))#
  print('Scaling spectra to a minimum value of zero')#
  }#
#
if (any(opt=='maximum')){#
  specs <- sapply(1:ncol(specs), function(z)specs[, z] / max(specs[, z]))#
  print('Scaling spectra to a maximum value of 1')#
#
if (any(opt=='sum')){#
  specs <- sapply(1:ncol(specs), function(z)specs[, z] / sum(specs[, z]))#
  print('Scaling spectra to a total area of 1')#
  }#
#
if (any(opt=='center')){#
  specs <- sapply(1:ncol(specs), function(z)specs[, z] - mean(specs[, z]))#
  print('Centering spectra to a mean of zero')#
  }#
#
#	if (any(opt=='fix'))#
#		specs <- ...#
		# option 1 = set all negatives to zero#
		# option 2 = add absolute val of most neg value to all spectra#
		# option 3 = set negatives to NAs, then smooth?#
#
	# Calculate medians according to # of bins specified for use in PCA#
	# Method follows Cuthill et al. (1999)#
if (any(opt=='bin')) {#
  bw <- floor(length(wl)/bins)#
  wl_bin <- seq(head(wl,1), tail(wl,1), by=bw)#
  wl_ind <- match(wl_bin, wl)#
  specs <- sapply(1:(length(wl_ind)-1), function(z) #
                  apply(specs[wl_ind[z]:(wl_ind[z]+bw), ], 2, median))#
#
  specs <- as.data.frame(cbind(wl_bin[-length(wl_bin)], t(specs)))#
  }else {#
    specs <- as.data.frame(cbind(wl, specs))#
    }#
class(specs) <- c('rspec', 'data.frame')#
specs#
}
procspec <- function(specs, opt = c('none', 'smooth', 'maximum', 'minimum', 'stretch', #
										 'bin', 'fix', 'sum', 'center'), #
										 # method = c('loess', 'spline'), spar = .65, #
										 span = .15, bins = 20) {#
#
opt <- match.arg(opt, several.ok = TRUE)  	# 'fix' = how to handle negative values#
# method <- match.arg(method)#
#
if (any(opt=='none')) {#
  print('No relevant processing option entered. Returning raw values') #
  specs#
  }#
wl_index <- which(names(specs)=='wl')#
if (length(wl_index > 0)){#
  wl <- specs[, wl_index]#
  specs <- specs[, -wl_index]#
    } else {#
    specs <- specs#
    }#
#
if (any(opt=='smooth')&method=='loess'){#
  specs <- sapply(names(specs), function(z){loess.smooth(x = wl, y = specs[, z], #
           span = span, degree = 2, family = "gaussian", #
           evaluation = length(wl))$y})#
  print(paste('smoothing spectra with a span of',span))#
  }#
#
# if (any(opt=='smooth')&method=='spline')#
  # specs <- sapply(names(specs), function(z){smooth.spline(x = wl, y = specs[, z], #
           # spar = spar)$y})#
#
# if (any(opt=='smooth')&method=='loess')#
  # specs <- sapply(names(specs), function(z){loess.smooth(x = wl, y = specs[, z], #
           # span = span, degree = 2, family = "gaussian", #
           # evaluation = length(wl))$y})#
#
if (any(opt=='minimum')){#
  specs <- sapply(1:ncol(specs), function(z)specs[, z] - min(specs[, z]))#
  print('Scaling spectra to a minimum value of zero')#
  }#
#
if (any(opt=='maximum')){#
  specs <- sapply(1:ncol(specs), function(z)specs[, z] / max(specs[, z]))#
  print('Scaling spectra to a maximum value of 1')#
  }#
#
if (any(opt=='sum')){#
  specs <- sapply(1:ncol(specs), function(z)specs[, z] / sum(specs[, z]))#
  print('Scaling spectra to a total area of 1')#
  }#
#
if (any(opt=='center')){#
  specs <- sapply(1:ncol(specs), function(z)specs[, z] - mean(specs[, z]))#
  print('Centering spectra to a mean of zero')#
  }#
#
#	if (any(opt=='fix'))#
#		specs <- ...#
		# option 1 = set all negatives to zero#
		# option 2 = add absolute val of most neg value to all spectra#
		# option 3 = set negatives to NAs, then smooth?#
#
	# Calculate medians according to # of bins specified for use in PCA#
	# Method follows Cuthill et al. (1999)#
if (any(opt=='bin')) {#
  bw <- floor(length(wl)/bins)#
  wl_bin <- seq(head(wl,1), tail(wl,1), by=bw)#
  wl_ind <- match(wl_bin, wl)#
  specs <- sapply(1:(length(wl_ind)-1), function(z) #
                  apply(specs[wl_ind[z]:(wl_ind[z]+bw), ], 2, median))#
#
  specs <- as.data.frame(cbind(wl_bin[-length(wl_bin)], t(specs)))#
  }else {#
    specs <- as.data.frame(cbind(wl, specs))#
    }#
class(specs) <- c('rspec', 'data.frame')#
specs#
}
ls()
rm(span)
rm(test)
procspec(sicalis, opt='smooth')
input an rspec object or data frame w/spectra in columns and wavelengths in rows#
# options = min, max, stretch, sum, bin, center (subtract avg. from all specs)#
#
# TODO#
# 1. add way to handle negatives#
#
procspec <- function(specs, opt = c('none', 'smooth', 'maximum', 'minimum', 'stretch', #
										 'bin', 'fix', 'sum', 'center'), #
										 # method = c('loess', 'spline'), spar = .65, #
										 span = .15, bins = 20) {#
#
opt <- match.arg(opt, several.ok = TRUE)  	# 'fix' = how to handle negative values#
# method <- match.arg(method)#
#
if (any(opt=='none')) {#
  print('No relevant processing option entered. Returning raw values') #
  specs#
  }#
wl_index <- which(names(specs)=='wl')#
if (length(wl_index > 0)){#
  wl <- specs[, wl_index]#
  specs <- specs[, -wl_index]#
    } else {#
    specs <- specs#
    }#
#
if (any(opt=='smooth')){#
  specs <- sapply(names(specs), function(z){loess.smooth(x = wl, y = specs[, z], #
           span = span, degree = 2, family = "gaussian", #
           evaluation = length(wl))$y})#
  print(paste('smoothing spectra with a span of',span))#
  }#
#
# if (any(opt=='smooth')&method=='spline')#
  # specs <- sapply(names(specs), function(z){smooth.spline(x = wl, y = specs[, z], #
           # spar = spar)$y})#
#
# if (any(opt=='smooth')&method=='loess')#
  # specs <- sapply(names(specs), function(z){loess.smooth(x = wl, y = specs[, z], #
           # span = span, degree = 2, family = "gaussian", #
           # evaluation = length(wl))$y})#
#
if (any(opt=='minimum')){#
  specs <- sapply(1:ncol(specs), function(z)specs[, z] - min(specs[, z]))#
  print('Scaling spectra to a minimum value of zero')#
  }#
#
if (any(opt=='maximum')){#
  specs <- sapply(1:ncol(specs), function(z)specs[, z] / max(specs[, z]))#
  print('Scaling spectra to a maximum value of 1')#
  }#
#
if (any(opt=='sum')){#
  specs <- sapply(1:ncol(specs), function(z)specs[, z] / sum(specs[, z]))#
  print('Scaling spectra to a total area of 1')#
  }#
#
if (any(opt=='center')){#
  specs <- sapply(1:ncol(specs), function(z)specs[, z] - mean(specs[, z]))#
  print('Centering spectra to a mean of zero')#
  }#
#
#	if (any(opt=='fix'))#
#		specs <- ...#
		# option 1 = set all negatives to zero#
		# option 2 = add absolute val of most neg value to all spectra#
		# option 3 = set negatives to NAs, then smooth?#
#
	# Calculate medians according to # of bins specified for use in PCA#
	# Method follows Cuthill et al. (1999)#
if (any(opt=='bin')) {#
  bw <- floor(length(wl)/bins)#
  wl_bin <- seq(head(wl,1), tail(wl,1), by=bw)#
  wl_ind <- match(wl_bin, wl)#
  specs <- sapply(1:(length(wl_ind)-1), function(z) #
                  apply(specs[wl_ind[z]:(wl_ind[z]+bw), ], 2, median))#
#
  specs <- as.data.frame(cbind(wl_bin[-length(wl_bin)], t(specs)))#
  }else {#
    specs <- as.data.frame(cbind(wl, specs))#
    }#
class(specs) <- c('rspec', 'data.frame')#
specs#
}#
#
# testing zone#
#tmp <- procspec(rspecs)#
#tmp <- procspec(rspecs, f="stretch")#
#plot(tmp, p=8:15, type='h')
procspec(sicalis, opt='smooth')
a=procspec(sicalis, opt='smooth')
a
head(a)
a = c(print('No relevant processing option entered. Returning raw values') ,print('No relevant processing option entered. Returning raw values') )
a
input an rspec object or data frame w/spectra in columns and wavelengths in rows#
# options = min, max, stretch, sum, bin, center (subtract avg. from all specs)#
#
# TODO#
# 1. add way to handle negatives#
#
procspec <- function(specs, opt = c('none', 'smooth', 'maximum', 'minimum', 'stretch', #
										 'bin', 'fix', 'sum', 'center'), #
										 # method = c('loess', 'spline'), spar = .65, #
										 span = .15, bins = 20) {#
#
opt <- match.arg(opt, several.ok = TRUE)  	# 'fix' = how to handle negative values#
# method <- match.arg(method)#
#
applied <- 'processing options applied:'#
#
if (any(opt=='none')) {#
  print('No relevant processing option entered. Returning raw values') #
  specs#
  }#
wl_index <- which(names(specs)=='wl')#
if (length(wl_index > 0)){#
  wl <- specs[, wl_index]#
  specs <- specs[, -wl_index]#
    } else {#
    specs <- specs#
    }#
#
if (any(opt=='smooth')){#
  specs <- sapply(names(specs), function(z){loess.smooth(x = wl, y = specs[, z], #
           span = span, degree = 2, family = "gaussian", #
           evaluation = length(wl))$y})#
  applied <- c(applied, paste('smoothing spectra with a span of',span))#
  }#
#
# if (any(opt=='smooth')&method=='spline')#
  # specs <- sapply(names(specs), function(z){smooth.spline(x = wl, y = specs[, z], #
           # spar = spar)$y})#
#
# if (any(opt=='smooth')&method=='loess')#
  # specs <- sapply(names(specs), function(z){loess.smooth(x = wl, y = specs[, z], #
           # span = span, degree = 2, family = "gaussian", #
           # evaluation = length(wl))$y})#
#
if (any(opt=='minimum')){#
  specs <- sapply(1:ncol(specs), function(z)specs[, z] - min(specs[, z]))#
   applied <- c(applied, 'Scaling spectra to a minimum value of zero')#
  }#
#
if (any(opt=='maximum')){#
  specs <- sapply(1:ncol(specs), function(z)specs[, z] / max(specs[, z]))#
   applied <- c(applied, 'Scaling spectra to a maximum value of 1')#
  }#
#
if (any(opt=='sum')){#
  specs <- sapply(1:ncol(specs), function(z)specs[, z] / sum(specs[, z]))#
   applied <- c(applied, 'Scaling spectra to a total area of 1')#
  }#
#
if (any(opt=='center')){#
  specs <- sapply(1:ncol(specs), function(z)specs[, z] - mean(specs[, z]))#
   applied <- c(applied, 'Centering spectra to a mean of zero')#
  }#
#
#	if (any(opt=='fix'))#
#		specs <- ...#
		# option 1 = set all negatives to zero#
		# option 2 = add absolute val of most neg value to all spectra#
		# option 3 = set negatives to NAs, then smooth?#
#
	# Calculate medians according to # of bins specified for use in PCA#
	# Method follows Cuthill et al. (1999)#
if (any(opt=='bin')) {#
  bw <- floor(length(wl)/bins)#
  wl_bin <- seq(head(wl,1), tail(wl,1), by=bw)#
  wl_ind <- match(wl_bin, wl)#
  specs <- sapply(1:(length(wl_ind)-1), function(z) #
                  apply(specs[wl_ind[z]:(wl_ind[z]+bw), ], 2, median))#
#
  specs <- as.data.frame(cbind(wl_bin[-length(wl_bin)], t(specs)))#
   applied <- c(applied, paste('binned spectra to ',bw,'-nm intervals',sep=''))#
  }else {#
    specs <- as.data.frame(cbind(wl, specs))#
    }#
class(specs) <- c('rspec', 'data.frame')#
return(specs)#
print(applied)#
}#
#
# testing zone#
#tmp <- procspec(rspecs)#
#tmp <- procspec(rspecs, f="stretch")#
#plot(tmp, p=8:15, type='h')
procspec(sicalis, opt='smooth')
head(procspec(sicalis, opt='smooth'))
input an rspec object or data frame w/spectra in columns and wavelengths in rows#
# options = min, max, stretch, sum, bin, center (subtract avg. from all specs)#
#
# TODO#
# 1. add way to handle negatives#
#
procspec <- function(specs, opt = c('none', 'smooth', 'maximum', 'minimum', 'stretch', #
										 'bin', 'fix', 'sum', 'center'), #
										 # method = c('loess', 'spline'), spar = .65, #
										 span = .15, bins = 20) {#
#
opt <- match.arg(opt, several.ok = TRUE)  	# 'fix' = how to handle negative values#
# method <- match.arg(method)#
#
applied <- 'processing options applied:'#
#
if (any(opt=='none')) {#
  print('No relevant processing option entered. Returning raw values') #
  specs#
  }#
wl_index <- which(names(specs)=='wl')#
if (length(wl_index > 0)){#
  wl <- specs[, wl_index]#
  specs <- specs[, -wl_index]#
    } else {#
    specs <- specs#
    }#
#
if (any(opt=='smooth')){#
  specs <- sapply(names(specs), function(z){loess.smooth(x = wl, y = specs[, z], #
           span = span, degree = 2, family = "gaussian", #
           evaluation = length(wl))$y})#
  applied <- c(applied, paste('smoothing spectra with a span of',span))#
  }#
#
# if (any(opt=='smooth')&method=='spline')#
  # specs <- sapply(names(specs), function(z){smooth.spline(x = wl, y = specs[, z], #
           # spar = spar)$y})#
#
# if (any(opt=='smooth')&method=='loess')#
  # specs <- sapply(names(specs), function(z){loess.smooth(x = wl, y = specs[, z], #
           # span = span, degree = 2, family = "gaussian", #
           # evaluation = length(wl))$y})#
#
if (any(opt=='minimum')){#
  specs <- sapply(1:ncol(specs), function(z)specs[, z] - min(specs[, z]))#
   applied <- c(applied, 'Scaling spectra to a minimum value of zero')#
  }#
#
if (any(opt=='maximum')){#
  specs <- sapply(1:ncol(specs), function(z)specs[, z] / max(specs[, z]))#
   applied <- c(applied, 'Scaling spectra to a maximum value of 1')#
  }#
#
if (any(opt=='sum')){#
  specs <- sapply(1:ncol(specs), function(z)specs[, z] / sum(specs[, z]))#
   applied <- c(applied, 'Scaling spectra to a total area of 1')#
  }#
#
if (any(opt=='center')){#
  specs <- sapply(1:ncol(specs), function(z)specs[, z] - mean(specs[, z]))#
   applied <- c(applied, 'Centering spectra to a mean of zero')#
  }#
#
#	if (any(opt=='fix'))#
#		specs <- ...#
		# option 1 = set all negatives to zero#
		# option 2 = add absolute val of most neg value to all spectra#
		# option 3 = set negatives to NAs, then smooth?#
#
	# Calculate medians according to # of bins specified for use in PCA#
	# Method follows Cuthill et al. (1999)#
if (any(opt=='bin')) {#
  bw <- floor(length(wl)/bins)#
  wl_bin <- seq(head(wl,1), tail(wl,1), by=bw)#
  wl_ind <- match(wl_bin, wl)#
  specs <- sapply(1:(length(wl_ind)-1), function(z) #
                  apply(specs[wl_ind[z]:(wl_ind[z]+bw), ], 2, median))#
#
  specs <- as.data.frame(cbind(wl_bin[-length(wl_bin)], t(specs)))#
   applied <- c(applied, paste('binned spectra to ',bw,'-nm intervals',sep=''))#
  }else {#
    specs <- as.data.frame(cbind(wl, specs))#
    }#
class(specs) <- c('rspec', 'data.frame')#
return(specs)#
cat(applied)#
}#
#
# testing zone#
#tmp <- procspec(rspecs)#
#tmp <- procspec(rspecs, f="stretch")#
#plot(tmp, p=8:15, type='h')
head(procspec(sicalis, opt='smooth'))
procspec(sicalis, opt='smooth')
input an rspec object or data frame w/spectra in columns and wavelengths in rows#
# options = min, max, stretch, sum, bin, center (subtract avg. from all specs)#
#
# TODO#
# 1. add way to handle negatives#
#
procspec <- function(specs, opt = c('none', 'smooth', 'maximum', 'minimum', 'stretch', #
										 'bin', 'fix', 'sum', 'center'), #
										 # method = c('loess', 'spline'), spar = .65, #
										 span = .15, bins = 20) {#
#
opt <- match.arg(opt, several.ok = TRUE)  	# 'fix' = how to handle negative values#
# method <- match.arg(method)#
#
applied <- 'processing options applied:'#
#
if (any(opt=='none')) {#
  print('No relevant processing option entered. Returning raw values') #
  specs#
  }#
wl_index <- which(names(specs)=='wl')#
if (length(wl_index > 0)){#
  wl <- specs[, wl_index]#
  specs <- specs[, -wl_index]#
    } else {#
    specs <- specs#
    }#
#
if (any(opt=='smooth')){#
  specs <- sapply(names(specs), function(z){loess.smooth(x = wl, y = specs[, z], #
           span = span, degree = 2, family = "gaussian", #
           evaluation = length(wl))$y})#
  applied <- c(applied, paste('smoothing spectra with a span of',span))#
  }#
#
# if (any(opt=='smooth')&method=='spline')#
  # specs <- sapply(names(specs), function(z){smooth.spline(x = wl, y = specs[, z], #
           # spar = spar)$y})#
#
# if (any(opt=='smooth')&method=='loess')#
  # specs <- sapply(names(specs), function(z){loess.smooth(x = wl, y = specs[, z], #
           # span = span, degree = 2, family = "gaussian", #
           # evaluation = length(wl))$y})#
#
if (any(opt=='minimum')){#
  specs <- sapply(1:ncol(specs), function(z)specs[, z] - min(specs[, z]))#
   applied <- c(applied, 'Scaling spectra to a minimum value of zero')#
  }#
#
if (any(opt=='maximum')){#
  specs <- sapply(1:ncol(specs), function(z)specs[, z] / max(specs[, z]))#
   applied <- c(applied, 'Scaling spectra to a maximum value of 1')#
  }#
#
if (any(opt=='sum')){#
  specs <- sapply(1:ncol(specs), function(z)specs[, z] / sum(specs[, z]))#
   applied <- c(applied, 'Scaling spectra to a total area of 1')#
  }#
#
if (any(opt=='center')){#
  specs <- sapply(1:ncol(specs), function(z)specs[, z] - mean(specs[, z]))#
   applied <- c(applied, 'Centering spectra to a mean of zero')#
  }#
#
#	if (any(opt=='fix'))#
#		specs <- ...#
		# option 1 = set all negatives to zero#
		# option 2 = add absolute val of most neg value to all spectra#
		# option 3 = set negatives to NAs, then smooth?#
#
	# Calculate medians according to # of bins specified for use in PCA#
	# Method follows Cuthill et al. (1999)#
if (any(opt=='bin')) {#
  bw <- floor(length(wl)/bins)#
  wl_bin <- seq(head(wl,1), tail(wl,1), by=bw)#
  wl_ind <- match(wl_bin, wl)#
  specs <- sapply(1:(length(wl_ind)-1), function(z) #
                  apply(specs[wl_ind[z]:(wl_ind[z]+bw), ], 2, median))#
#
  specs <- as.data.frame(cbind(wl_bin[-length(wl_bin)], t(specs)))#
   applied <- c(applied, paste('binned spectra to ',bw,'-nm intervals',sep=''))#
  }else {#
    specs <- as.data.frame(cbind(wl, specs))#
    }#
class(specs) <- c('rspec', 'data.frame')#
specs#
print(applied)#
}#
#
# testing zone#
#tmp <- procspec(rspecs)#
#tmp <- procspec(rspecs, f="stretch")#
#plot(tmp, p=8:15, type='h')
procspec(sicalis, opt='smooth')
input an rspec object or data frame w/spectra in columns and wavelengths in rows#
# options = min, max, stretch, sum, bin, center (subtract avg. from all specs)#
#
# TODO#
# 1. add way to handle negatives#
#
procspec <- function(specs, opt = c('none', 'smooth', 'maximum', 'minimum', 'stretch', #
										 'bin', 'fix', 'sum', 'center'), #
										 # method = c('loess', 'spline'), spar = .65, #
										 span = .15, bins = 20) {#
#
opt <- match.arg(opt, several.ok = TRUE)  	# 'fix' = how to handle negative values#
# method <- match.arg(method)#
#
applied <- 'processing options applied:'#
#
if (any(opt=='none')) {#
  print('No relevant processing option entered. Returning raw values') #
  specs#
  }#
wl_index <- which(names(specs)=='wl')#
if (length(wl_index > 0)){#
  wl <- specs[, wl_index]#
  specs <- specs[, -wl_index]#
    } else {#
    specs <- specs#
    }#
#
if (any(opt=='smooth')){#
  specs <- sapply(names(specs), function(z){loess.smooth(x = wl, y = specs[, z], #
           span = span, degree = 2, family = "gaussian", #
           evaluation = length(wl))$y})#
  applied <- c(applied, paste('smoothing spectra with a span of',span))#
  }#
#
# if (any(opt=='smooth')&method=='spline')#
  # specs <- sapply(names(specs), function(z){smooth.spline(x = wl, y = specs[, z], #
           # spar = spar)$y})#
#
# if (any(opt=='smooth')&method=='loess')#
  # specs <- sapply(names(specs), function(z){loess.smooth(x = wl, y = specs[, z], #
           # span = span, degree = 2, family = "gaussian", #
           # evaluation = length(wl))$y})#
#
if (any(opt=='minimum')){#
  specs <- sapply(1:ncol(specs), function(z)specs[, z] - min(specs[, z]))#
   applied <- c(applied, 'Scaling spectra to a minimum value of zero')#
  }#
#
if (any(opt=='maximum')){#
  specs <- sapply(1:ncol(specs), function(z)specs[, z] / max(specs[, z]))#
   applied <- c(applied, 'Scaling spectra to a maximum value of 1')#
  }#
#
if (any(opt=='sum')){#
  specs <- sapply(1:ncol(specs), function(z)specs[, z] / sum(specs[, z]))#
   applied <- c(applied, 'Scaling spectra to a total area of 1')#
  }#
#
if (any(opt=='center')){#
  specs <- sapply(1:ncol(specs), function(z)specs[, z] - mean(specs[, z]))#
   applied <- c(applied, 'Centering spectra to a mean of zero')#
  }#
#
#	if (any(opt=='fix'))#
#		specs <- ...#
		# option 1 = set all negatives to zero#
		# option 2 = add absolute val of most neg value to all spectra#
		# option 3 = set negatives to NAs, then smooth?#
#
	# Calculate medians according to # of bins specified for use in PCA#
	# Method follows Cuthill et al. (1999)#
if (any(opt=='bin')) {#
  bw <- floor(length(wl)/bins)#
  wl_bin <- seq(head(wl,1), tail(wl,1), by=bw)#
  wl_ind <- match(wl_bin, wl)#
  specs <- sapply(1:(length(wl_ind)-1), function(z) #
                  apply(specs[wl_ind[z]:(wl_ind[z]+bw), ], 2, median))#
#
  specs <- as.data.frame(cbind(wl_bin[-length(wl_bin)], t(specs)))#
   applied <- c(applied, paste('binned spectra to ',bw,'-nm intervals',sep=''))#
  }else {#
    specs <- as.data.frame(cbind(wl, specs))#
    }#
class(specs) <- c('rspec', 'data.frame')#
specs#
cat(applied)#
}#
#
# testing zone#
#tmp <- procspec(rspecs)#
#tmp <- procspec(rspecs, f="stretch")#
#plot(tmp, p=8:15, type='h')
procspec(sicalis, opt='smooth')
input an rspec object or data frame w/spectra in columns and wavelengths in rows#
# options = min, max, stretch, sum, bin, center (subtract avg. from all specs)#
#
# TODO#
# 1. add way to handle negatives#
#
procspec <- function(specs, opt = c('none', 'smooth', 'maximum', 'minimum', 'stretch', #
										 'bin', 'fix', 'sum', 'center'), #
										 # method = c('loess', 'spline'), spar = .65, #
										 span = .15, bins = 20) {#
#
opt <- match.arg(opt, several.ok = TRUE)  	# 'fix' = how to handle negative values#
# method <- match.arg(method)#
#
applied <- 'processing options applied:'#
#
if (any(opt=='none')) {#
  print('No relevant processing option entered. Returning raw values') #
  specs#
  }#
wl_index <- which(names(specs)=='wl')#
if (length(wl_index > 0)){#
  wl <- specs[, wl_index]#
  specs <- specs[, -wl_index]#
    } else {#
    specs <- specs#
    }#
#
if (any(opt=='smooth')){#
  specs <- sapply(names(specs), function(z){loess.smooth(x = wl, y = specs[, z], #
           span = span, degree = 2, family = "gaussian", #
           evaluation = length(wl))$y})#
  applied <- c(applied, paste('smoothing spectra with a span of',span))#
  }#
#
# if (any(opt=='smooth')&method=='spline')#
  # specs <- sapply(names(specs), function(z){smooth.spline(x = wl, y = specs[, z], #
           # spar = spar)$y})#
#
# if (any(opt=='smooth')&method=='loess')#
  # specs <- sapply(names(specs), function(z){loess.smooth(x = wl, y = specs[, z], #
           # span = span, degree = 2, family = "gaussian", #
           # evaluation = length(wl))$y})#
#
if (any(opt=='minimum')){#
  specs <- sapply(1:ncol(specs), function(z)specs[, z] - min(specs[, z]))#
   applied <- c(applied, 'Scaling spectra to a minimum value of zero')#
  }#
#
if (any(opt=='maximum')){#
  specs <- sapply(1:ncol(specs), function(z)specs[, z] / max(specs[, z]))#
   applied <- c(applied, 'Scaling spectra to a maximum value of 1')#
  }#
#
if (any(opt=='sum')){#
  specs <- sapply(1:ncol(specs), function(z)specs[, z] / sum(specs[, z]))#
   applied <- c(applied, 'Scaling spectra to a total area of 1')#
  }#
#
if (any(opt=='center')){#
  specs <- sapply(1:ncol(specs), function(z)specs[, z] - mean(specs[, z]))#
   applied <- c(applied, 'Centering spectra to a mean of zero')#
  }#
#
#	if (any(opt=='fix'))#
#		specs <- ...#
		# option 1 = set all negatives to zero#
		# option 2 = add absolute val of most neg value to all spectra#
		# option 3 = set negatives to NAs, then smooth?#
#
	# Calculate medians according to # of bins specified for use in PCA#
	# Method follows Cuthill et al. (1999)#
if (any(opt=='bin')) {#
  bw <- floor(length(wl)/bins)#
  wl_bin <- seq(head(wl,1), tail(wl,1), by=bw)#
  wl_ind <- match(wl_bin, wl)#
  specs <- sapply(1:(length(wl_ind)-1), function(z) #
                  apply(specs[wl_ind[z]:(wl_ind[z]+bw), ], 2, median))#
#
  specs <- as.data.frame(cbind(wl_bin[-length(wl_bin)], t(specs)))#
   applied <- c(applied, paste('binned spectra to ',bw,'-nm intervals',sep=''))#
  }else {#
    specs <- as.data.frame(cbind(wl, specs))#
    }#
class(specs) <- c('rspec', 'data.frame')#
return(specs)#
cat(applied)#
}#
#
# testing zone#
#tmp <- procspec(rspecs)#
#tmp <- procspec(rspecs, f="stretch")#
#plot(tmp, p=8:15, type='h')
procspec(sicalis, opt='smooth')
?return
sicalis
sic = apply(sicalis,2, function(x) x + abs(min(x, na.rm=T)))
sic
head(sic)
plot(sicalis[,2])
points(sic[,2])
sic = sic - 10
plot(sic[,2])
sic = apply(sic,2, function(x) x + abs(min(x, na.rm=T)))
plot(sic[,2])
sic = sic - 10
sic = apply(sic,2, function(x) x[x < 0] = 0)
plot(sic[,2])
sic
sic = apply(sicalis,2, function(x) x + abs(min(x, na.rm=T)))
sic = sic - 10
makenegzero<-function(x) {x[x[,2]<0,2] = 0; x}
sic2 <- apply(sic,2,makenegzero)
makenegzero<-function(x) {x[x<0] = 0; x}
sic2 <- apply(sic,2,makenegzero)
sic2
plot(sic2[,2])
ls()
rm(list=ls())
input an rspec object or data frame w/spectra in columns and wavelengths in rows#
# options = min, max, stretch, sum, bin, center (subtract avg. from all specs)#
#
# TODO#
# 1. add way to handle negatives#
#
procspec <- function(specs, opt = c('none', 'smooth', 'maximum', 'minimum', 'stretch', #
										 'bin', 'fix', 'sum', 'center'), #
										 fixneg = c('none', 'min', 'zero')#
										 # method = c('loess', 'spline'), spar = .65, #
										 span = .15, bins = 20) {#
#
opt <- match.arg(opt, several.ok = TRUE)  	# 'fix' = how to handle negative values#
# method <- match.arg(method)#
#
fixneg <- match.arg(fixneg)#
#
applied <- 'processing options applied:\n'#
#
if (any(opt=='none')) {#
  print('No relevant processing option entered. Returning raw values') #
  specs#
  }#
wl_index <- which(names(specs)=='wl')#
if (length(wl_index > 0)){#
  wl <- specs[, wl_index]#
  specs <- specs[, -wl_index]#
    } else {#
    specs <- specs#
    }#
#
if(fixneg=='min'){#
 specs <- apply(specs, 2, function(x) x + abs(min(x, na.rm=T))#
 applied <- c(applied, 'Negative value correction: added min to all reflectance\n')#
 }#
if(fixneg=='zero'){#
  makenegzero<-function(x) {x[x<0] = 0; x}#
  specs <- apply(specs, 2, makenegzero)#
  applied <- c(applied, 'Negative value correction: set to zero\n')#
}#
#
 {#
	interp[,2] <- switch(negative,#
	raw = interp[,2],#
	zero = makenegzero(interp)[,2],#
	min = interp[,2] + abs(min(interp[,2], na.rm=T)),#
	)#
}#
if (any(opt=='smooth')){#
  specs <- sapply(names(specs), function(z){loess.smooth(x = wl, y = specs[, z], #
           span = span, degree = 2, family = "gaussian", #
           evaluation = length(wl))$y})#
  applied <- c(applied, paste('smoothing spectra with a span of',span,'\n'))#
  }#
#
# if (any(opt=='smooth')&method=='spline')#
  # specs <- sapply(names(specs), function(z){smooth.spline(x = wl, y = specs[, z], #
           # spar = spar)$y})#
#
# if (any(opt=='smooth')&method=='loess')#
  # specs <- sapply(names(specs), function(z){loess.smooth(x = wl, y = specs[, z], #
           # span = span, degree = 2, family = "gaussian", #
           # evaluation = length(wl))$y})#
#
if (any(opt=='minimum')){#
  specs <- sapply(1:ncol(specs), function(z)specs[, z] - min(specs[, z]))#
   applied <- c(applied, 'Scaling spectra to a minimum value of zero\n')#
  }#
#
if (any(opt=='maximum')){#
  specs <- sapply(1:ncol(specs), function(z)specs[, z] / max(specs[, z]))#
   applied <- c(applied, 'Scaling spectra to a maximum value of 1\n')#
  }#
#
if (any(opt=='sum')){#
  specs <- sapply(1:ncol(specs), function(z)specs[, z] / sum(specs[, z]))#
   applied <- c(applied, 'Scaling spectra to a total area of 1\n')#
  }#
#
if (any(opt=='center')){#
  specs <- sapply(1:ncol(specs), function(z)specs[, z] - mean(specs[, z]))#
   applied <- c(applied, 'Centering spectra to a mean of zero\n')#
  }#
#
#	if (any(opt=='fix'))#
#		specs <- ...#
		# option 1 = set all negatives to zero#
		# option 2 = add absolute val of most neg value to all spectra#
		# option 3 = set negatives to NAs, then smooth?#
#
	# Calculate medians according to # of bins specified for use in PCA#
	# Method follows Cuthill et al. (1999)#
if (any(opt=='bin')) {#
  bw <- floor(length(wl)/bins)#
  wl_bin <- seq(head(wl,1), tail(wl,1), by=bw)#
  wl_ind <- match(wl_bin, wl)#
  specs <- sapply(1:(length(wl_ind)-1), function(z) #
                  apply(specs[wl_ind[z]:(wl_ind[z]+bw), ], 2, median))#
#
  specs <- as.data.frame(cbind(wl_bin[-length(wl_bin)], t(specs)))#
   applied <- c(applied, paste('binned spectra to ',bw,'-nm intervals\n',sep=''))#
  }else {#
    specs <- as.data.frame(cbind(wl, specs))#
    }#
class(specs) <- c('rspec', 'data.frame')#
return(specs)#
cat(applied)#
}#
#
# testing zone#
#tmp <- procspec(rspecs)#
#tmp <- procspec(rspecs, f="stretch")#
#plot(tmp, p=8:15, type='h')
ls()
rm(applied)
input an rspec object or data frame w/spectra in columns and wavelengths in rows#
# options = min, max, stretch, sum, bin, center (subtract avg. from all specs)#
#
# TODO#
# 1. add way to handle negatives#
#
procspec <- function(specs, opt = c('none', 'smooth', 'maximum', 'minimum', 'stretch', #
										 'bin', 'fix', 'sum', 'center'), #
										 fixneg = c('none', 'min', 'zero'),#
										 # method = c('loess', 'spline'), spar = .65, #
										 span = .15, bins = 20) {#
#
opt <- match.arg(opt, several.ok = TRUE)  	# 'fix' = how to handle negative values#
# method <- match.arg(method)#
#
fixneg <- match.arg(fixneg)#
#
applied <- 'processing options applied:\n'#
#
if (any(opt=='none')) {#
  print('No relevant processing option entered. Returning raw values') #
  specs#
  }#
wl_index <- which(names(specs)=='wl')#
if (length(wl_index > 0)){#
  wl <- specs[, wl_index]#
  specs <- specs[, -wl_index]#
    } else {#
    specs <- specs#
    }#
#
if(fixneg=='min'){#
 specs <- apply(specs, 2, function(x) x + abs(min(x, na.rm=T))#
 applied <- c(applied, 'Negative value correction: added min to all reflectance\n')#
 }#
if(fixneg=='zero'){#
  makenegzero<-function(x) {x[x<0] = 0; x}#
  specs <- apply(specs, 2, makenegzero)#
  applied <- c(applied, 'Negative value correction: set to zero\n')#
}#
#
 {#
	interp[,2] <- switch(negative,#
	raw = interp[,2],#
	zero = makenegzero(interp)[,2],#
	min = interp[,2] + abs(min(interp[,2], na.rm=T)),#
	)#
}#
if (any(opt=='smooth')){#
  specs <- sapply(names(specs), function(z){loess.smooth(x = wl, y = specs[, z], #
           span = span, degree = 2, family = "gaussian", #
           evaluation = length(wl))$y})#
  applied <- c(applied, paste('smoothing spectra with a span of',span,'\n'))#
  }#
#
# if (any(opt=='smooth')&method=='spline')#
  # specs <- sapply(names(specs), function(z){smooth.spline(x = wl, y = specs[, z], #
           # spar = spar)$y})#
#
# if (any(opt=='smooth')&method=='loess')#
  # specs <- sapply(names(specs), function(z){loess.smooth(x = wl, y = specs[, z], #
           # span = span, degree = 2, family = "gaussian", #
           # evaluation = length(wl))$y})#
#
if (any(opt=='minimum')){#
  specs <- sapply(1:ncol(specs), function(z)specs[, z] - min(specs[, z]))#
   applied <- c(applied, 'Scaling spectra to a minimum value of zero\n')#
  }#
#
if (any(opt=='maximum')){#
  specs <- sapply(1:ncol(specs), function(z)specs[, z] / max(specs[, z]))#
   applied <- c(applied, 'Scaling spectra to a maximum value of 1\n')#
  }#
#
if (any(opt=='sum')){#
  specs <- sapply(1:ncol(specs), function(z)specs[, z] / sum(specs[, z]))#
   applied <- c(applied, 'Scaling spectra to a total area of 1\n')#
  }#
#
if (any(opt=='center')){#
  specs <- sapply(1:ncol(specs), function(z)specs[, z] - mean(specs[, z]))#
   applied <- c(applied, 'Centering spectra to a mean of zero\n')#
  }#
#
#	if (any(opt=='fix'))#
#		specs <- ...#
		# option 1 = set all negatives to zero#
		# option 2 = add absolute val of most neg value to all spectra#
		# option 3 = set negatives to NAs, then smooth?#
#
	# Calculate medians according to # of bins specified for use in PCA#
	# Method follows Cuthill et al. (1999)#
if (any(opt=='bin')) {#
  bw <- floor(length(wl)/bins)#
  wl_bin <- seq(head(wl,1), tail(wl,1), by=bw)#
  wl_ind <- match(wl_bin, wl)#
  specs <- sapply(1:(length(wl_ind)-1), function(z) #
                  apply(specs[wl_ind[z]:(wl_ind[z]+bw), ], 2, median))#
#
  specs <- as.data.frame(cbind(wl_bin[-length(wl_bin)], t(specs)))#
   applied <- c(applied, paste('binned spectra to ',bw,'-nm intervals\n',sep=''))#
  }else {#
    specs <- as.data.frame(cbind(wl, specs))#
    }#
class(specs) <- c('rspec', 'data.frame')#
return(specs)#
cat(applied)#
}#
#
# testing zone#
#tmp <- procspec(rspecs)#
#tmp <- procspec(rspecs, f="stretch")#
#plot(tmp, p=8:15, type='h')
input an rspec object or data frame w/spectra in columns and wavelengths in rows#
# options = min, max, stretch, sum, bin, center (subtract avg. from all specs)#
#
# TODO#
# 1. add way to handle negatives#
#
procspec <- function(specs, opt = c('none', 'smooth', 'maximum', 'minimum', 'stretch', #
										 'bin', 'fix', 'sum', 'center'), #
										 fixneg = c('none', 'min', 'zero'),#
										 # method = c('loess', 'spline'), spar = .65, #
										 span = .15, bins = 20) {#
#
opt <- match.arg(opt, several.ok = TRUE)  	# 'fix' = how to handle negative values#
# method <- match.arg(method)#
#
fixneg <- match.arg(fixneg)#
#
applied <- 'processing options applied:\n'#
#
if (any(opt=='none')) {#
  print('No relevant processing option entered. Returning raw values') #
  specs#
  }#
wl_index <- which(names(specs)=='wl')#
if (length(wl_index > 0)){#
  wl <- specs[, wl_index]#
  specs <- specs[, -wl_index]#
    } else {#
    specs <- specs#
    }#
#
if(fixneg=='min'){#
 specs <- apply(specs, 2, function(x) x + abs(min(x, na.rm=T)))#
 applied <- c(applied, 'Negative value correction: added min to all reflectance\n')#
 }#
if(fixneg=='zero'){#
  makenegzero<-function(x) {x[x<0] = 0; x}#
  specs <- apply(specs, 2, makenegzero)#
  applied <- c(applied, 'Negative value correction: set to zero\n')#
}#
#
if (any(opt=='smooth')){#
  specs <- sapply(names(specs), function(z){loess.smooth(x = wl, y = specs[, z], #
           span = span, degree = 2, family = "gaussian", #
           evaluation = length(wl))$y})#
  applied <- c(applied, paste('smoothing spectra with a span of',span,'\n'))#
  }#
#
# if (any(opt=='smooth')&method=='spline')#
  # specs <- sapply(names(specs), function(z){smooth.spline(x = wl, y = specs[, z], #
           # spar = spar)$y})#
#
# if (any(opt=='smooth')&method=='loess')#
  # specs <- sapply(names(specs), function(z){loess.smooth(x = wl, y = specs[, z], #
           # span = span, degree = 2, family = "gaussian", #
           # evaluation = length(wl))$y})#
#
if (any(opt=='minimum')){#
  specs <- sapply(1:ncol(specs), function(z)specs[, z] - min(specs[, z]))#
   applied <- c(applied, 'Scaling spectra to a minimum value of zero\n')#
  }#
#
if (any(opt=='maximum')){#
  specs <- sapply(1:ncol(specs), function(z)specs[, z] / max(specs[, z]))#
   applied <- c(applied, 'Scaling spectra to a maximum value of 1\n')#
  }#
#
if (any(opt=='sum')){#
  specs <- sapply(1:ncol(specs), function(z)specs[, z] / sum(specs[, z]))#
   applied <- c(applied, 'Scaling spectra to a total area of 1\n')#
  }#
#
if (any(opt=='center')){#
  specs <- sapply(1:ncol(specs), function(z)specs[, z] - mean(specs[, z]))#
   applied <- c(applied, 'Centering spectra to a mean of zero\n')#
  }#
#
#	if (any(opt=='fix'))#
#		specs <- ...#
		# option 1 = set all negatives to zero#
		# option 2 = add absolute val of most neg value to all spectra#
		# option 3 = set negatives to NAs, then smooth?#
#
	# Calculate medians according to # of bins specified for use in PCA#
	# Method follows Cuthill et al. (1999)#
if (any(opt=='bin')) {#
  bw <- floor(length(wl)/bins)#
  wl_bin <- seq(head(wl,1), tail(wl,1), by=bw)#
  wl_ind <- match(wl_bin, wl)#
  specs <- sapply(1:(length(wl_ind)-1), function(z) #
                  apply(specs[wl_ind[z]:(wl_ind[z]+bw), ], 2, median))#
#
  specs <- as.data.frame(cbind(wl_bin[-length(wl_bin)], t(specs)))#
   applied <- c(applied, paste('binned spectra to ',bw,'-nm intervals\n',sep=''))#
  }else {#
    specs <- as.data.frame(cbind(wl, specs))#
    }#
class(specs) <- c('rspec', 'data.frame')#
return(specs)#
cat(applied)#
}#
#
# testing zone#
#tmp <- procspec(rspecs)#
#tmp <- procspec(rspecs, f="stretch")#
#plot(tmp, p=8:15, type='h')
data(sicalis)
procspec(sicalis,opt='smooth')
a=procspec(sicalis,opt='smooth')
input an rspec object or data frame w/spectra in columns and wavelengths in rows#
# options = min, max, stretch, sum, bin, center (subtract avg. from all specs)#
#
# TODO#
# 1. add way to handle negatives#
#
procspec <- function(specs, opt = c('none', 'smooth', 'maximum', 'minimum', 'stretch', #
										 'bin', 'fix', 'sum', 'center'), #
										 fixneg = c('none', 'min', 'zero'),#
										 # method = c('loess', 'spline'), spar = .65, #
										 span = .15, bins = 20) {#
#
opt <- match.arg(opt, several.ok = TRUE)  	# 'fix' = how to handle negative values#
# method <- match.arg(method)#
#
fixneg <- match.arg(fixneg)#
#
applied <- 'processing options applied:\n'#
#
if (any(opt=='none')) {#
  print('No relevant processing option entered. Returning raw values') #
  specs#
  }#
wl_index <- which(names(specs)=='wl')#
if (length(wl_index > 0)){#
  wl <- specs[, wl_index]#
  specs <- specs[, -wl_index]#
    } else {#
    specs <- specs#
    }#
#
if(fixneg=='min'){#
 specs <- apply(specs, 2, function(x) x + abs(min(x, na.rm=T)))#
 applied <- c(applied, 'Negative value correction: added min to all reflectance\n')#
 }#
if(fixneg=='zero'){#
  makenegzero<-function(x) {x[x<0] = 0; x}#
  specs <- apply(specs, 2, makenegzero)#
  applied <- c(applied, 'Negative value correction: set to zero\n')#
}#
#
if (any(opt=='smooth')){#
  specs <- sapply(names(specs), function(z){loess.smooth(x = wl, y = specs[, z], #
           span = span, degree = 2, family = "gaussian", #
           evaluation = length(wl))$y})#
  applied <- c(applied, paste('smoothing spectra with a span of',span,'\n'))#
  }#
#
# if (any(opt=='smooth')&method=='spline')#
  # specs <- sapply(names(specs), function(z){smooth.spline(x = wl, y = specs[, z], #
           # spar = spar)$y})#
#
# if (any(opt=='smooth')&method=='loess')#
  # specs <- sapply(names(specs), function(z){loess.smooth(x = wl, y = specs[, z], #
           # span = span, degree = 2, family = "gaussian", #
           # evaluation = length(wl))$y})#
#
if (any(opt=='minimum')){#
  specs <- sapply(1:ncol(specs), function(z)specs[, z] - min(specs[, z]))#
   applied <- c(applied, 'Scaling spectra to a minimum value of zero\n')#
  }#
#
if (any(opt=='maximum')){#
  specs <- sapply(1:ncol(specs), function(z)specs[, z] / max(specs[, z]))#
   applied <- c(applied, 'Scaling spectra to a maximum value of 1\n')#
  }#
#
if (any(opt=='sum')){#
  specs <- sapply(1:ncol(specs), function(z)specs[, z] / sum(specs[, z]))#
   applied <- c(applied, 'Scaling spectra to a total area of 1\n')#
  }#
#
if (any(opt=='center')){#
  specs <- sapply(1:ncol(specs), function(z)specs[, z] - mean(specs[, z]))#
   applied <- c(applied, 'Centering spectra to a mean of zero\n')#
  }#
#
#	if (any(opt=='fix'))#
#		specs <- ...#
		# option 1 = set all negatives to zero#
		# option 2 = add absolute val of most neg value to all spectra#
		# option 3 = set negatives to NAs, then smooth?#
#
	# Calculate medians according to # of bins specified for use in PCA#
	# Method follows Cuthill et al. (1999)#
if (any(opt=='bin')) {#
  bw <- floor(length(wl)/bins)#
  wl_bin <- seq(head(wl,1), tail(wl,1), by=bw)#
  wl_ind <- match(wl_bin, wl)#
  specs <- sapply(1:(length(wl_ind)-1), function(z) #
                  apply(specs[wl_ind[z]:(wl_ind[z]+bw), ], 2, median))#
#
  specs <- as.data.frame(cbind(wl_bin[-length(wl_bin)], t(specs)))#
   applied <- c(applied, paste('binned spectra to ',bw,'-nm intervals\n',sep=''))#
  }else {#
    specs <- as.data.frame(cbind(wl, specs))#
    }#
class(specs) <- c('rspec', 'data.frame')#
specs#
cat(applied)#
}#
#
# testing zone#
#tmp <- procspec(rspecs)#
#tmp <- procspec(rspecs, f="stretch")#
#plot(tmp, p=8:15, type='h')
a=procspec(sicalis,opt='smooth')
a
input an rspec object or data frame w/spectra in columns and wavelengths in rows#
# options = min, max, stretch, sum, bin, center (subtract avg. from all specs)#
#
# TODO#
# 1. add way to handle negatives#
#
procspec <- function(specs, opt = c('none', 'smooth', 'maximum', 'minimum', 'stretch', #
										 'bin', 'fix', 'sum', 'center'), #
										 fixneg = c('none', 'min', 'zero'),#
										 # method = c('loess', 'spline'), spar = .65, #
										 span = .15, bins = 20) {#
#
opt <- match.arg(opt, several.ok = TRUE)  	# 'fix' = how to handle negative values#
# method <- match.arg(method)#
#
fixneg <- match.arg(fixneg)#
#
applied <- 'processing options applied:\n'#
#
if (any(opt=='none')) {#
  print('No relevant processing option entered. Returning raw values') #
  specs#
  }#
wl_index <- which(names(specs)=='wl')#
if (length(wl_index > 0)){#
  wl <- specs[, wl_index]#
  specs <- specs[, -wl_index]#
    } else {#
    specs <- specs#
    }#
#
if(fixneg=='min'){#
 specs <- apply(specs, 2, function(x) x + abs(min(x, na.rm=T)))#
 applied <- c(applied, 'Negative value correction: added min to all reflectance\n')#
 }#
if(fixneg=='zero'){#
  makenegzero<-function(x) {x[x<0] = 0; x}#
  specs <- apply(specs, 2, makenegzero)#
  applied <- c(applied, 'Negative value correction: set to zero\n')#
}#
#
if (any(opt=='smooth')){#
  specs <- sapply(names(specs), function(z){loess.smooth(x = wl, y = specs[, z], #
           span = span, degree = 2, family = "gaussian", #
           evaluation = length(wl))$y})#
  applied <- c(applied, paste('smoothing spectra with a span of',span,'\n'))#
  }#
#
# if (any(opt=='smooth')&method=='spline')#
  # specs <- sapply(names(specs), function(z){smooth.spline(x = wl, y = specs[, z], #
           # spar = spar)$y})#
#
# if (any(opt=='smooth')&method=='loess')#
  # specs <- sapply(names(specs), function(z){loess.smooth(x = wl, y = specs[, z], #
           # span = span, degree = 2, family = "gaussian", #
           # evaluation = length(wl))$y})#
#
if (any(opt=='minimum')){#
  specs <- sapply(1:ncol(specs), function(z)specs[, z] - min(specs[, z]))#
   applied <- c(applied, 'Scaling spectra to a minimum value of zero\n')#
  }#
#
if (any(opt=='maximum')){#
  specs <- sapply(1:ncol(specs), function(z)specs[, z] / max(specs[, z]))#
   applied <- c(applied, 'Scaling spectra to a maximum value of 1\n')#
  }#
#
if (any(opt=='sum')){#
  specs <- sapply(1:ncol(specs), function(z)specs[, z] / sum(specs[, z]))#
   applied <- c(applied, 'Scaling spectra to a total area of 1\n')#
  }#
#
if (any(opt=='center')){#
  specs <- sapply(1:ncol(specs), function(z)specs[, z] - mean(specs[, z]))#
   applied <- c(applied, 'Centering spectra to a mean of zero\n')#
  }#
#
#	if (any(opt=='fix'))#
#		specs <- ...#
		# option 1 = set all negatives to zero#
		# option 2 = add absolute val of most neg value to all spectra#
		# option 3 = set negatives to NAs, then smooth?#
#
	# Calculate medians according to # of bins specified for use in PCA#
	# Method follows Cuthill et al. (1999)#
if (any(opt=='bin')) {#
  bw <- floor(length(wl)/bins)#
  wl_bin <- seq(head(wl,1), tail(wl,1), by=bw)#
  wl_ind <- match(wl_bin, wl)#
  specs <- sapply(1:(length(wl_ind)-1), function(z) #
                  apply(specs[wl_ind[z]:(wl_ind[z]+bw), ], 2, median))#
#
  specs <- as.data.frame(cbind(wl_bin[-length(wl_bin)], t(specs)))#
   applied <- c(applied, paste('binned spectra to ',bw,'-nm intervals\n',sep=''))#
  }else {#
    specs <- as.data.frame(cbind(wl, specs))#
    }#
class(specs) <- c('rspec', 'data.frame')#
cat(applied)#
specs#
}#
#
# testing zone#
#tmp <- procspec(rspecs)#
#tmp <- procspec(rspecs, f="stretch")#
#plot(tmp, p=8:15, type='h')
a=procspec(sicalis,opt='smooth')
a
input an rspec object or data frame w/spectra in columns and wavelengths in rows#
# options = min, max, stretch, sum, bin, center (subtract avg. from all specs)#
#
# TODO#
# 1. add way to handle negatives#
#
procspec <- function(specs, opt = c('none', 'smooth', 'maximum', 'minimum', 'stretch', #
										 'bin', 'fix', 'sum', 'center'), #
										 fixneg = c('none', 'min', 'zero'),#
										 # method = c('loess', 'spline'), spar = .65, #
										 span = .15, bins = 20) {#
#
opt <- match.arg(opt, several.ok = TRUE)  	# 'fix' = how to handle negative values#
# method <- match.arg(method)#
#
fixneg <- match.arg(fixneg)#
#
applied <- 'processing options applied:\n'#
#
if (any(opt=='none')) {#
  print('No relevant processing option entered. Returning raw values') #
  specs#
  }#
wl_index <- which(names(specs)=='wl')#
if (length(wl_index > 0)){#
  wl <- specs[, wl_index]#
  specs <- specs[, -wl_index]#
    } else {#
    specs <- specs#
    }#
#
if(fixneg=='min'){#
 specs <- apply(specs, 2, function(x) x + abs(min(x, na.rm=T)))#
 applied <- c(applied, 'Negative value correction: added min to all reflectance\n')#
 }#
if(fixneg=='zero'){#
  makenegzero<-function(x) {x[x<0] = 0; x}#
  specs <- apply(specs, 2, makenegzero)#
  applied <- c(applied, 'Negative value correction: set to zero\n')#
}#
#
if (any(opt=='smooth')){#
  specs <- sapply(names(specs), function(z){loess.smooth(x = wl, y = specs[, z], #
           span = span, degree = 2, family = "gaussian", #
           evaluation = length(wl))$y})#
  applied <- c(applied, paste('smoothing spectra with a span of',span,'\n'))#
  }#
#
# if (any(opt=='smooth')&method=='spline')#
  # specs <- sapply(names(specs), function(z){smooth.spline(x = wl, y = specs[, z], #
           # spar = spar)$y})#
#
# if (any(opt=='smooth')&method=='loess')#
  # specs <- sapply(names(specs), function(z){loess.smooth(x = wl, y = specs[, z], #
           # span = span, degree = 2, family = "gaussian", #
           # evaluation = length(wl))$y})#
#
if (any(opt=='minimum')){#
  specs <- sapply(1:ncol(specs), function(z)specs[, z] - min(specs[, z]))#
   applied <- c(applied, 'Scaling spectra to a minimum value of zero\n')#
  }#
#
if (any(opt=='maximum')){#
  specs <- sapply(1:ncol(specs), function(z)specs[, z] / max(specs[, z]))#
   applied <- c(applied, 'Scaling spectra to a maximum value of 1\n')#
  }#
#
if (any(opt=='sum')){#
  specs <- sapply(1:ncol(specs), function(z)specs[, z] / sum(specs[, z]))#
   applied <- c(applied, 'Scaling spectra to a total area of 1\n')#
  }#
#
if (any(opt=='center')){#
  specs <- sapply(1:ncol(specs), function(z)specs[, z] - mean(specs[, z]))#
   applied <- c(applied, 'Centering spectra to a mean of zero\n')#
  }#
#
#	if (any(opt=='fix'))#
#		specs <- ...#
		# option 1 = set all negatives to zero#
		# option 2 = add absolute val of most neg value to all spectra#
		# option 3 = set negatives to NAs, then smooth?#
#
	# Calculate medians according to # of bins specified for use in PCA#
	# Method follows Cuthill et al. (1999)#
if (any(opt=='bin')) {#
  bw <- floor(length(wl)/bins)#
  wl_bin <- seq(head(wl,1), tail(wl,1), by=bw)#
  wl_ind <- match(wl_bin, wl)#
  specs <- sapply(1:(length(wl_ind)-1), function(z) #
                  apply(specs[wl_ind[z]:(wl_ind[z]+bw), ], 2, median))#
#
  specs <- as.data.frame(cbind(wl_bin[-length(wl_bin)], t(specs)))#
   applied <- c(applied, paste('binned spectra to ',bw,'-nm intervals\n',sep=''))#
  }else {#
    specs <- as.data.frame(cbind(wl, specs))#
    }#
class(specs) <- c('rspec', 'data.frame')#
#
print(specs)#
cat(applied)#
specs#
}#
#
# testing zone#
#tmp <- procspec(rspecs)#
#tmp <- procspec(rspecs, f="stretch")#
#plot(tmp, p=8:15, type='h')
a
a=procspec(sicalis,opt='smooth')
a
procspec(sicalis,opt='smooth')
?return
?printif
?printlf
procspec(sicalis,opt=c('smooth','max'))
a=procspec(sicalis,opt=c('smooth','max'))
a=procspec(sicalis,opt=c('smooth','max'), fixneg='min')
input an rspec object or data frame w/spectra in columns and wavelengths in rows#
# options = min, max, stretch, sum, bin, center (subtract avg. from all specs)#
#
# TODO#
# 1. add way to handle negatives#
#
procspec <- function(specs, opt = c('none', 'smooth', 'maximum', 'minimum', 'stretch', #
										 'bin', 'fix', 'sum', 'center'), #
										 fixneg = c('none', 'min', 'zero'),#
										 # method = c('loess', 'spline'), spar = .65, #
										 span = .15, bins = 20) {#
#
opt <- match.arg(opt, several.ok = TRUE)  	# 'fix' = how to handle negative values#
# method <- match.arg(method)#
#
fixneg <- match.arg(fixneg)#
#
applied <- 'processing options applied:\n'#
#
if (any(opt=='none')) {#
  print('No relevant processing option entered. Returning raw values') #
  specs#
  }#
wl_index <- which(names(specs)=='wl')#
if (length(wl_index > 0)){#
  wl <- specs[, wl_index]#
  specs <- specs[, -wl_index]#
    } else {#
    specs <- specs#
    }#
#
if(fixneg=='min'){#
 specs <- apply(specs, 2, function(x) ifelse(x<0,x + abs(min(x, na.rm=T),x)))#
 applied <- c(applied, 'Negative value correction: added min to all reflectance\n')#
 }#
if(fixneg=='zero'){#
  makenegzero<-function(x) {x[x<0] = 0; x}#
  specs <- apply(specs, 2, makenegzero)#
  applied <- c(applied, 'Negative value correction: set to zero\n')#
}#
#
if (any(opt=='smooth')){#
  specs <- sapply(names(specs), function(z){loess.smooth(x = wl, y = specs[, z], #
           span = span, degree = 2, family = "gaussian", #
           evaluation = length(wl))$y})#
  applied <- c(applied, paste('smoothing spectra with a span of',span,'\n'))#
  }#
#
# if (any(opt=='smooth')&method=='spline')#
  # specs <- sapply(names(specs), function(z){smooth.spline(x = wl, y = specs[, z], #
           # spar = spar)$y})#
#
# if (any(opt=='smooth')&method=='loess')#
  # specs <- sapply(names(specs), function(z){loess.smooth(x = wl, y = specs[, z], #
           # span = span, degree = 2, family = "gaussian", #
           # evaluation = length(wl))$y})#
#
if (any(opt=='minimum')){#
  specs <- sapply(1:ncol(specs), function(z)specs[, z] - min(specs[, z]))#
   applied <- c(applied, 'Scaling spectra to a minimum value of zero\n')#
  }#
#
if (any(opt=='maximum')){#
  specs <- sapply(1:ncol(specs), function(z)specs[, z] / max(specs[, z]))#
   applied <- c(applied, 'Scaling spectra to a maximum value of 1\n')#
  }#
#
if (any(opt=='sum')){#
  specs <- sapply(1:ncol(specs), function(z)specs[, z] / sum(specs[, z]))#
   applied <- c(applied, 'Scaling spectra to a total area of 1\n')#
  }#
#
if (any(opt=='center')){#
  specs <- sapply(1:ncol(specs), function(z)specs[, z] - mean(specs[, z]))#
   applied <- c(applied, 'Centering spectra to a mean of zero\n')#
  }#
#
#	if (any(opt=='fix'))#
#		specs <- ...#
		# option 1 = set all negatives to zero#
		# option 2 = add absolute val of most neg value to all spectra#
		# option 3 = set negatives to NAs, then smooth?#
#
	# Calculate medians according to # of bins specified for use in PCA#
	# Method follows Cuthill et al. (1999)#
if (any(opt=='bin')) {#
  bw <- floor(length(wl)/bins)#
  wl_bin <- seq(head(wl,1), tail(wl,1), by=bw)#
  wl_ind <- match(wl_bin, wl)#
  specs <- sapply(1:(length(wl_ind)-1), function(z) #
                  apply(specs[wl_ind[z]:(wl_ind[z]+bw), ], 2, median))#
#
  specs <- as.data.frame(cbind(wl_bin[-length(wl_bin)], t(specs)))#
   applied <- c(applied, paste('binned spectra to ',bw,'-nm intervals\n',sep=''))#
  }else {#
    specs <- as.data.frame(cbind(wl, specs))#
    }#
class(specs) <- c('rspec', 'data.frame')#
#
cat(applied)#
specs#
}#
#
# testing zone#
#tmp <- procspec(rspecs)#
#tmp <- procspec(rspecs, f="stretch")#
#plot(tmp, p=8:15, type='h')
a=procspec(sicalis,opt=c('smooth','max'), fixneg='min')
?ifelse
input an rspec object or data frame w/spectra in columns and wavelengths in rows#
# options = min, max, stretch, sum, bin, center (subtract avg. from all specs)#
#
# TODO#
# 1. add way to handle negatives#
#
procspec <- function(specs, opt = c('none', 'smooth', 'maximum', 'minimum', 'stretch', #
										 'bin', 'fix', 'sum', 'center'), #
										 fixneg = c('none', 'min', 'zero'),#
										 # method = c('loess', 'spline'), spar = .65, #
										 span = .15, bins = 20) {#
#
opt <- match.arg(opt, several.ok = TRUE)  	# 'fix' = how to handle negative values#
# method <- match.arg(method)#
#
fixneg <- match.arg(fixneg)#
#
applied <- 'processing options applied:\n'#
#
if (any(opt=='none')) {#
  print('No relevant processing option entered. Returning raw values') #
  specs#
  }#
wl_index <- which(names(specs)=='wl')#
if (length(wl_index > 0)){#
  wl <- specs[, wl_index]#
  specs <- specs[, -wl_index]#
    } else {#
    specs <- specs#
    }#
#
if(fixneg=='min'){#
 specs <- apply(specs, 2, function(x) ifelse(x<0, x <- x + abs(min(x, na.rm=T), x <- x)))#
 applied <- c(applied, 'Negative value correction: added min to all reflectance\n')#
 }#
if(fixneg=='zero'){#
  makenegzero<-function(x) {x[x<0] = 0; x}#
  specs <- apply(specs, 2, makenegzero)#
  applied <- c(applied, 'Negative value correction: set to zero\n')#
}#
#
if (any(opt=='smooth')){#
  specs <- sapply(names(specs), function(z){loess.smooth(x = wl, y = specs[, z], #
           span = span, degree = 2, family = "gaussian", #
           evaluation = length(wl))$y})#
  applied <- c(applied, paste('smoothing spectra with a span of',span,'\n'))#
  }#
#
# if (any(opt=='smooth')&method=='spline')#
  # specs <- sapply(names(specs), function(z){smooth.spline(x = wl, y = specs[, z], #
           # spar = spar)$y})#
#
# if (any(opt=='smooth')&method=='loess')#
  # specs <- sapply(names(specs), function(z){loess.smooth(x = wl, y = specs[, z], #
           # span = span, degree = 2, family = "gaussian", #
           # evaluation = length(wl))$y})#
#
if (any(opt=='minimum')){#
  specs <- sapply(1:ncol(specs), function(z)specs[, z] - min(specs[, z]))#
   applied <- c(applied, 'Scaling spectra to a minimum value of zero\n')#
  }#
#
if (any(opt=='maximum')){#
  specs <- sapply(1:ncol(specs), function(z)specs[, z] / max(specs[, z]))#
   applied <- c(applied, 'Scaling spectra to a maximum value of 1\n')#
  }#
#
if (any(opt=='sum')){#
  specs <- sapply(1:ncol(specs), function(z)specs[, z] / sum(specs[, z]))#
   applied <- c(applied, 'Scaling spectra to a total area of 1\n')#
  }#
#
if (any(opt=='center')){#
  specs <- sapply(1:ncol(specs), function(z)specs[, z] - mean(specs[, z]))#
   applied <- c(applied, 'Centering spectra to a mean of zero\n')#
  }#
#
#	if (any(opt=='fix'))#
#		specs <- ...#
		# option 1 = set all negatives to zero#
		# option 2 = add absolute val of most neg value to all spectra#
		# option 3 = set negatives to NAs, then smooth?#
#
	# Calculate medians according to # of bins specified for use in PCA#
	# Method follows Cuthill et al. (1999)#
if (any(opt=='bin')) {#
  bw <- floor(length(wl)/bins)#
  wl_bin <- seq(head(wl,1), tail(wl,1), by=bw)#
  wl_ind <- match(wl_bin, wl)#
  specs <- sapply(1:(length(wl_ind)-1), function(z) #
                  apply(specs[wl_ind[z]:(wl_ind[z]+bw), ], 2, median))#
#
  specs <- as.data.frame(cbind(wl_bin[-length(wl_bin)], t(specs)))#
   applied <- c(applied, paste('binned spectra to ',bw,'-nm intervals\n',sep=''))#
  }else {#
    specs <- as.data.frame(cbind(wl, specs))#
    }#
class(specs) <- c('rspec', 'data.frame')#
#
cat(applied)#
specs#
}#
#
# testing zone#
#tmp <- procspec(rspecs)#
#tmp <- procspec(rspecs, f="stretch")#
#plot(tmp, p=8:15, type='h')
a=procspec(sicalis,opt=c('smooth','max'), fixneg='min')
?ifelse
input an rspec object or data frame w/spectra in columns and wavelengths in rows#
# options = min, max, stretch, sum, bin, center (subtract avg. from all specs)#
#
# TODO#
# 1. add way to handle negatives#
#
procspec <- function(specs, opt = c('none', 'smooth', 'maximum', 'minimum', 'stretch', #
										 'bin', 'fix', 'sum', 'center'), #
										 fixneg = c('none', 'min', 'zero'),#
										 # method = c('loess', 'spline'), spar = .65, #
										 span = .15, bins = 20) {#
#
opt <- match.arg(opt, several.ok = TRUE)  	# 'fix' = how to handle negative values#
# method <- match.arg(method)#
#
fixneg <- match.arg(fixneg)#
#
applied <- 'processing options applied:\n'#
#
if (any(opt=='none')) {#
  print('No relevant processing option entered. Returning raw values') #
  specs#
  }#
wl_index <- which(names(specs)=='wl')#
if (length(wl_index > 0)){#
  wl <- specs[, wl_index]#
  specs <- specs[, -wl_index]#
    } else {#
    specs <- specs#
    }#
#
if(fixneg=='min'){#
 specs <- apply(specs, 2, function(x) ifelse(x<0, function(x) x + abs(min(x, na.rm=T)), x))#
 applied <- c(applied, 'Negative value correction: added min to all reflectance\n')#
 }#
if(fixneg=='zero'){#
  makenegzero<-function(x) {x[x<0] = 0; x}#
  specs <- apply(specs, 2, makenegzero)#
  applied <- c(applied, 'Negative value correction: set to zero\n')#
}#
#
if (any(opt=='smooth')){#
  specs <- sapply(names(specs), function(z){loess.smooth(x = wl, y = specs[, z], #
           span = span, degree = 2, family = "gaussian", #
           evaluation = length(wl))$y})#
  applied <- c(applied, paste('smoothing spectra with a span of',span,'\n'))#
  }#
#
# if (any(opt=='smooth')&method=='spline')#
  # specs <- sapply(names(specs), function(z){smooth.spline(x = wl, y = specs[, z], #
           # spar = spar)$y})#
#
# if (any(opt=='smooth')&method=='loess')#
  # specs <- sapply(names(specs), function(z){loess.smooth(x = wl, y = specs[, z], #
           # span = span, degree = 2, family = "gaussian", #
           # evaluation = length(wl))$y})#
#
if (any(opt=='minimum')){#
  specs <- sapply(1:ncol(specs), function(z)specs[, z] - min(specs[, z]))#
   applied <- c(applied, 'Scaling spectra to a minimum value of zero\n')#
  }#
#
if (any(opt=='maximum')){#
  specs <- sapply(1:ncol(specs), function(z)specs[, z] / max(specs[, z]))#
   applied <- c(applied, 'Scaling spectra to a maximum value of 1\n')#
  }#
#
if (any(opt=='sum')){#
  specs <- sapply(1:ncol(specs), function(z)specs[, z] / sum(specs[, z]))#
   applied <- c(applied, 'Scaling spectra to a total area of 1\n')#
  }#
#
if (any(opt=='center')){#
  specs <- sapply(1:ncol(specs), function(z)specs[, z] - mean(specs[, z]))#
   applied <- c(applied, 'Centering spectra to a mean of zero\n')#
  }#
#
#	if (any(opt=='fix'))#
#		specs <- ...#
		# option 1 = set all negatives to zero#
		# option 2 = add absolute val of most neg value to all spectra#
		# option 3 = set negatives to NAs, then smooth?#
#
	# Calculate medians according to # of bins specified for use in PCA#
	# Method follows Cuthill et al. (1999)#
if (any(opt=='bin')) {#
  bw <- floor(length(wl)/bins)#
  wl_bin <- seq(head(wl,1), tail(wl,1), by=bw)#
  wl_ind <- match(wl_bin, wl)#
  specs <- sapply(1:(length(wl_ind)-1), function(z) #
                  apply(specs[wl_ind[z]:(wl_ind[z]+bw), ], 2, median))#
#
  specs <- as.data.frame(cbind(wl_bin[-length(wl_bin)], t(specs)))#
   applied <- c(applied, paste('binned spectra to ',bw,'-nm intervals\n',sep=''))#
  }else {#
    specs <- as.data.frame(cbind(wl, specs))#
    }#
class(specs) <- c('rspec', 'data.frame')#
#
cat(applied)#
specs#
}#
#
# testing zone#
#tmp <- procspec(rspecs)#
#tmp <- procspec(rspecs, f="stretch")#
#plot(tmp, p=8:15, type='h')
a=procspec(sicalis,opt=c('smooth','max'), fixneg='min')
min(sicalis[,2] < 0)
sic
sic = sicalis-2
min(sicalis[,2] < 0)
min(sicalis)
sicalis
sic
min(sic)
min(sic[,2] < 0)
apply(sic,2,min)
input an rspec object or data frame w/spectra in columns and wavelengths in rows#
# options = min, max, stretch, sum, bin, center (subtract avg. from all specs)#
#
# TODO#
# 1. add way to handle negatives#
#
procspec <- function(specs, opt = c('none', 'smooth', 'maximum', 'minimum', 'stretch', #
										 'bin', 'fix', 'sum', 'center'), #
										 fixneg = c('none', 'min', 'zero'),#
										 # method = c('loess', 'spline'), spar = .65, #
										 span = .15, bins = 20) {#
#
opt <- match.arg(opt, several.ok = TRUE)  	# 'fix' = how to handle negative values#
# method <- match.arg(method)#
#
fixneg <- match.arg(fixneg)#
#
applied <- 'processing options applied:\n'#
#
if (any(opt=='none')) {#
  print('No relevant processing option entered. Returning raw values') #
  specs#
  }#
wl_index <- which(names(specs)=='wl')#
if (length(wl_index > 0)){#
  wl <- specs[, wl_index]#
  specs <- specs[, -wl_index]#
    } else {#
    specs <- specs#
    }#
#
if(fixneg=='min'){#
  makenegzero<-function(x) {if(min(x) < 0) {x <- x + abs(min(x, na.rm=T))}; x}#
  specs <- apply(specs, 2, function(x) x + abs(min(x, na.rm=T)))#
  applied <- c(applied, 'Negative value correction: added min to all reflectance\n')#
 }#
if(fixneg=='zero'){#
  makenegzero<-function(x) {x[x<0] = 0; x}#
  specs <- apply(specs, 2, makenegzero)#
  applied <- c(applied, 'Negative value correction: set to zero\n')#
}#
#
if (any(opt=='smooth')){#
  specs <- sapply(names(specs), function(z){loess.smooth(x = wl, y = specs[, z], #
           span = span, degree = 2, family = "gaussian", #
           evaluation = length(wl))$y})#
  applied <- c(applied, paste('smoothing spectra with a span of',span,'\n'))#
  }#
#
# if (any(opt=='smooth')&method=='spline')#
  # specs <- sapply(names(specs), function(z){smooth.spline(x = wl, y = specs[, z], #
           # spar = spar)$y})#
#
# if (any(opt=='smooth')&method=='loess')#
  # specs <- sapply(names(specs), function(z){loess.smooth(x = wl, y = specs[, z], #
           # span = span, degree = 2, family = "gaussian", #
           # evaluation = length(wl))$y})#
#
if (any(opt=='minimum')){#
  specs <- sapply(1:ncol(specs), function(z)specs[, z] - min(specs[, z]))#
   applied <- c(applied, 'Scaling spectra to a minimum value of zero\n')#
  }#
#
if (any(opt=='maximum')){#
  specs <- sapply(1:ncol(specs), function(z)specs[, z] / max(specs[, z]))#
   applied <- c(applied, 'Scaling spectra to a maximum value of 1\n')#
  }#
#
if (any(opt=='sum')){#
  specs <- sapply(1:ncol(specs), function(z)specs[, z] / sum(specs[, z]))#
   applied <- c(applied, 'Scaling spectra to a total area of 1\n')#
  }#
#
if (any(opt=='center')){#
  specs <- sapply(1:ncol(specs), function(z)specs[, z] - mean(specs[, z]))#
   applied <- c(applied, 'Centering spectra to a mean of zero\n')#
  }#
#
#	if (any(opt=='fix'))#
#		specs <- ...#
		# option 1 = set all negatives to zero#
		# option 2 = add absolute val of most neg value to all spectra#
		# option 3 = set negatives to NAs, then smooth?#
#
	# Calculate medians according to # of bins specified for use in PCA#
	# Method follows Cuthill et al. (1999)#
if (any(opt=='bin')) {#
  bw <- floor(length(wl)/bins)#
  wl_bin <- seq(head(wl,1), tail(wl,1), by=bw)#
  wl_ind <- match(wl_bin, wl)#
  specs <- sapply(1:(length(wl_ind)-1), function(z) #
                  apply(specs[wl_ind[z]:(wl_ind[z]+bw), ], 2, median))#
#
  specs <- as.data.frame(cbind(wl_bin[-length(wl_bin)], t(specs)))#
   applied <- c(applied, paste('binned spectra to ',bw,'-nm intervals\n',sep=''))#
  }else {#
    specs <- as.data.frame(cbind(wl, specs))#
    }#
class(specs) <- c('rspec', 'data.frame')#
#
cat(applied)#
specs#
}#
#
# testing zone#
#tmp <- procspec(rspecs)#
#tmp <- procspec(rspecs, f="stretch")#
#plot(tmp, p=8:15, type='h')
input an rspec object or data frame w/spectra in columns and wavelengths in rows#
# options = min, max, stretch, sum, bin, center (subtract avg. from all specs)#
#
# TODO#
# 1. add way to handle negatives#
#
procspec <- function(specs, opt = c('none', 'smooth', 'maximum', 'minimum', 'stretch', #
										 'bin', 'fix', 'sum', 'center'), #
										 fixneg = c('none', 'min', 'zero'),#
										 # method = c('loess', 'spline'), spar = .65, #
										 span = .15, bins = 20) {#
#
opt <- match.arg(opt, several.ok = TRUE)  	# 'fix' = how to handle negative values#
# method <- match.arg(method)#
#
fixneg <- match.arg(fixneg)#
#
applied <- 'processing options applied:\n'#
#
if (any(opt=='none')) {#
  print('No relevant processing option entered. Returning raw values') #
  specs#
  }#
wl_index <- which(names(specs)=='wl')#
if (length(wl_index > 0)){#
  wl <- specs[, wl_index]#
  specs <- specs[, -wl_index]#
    } else {#
    specs <- specs#
    }#
#
if(fixneg=='min'){#
  makenegzero<-function(x) {if(min(x) < 0) {x <- x + abs(min(x, na.rm=T))}; x}#
  specs <- apply(specs, 2, makenegzero)#
  applied <- c(applied, 'Negative value correction: added min to all reflectance\n')#
 }#
if(fixneg=='zero'){#
  makenegzero<-function(x) {x[x<0] = 0; x}#
  specs <- apply(specs, 2, makenegzero)#
  applied <- c(applied, 'Negative value correction: set to zero\n')#
}#
#
if (any(opt=='smooth')){#
  specs <- sapply(names(specs), function(z){loess.smooth(x = wl, y = specs[, z], #
           span = span, degree = 2, family = "gaussian", #
           evaluation = length(wl))$y})#
  applied <- c(applied, paste('smoothing spectra with a span of',span,'\n'))#
  }#
#
# if (any(opt=='smooth')&method=='spline')#
  # specs <- sapply(names(specs), function(z){smooth.spline(x = wl, y = specs[, z], #
           # spar = spar)$y})#
#
# if (any(opt=='smooth')&method=='loess')#
  # specs <- sapply(names(specs), function(z){loess.smooth(x = wl, y = specs[, z], #
           # span = span, degree = 2, family = "gaussian", #
           # evaluation = length(wl))$y})#
#
if (any(opt=='minimum')){#
  specs <- sapply(1:ncol(specs), function(z)specs[, z] - min(specs[, z]))#
   applied <- c(applied, 'Scaling spectra to a minimum value of zero\n')#
  }#
#
if (any(opt=='maximum')){#
  specs <- sapply(1:ncol(specs), function(z)specs[, z] / max(specs[, z]))#
   applied <- c(applied, 'Scaling spectra to a maximum value of 1\n')#
  }#
#
if (any(opt=='sum')){#
  specs <- sapply(1:ncol(specs), function(z)specs[, z] / sum(specs[, z]))#
   applied <- c(applied, 'Scaling spectra to a total area of 1\n')#
  }#
#
if (any(opt=='center')){#
  specs <- sapply(1:ncol(specs), function(z)specs[, z] - mean(specs[, z]))#
   applied <- c(applied, 'Centering spectra to a mean of zero\n')#
  }#
#
#	if (any(opt=='fix'))#
#		specs <- ...#
		# option 1 = set all negatives to zero#
		# option 2 = add absolute val of most neg value to all spectra#
		# option 3 = set negatives to NAs, then smooth?#
#
	# Calculate medians according to # of bins specified for use in PCA#
	# Method follows Cuthill et al. (1999)#
if (any(opt=='bin')) {#
  bw <- floor(length(wl)/bins)#
  wl_bin <- seq(head(wl,1), tail(wl,1), by=bw)#
  wl_ind <- match(wl_bin, wl)#
  specs <- sapply(1:(length(wl_ind)-1), function(z) #
                  apply(specs[wl_ind[z]:(wl_ind[z]+bw), ], 2, median))#
#
  specs <- as.data.frame(cbind(wl_bin[-length(wl_bin)], t(specs)))#
   applied <- c(applied, paste('binned spectra to ',bw,'-nm intervals\n',sep=''))#
  }else {#
    specs <- as.data.frame(cbind(wl, specs))#
    }#
class(specs) <- c('rspec', 'data.frame')#
#
cat(applied)#
specs#
}#
#
# testing zone#
#tmp <- procspec(rspecs)#
#tmp <- procspec(rspecs, f="stretch")#
#plot(tmp, p=8:15, type='h')
input an rspec object or data frame w/spectra in columns and wavelengths in rows#
# options = min, max, stretch, sum, bin, center (subtract avg. from all specs)#
#
# TODO#
# 1. add way to handle negatives#
#
procspec <- function(specs, opt = c('none', 'smooth', 'maximum', 'minimum', 'stretch', #
										 'bin', 'fix', 'sum', 'center'), #
										 fixneg = c('none', 'min', 'zero'),#
										 # method = c('loess', 'spline'), spar = .65, #
										 span = .15, bins = 20) {#
#
opt <- match.arg(opt, several.ok = TRUE)  	# 'fix' = how to handle negative values#
# method <- match.arg(method)#
#
fixneg <- match.arg(fixneg)#
#
applied <- 'processing options applied:\n'#
#
if (any(opt=='none')) {#
  print('No relevant processing option entered. Returning raw values') #
  specs#
  }#
wl_index <- which(names(specs)=='wl')#
if (length(wl_index > 0)){#
  wl <- specs[, wl_index]#
  specs <- specs[, -wl_index]#
    } else {#
    specs <- specs#
    }#
#
if(fixneg=='min'){#
  makenegzero<-function(x) {if(min(x) < 0) {x <- x + abs(min(x, na.rm=T))}; x}#
  specs <- apply(specs, 2, makenegzero)#
  applied <- c(applied, 'Negative value correction: added min to all reflectance\n')#
 }#
if(fixneg=='zero'){#
  makenegzero<-function(x) {x[x<0] = 0; x}#
  specs <- apply(specs, 2, makenegzero)#
  applied <- c(applied, 'Negative value correction: set to zero\n')#
}#
#
if (any(opt=='smooth')){#
  specs <- sapply(names(specs), function(z){loess.smooth(x = wl, y = specs[, z], #
           span = span, degree = 2, family = "gaussian", #
           evaluation = length(wl))$y})#
  applied <- c(applied, paste('smoothing spectra with a span of',span,'\n'))#
  }#
#
# if (any(opt=='smooth')&method=='spline')#
  # specs <- sapply(names(specs), function(z){smooth.spline(x = wl, y = specs[, z], #
           # spar = spar)$y})#
#
# if (any(opt=='smooth')&method=='loess')#
  # specs <- sapply(names(specs), function(z){loess.smooth(x = wl, y = specs[, z], #
           # span = span, degree = 2, family = "gaussian", #
           # evaluation = length(wl))$y})#
#
if (any(opt=='minimum')){#
  specs <- sapply(1:ncol(specs), function(z)specs[, z] - min(specs[, z]))#
   applied <- c(applied, 'Scaling spectra to a minimum value of zero\n')#
  }#
#
if (any(opt=='maximum')){#
  specs <- sapply(1:ncol(specs), function(z)specs[, z] / max(specs[, z]))#
   applied <- c(applied, 'Scaling spectra to a maximum value of 1\n')#
  }#
#
if (any(opt=='sum')){#
  specs <- sapply(1:ncol(specs), function(z)specs[, z] / sum(specs[, z]))#
   applied <- c(applied, 'Scaling spectra to a total area of 1\n')#
  }#
#
if (any(opt=='center')){#
  specs <- sapply(1:ncol(specs), function(z)specs[, z] - mean(specs[, z]))#
   applied <- c(applied, 'Centering spectra to a mean of zero\n')#
  }#
#
#	if (any(opt=='fix'))#
#		specs <- ...#
		# option 1 = set all negatives to zero#
		# option 2 = add absolute val of most neg value to all spectra#
		# option 3 = set negatives to NAs, then smooth?#
#
	# Calculate medians according to # of bins specified for use in PCA#
	# Method follows Cuthill et al. (1999)#
if (any(opt=='bin')) {#
  bw <- floor(length(wl)/bins)#
  wl_bin <- seq(head(wl,1), tail(wl,1), by=bw)#
  wl_ind <- match(wl_bin, wl)#
  specs <- sapply(1:(length(wl_ind)-1), function(z) #
                  apply(specs[wl_ind[z]:(wl_ind[z]+bw), ], 2, median))#
#
  specs <- as.data.frame(cbind(wl_bin[-length(wl_bin)], t(specs)))#
   applied <- c(applied, paste('binned spectra to ',bw,'-nm intervals\n',sep=''))#
  }else {#
    specs <- as.data.frame(cbind(wl, specs))#
    }#
class(specs) <- c('rspec', 'data.frame')#
#
cat(applied)#
specs#
}#
#
# testing zone#
#tmp <- procspec(rspecs)#
#tmp <- procspec(rspecs, f="stretch")#
#plot(tmp, p=8:15, type='h')
a=procspec(sicalis,opt=c('smooth','max'), fixneg='min')
a=procspec(sicalis,opt=c('smooth','max'))
a=procspec(sicalis,opt=c('smooth','max'), fixneg='min')
input an rspec object or data frame w/spectra in columns and wavelengths in rows#
# options = min, max, stretch, sum, bin, center (subtract avg. from all specs)#
#
# TODO#
# 1. add way to handle negatives#
#
procspec <- function(specs, opt = c('none', 'smooth', 'maximum', 'minimum', 'stretch', #
										 'bin', 'fix', 'sum', 'center'), #
										 fixneg = c('none', 'min', 'zero'),#
										 # method = c('loess', 'spline'), spar = .65, #
										 span = .15, bins = 20) {#
#
opt <- match.arg(opt, several.ok = TRUE)  	# 'fix' = how to handle negative values#
# method <- match.arg(method)#
#
fixneg <- match.arg(fixneg)#
#
applied <- 'processing options applied:\n'#
#
if (any(opt=='none')) {#
  print('No relevant processing option entered. Returning raw values') #
  specs#
  }#
wl_index <- which(names(specs)=='wl')#
if (length(wl_index > 0)){#
  wl <- specs[, wl_index]#
  specs <- specs[, -wl_index]#
    } else {#
    specs <- specs#
    }#
#
if(fixneg=='min'){#
  makenegzero<-function(x) {#
  	if(min(x) < 0) {#
  		x <- x + abs(min(x, na.rm=T))#
  		}#
  	x}#
  specs <- apply(specs, 2, makenegzero)#
  applied <- c(applied, 'Negative value correction: added min to all reflectance\n')#
 }#
if(fixneg=='zero'){#
  makenegzero<-function(x) {x[x<0] = 0; x}#
  specs <- apply(specs, 2, makenegzero)#
  applied <- c(applied, 'Negative value correction: set to zero\n')#
}#
#
if (any(opt=='smooth')){#
  specs <- sapply(names(specs), function(z){loess.smooth(x = wl, y = specs[, z], #
           span = span, degree = 2, family = "gaussian", #
           evaluation = length(wl))$y})#
  applied <- c(applied, paste('smoothing spectra with a span of',span,'\n'))#
  }#
#
# if (any(opt=='smooth')&method=='spline')#
  # specs <- sapply(names(specs), function(z){smooth.spline(x = wl, y = specs[, z], #
           # spar = spar)$y})#
#
# if (any(opt=='smooth')&method=='loess')#
  # specs <- sapply(names(specs), function(z){loess.smooth(x = wl, y = specs[, z], #
           # span = span, degree = 2, family = "gaussian", #
           # evaluation = length(wl))$y})#
#
if (any(opt=='minimum')){#
  specs <- sapply(1:ncol(specs), function(z)specs[, z] - min(specs[, z]))#
   applied <- c(applied, 'Scaling spectra to a minimum value of zero\n')#
  }#
#
if (any(opt=='maximum')){#
  specs <- sapply(1:ncol(specs), function(z)specs[, z] / max(specs[, z]))#
   applied <- c(applied, 'Scaling spectra to a maximum value of 1\n')#
  }#
#
if (any(opt=='sum')){#
  specs <- sapply(1:ncol(specs), function(z)specs[, z] / sum(specs[, z]))#
   applied <- c(applied, 'Scaling spectra to a total area of 1\n')#
  }#
#
if (any(opt=='center')){#
  specs <- sapply(1:ncol(specs), function(z)specs[, z] - mean(specs[, z]))#
   applied <- c(applied, 'Centering spectra to a mean of zero\n')#
  }#
#
#	if (any(opt=='fix'))#
#		specs <- ...#
		# option 1 = set all negatives to zero#
		# option 2 = add absolute val of most neg value to all spectra#
		# option 3 = set negatives to NAs, then smooth?#
#
	# Calculate medians according to # of bins specified for use in PCA#
	# Method follows Cuthill et al. (1999)#
if (any(opt=='bin')) {#
  bw <- floor(length(wl)/bins)#
  wl_bin <- seq(head(wl,1), tail(wl,1), by=bw)#
  wl_ind <- match(wl_bin, wl)#
  specs <- sapply(1:(length(wl_ind)-1), function(z) #
                  apply(specs[wl_ind[z]:(wl_ind[z]+bw), ], 2, median))#
#
  specs <- as.data.frame(cbind(wl_bin[-length(wl_bin)], t(specs)))#
   applied <- c(applied, paste('binned spectra to ',bw,'-nm intervals\n',sep=''))#
  }else {#
    specs <- as.data.frame(cbind(wl, specs))#
    }#
class(specs) <- c('rspec', 'data.frame')#
#
cat(applied)#
specs#
}#
#
# testing zone#
#tmp <- procspec(rspecs)#
#tmp <- procspec(rspecs, f="stretch")#
#plot(tmp, p=8:15, type='h')
a=procspec(sicalis,opt=c('smooth','max'), fixneg='min')
a=procspec(sicalis,opt=c('smooth','max'), fixneg='zero')
input an rspec object or data frame w/spectra in columns and wavelengths in rows#
# options = min, max, stretch, sum, bin, center (subtract avg. from all specs)#
#
# TODO#
# 1. add way to handle negatives#
#
procspec <- function(specs, opt = c('none', 'smooth', 'maximum', 'minimum', 'stretch', #
										 'bin', 'fix', 'sum', 'center'), #
										 fixneg = c('none', 'min', 'zero'),#
										 # method = c('loess', 'spline'), spar = .65, #
										 span = .15, bins = 20) {#
#
opt <- match.arg(opt, several.ok = TRUE)  	# 'fix' = how to handle negative values#
# method <- match.arg(method)#
#
fixneg <- match.arg(fixneg)#
#
applied <- 'processing options applied:\n'#
#
if (any(opt=='none')) {#
  print('No relevant processing option entered. Returning raw values') #
  specs#
  }#
wl_index <- which(names(specs)=='wl')#
if (length(wl_index > 0)){#
  wl <- specs[, wl_index]#
  specs <- specs[, -wl_index]#
    } else {#
    specs <- specs#
    }#
#
if(fixneg=='min'){#
  makenegzero<-function(x) {#
  	if(min(x) < 0) {#
  		x <- x + abs(min(x, na.rm=T))#
  		}#
  	x}#
  specs <- apply(specs, 2, makenegzero)#
  applied <- c(applied, 'Negative value correction: added min to all reflectance\n')#
 }#
#
makenegzero<-function(x) {x[x<0] = 0; x}#
if(fixneg=='zero'){#
  specs <- apply(specs, 2, makenegzero)#
  applied <- c(applied, 'Negative value correction: set to zero\n')#
}#
#
if (any(opt=='smooth')){#
  specs <- sapply(names(specs), function(z){loess.smooth(x = wl, y = specs[, z], #
           span = span, degree = 2, family = "gaussian", #
           evaluation = length(wl))$y})#
  applied <- c(applied, paste('smoothing spectra with a span of',span,'\n'))#
  }#
#
# if (any(opt=='smooth')&method=='spline')#
  # specs <- sapply(names(specs), function(z){smooth.spline(x = wl, y = specs[, z], #
           # spar = spar)$y})#
#
# if (any(opt=='smooth')&method=='loess')#
  # specs <- sapply(names(specs), function(z){loess.smooth(x = wl, y = specs[, z], #
           # span = span, degree = 2, family = "gaussian", #
           # evaluation = length(wl))$y})#
#
if (any(opt=='minimum')){#
  specs <- sapply(1:ncol(specs), function(z)specs[, z] - min(specs[, z]))#
   applied <- c(applied, 'Scaling spectra to a minimum value of zero\n')#
  }#
#
if (any(opt=='maximum')){#
  specs <- sapply(1:ncol(specs), function(z)specs[, z] / max(specs[, z]))#
   applied <- c(applied, 'Scaling spectra to a maximum value of 1\n')#
  }#
#
if (any(opt=='sum')){#
  specs <- sapply(1:ncol(specs), function(z)specs[, z] / sum(specs[, z]))#
   applied <- c(applied, 'Scaling spectra to a total area of 1\n')#
  }#
#
if (any(opt=='center')){#
  specs <- sapply(1:ncol(specs), function(z)specs[, z] - mean(specs[, z]))#
   applied <- c(applied, 'Centering spectra to a mean of zero\n')#
  }#
#
#	if (any(opt=='fix'))#
#		specs <- ...#
		# option 1 = set all negatives to zero#
		# option 2 = add absolute val of most neg value to all spectra#
		# option 3 = set negatives to NAs, then smooth?#
#
	# Calculate medians according to # of bins specified for use in PCA#
	# Method follows Cuthill et al. (1999)#
if (any(opt=='bin')) {#
  bw <- floor(length(wl)/bins)#
  wl_bin <- seq(head(wl,1), tail(wl,1), by=bw)#
  wl_ind <- match(wl_bin, wl)#
  specs <- sapply(1:(length(wl_ind)-1), function(z) #
                  apply(specs[wl_ind[z]:(wl_ind[z]+bw), ], 2, median))#
#
  specs <- as.data.frame(cbind(wl_bin[-length(wl_bin)], t(specs)))#
   applied <- c(applied, paste('binned spectra to ',bw,'-nm intervals\n',sep=''))#
  }else {#
    specs <- as.data.frame(cbind(wl, specs))#
    }#
class(specs) <- c('rspec', 'data.frame')#
#
cat(applied)#
specs#
}#
#
# testing zone#
#tmp <- procspec(rspecs)#
#tmp <- procspec(rspecs, f="stretch")#
#plot(tmp, p=8:15, type='h')
a=procspec(sicalis,opt=c('smooth','max'), fixneg='zero')
input an rspec object or data frame w/spectra in columns and wavelengths in rows#
# options = min, max, stretch, sum, bin, center (subtract avg. from all specs)#
#
# TODO#
# 1. add way to handle negatives#
#
procspec <- function(specs, opt = c('none', 'smooth', 'maximum', 'minimum', 'stretch', #
										 'bin', 'fix', 'sum', 'center'), #
										 fixneg = c('none', 'min', 'zero'),#
										 # method = c('loess', 'spline'), spar = .65, #
										 span = .15, bins = 20) {#
#
opt <- match.arg(opt, several.ok = TRUE)  	# 'fix' = how to handle negative values#
# method <- match.arg(method)#
#
fixneg <- match.arg(fixneg)#
#
applied <- 'processing options applied:\n'#
#
if (any(opt=='none')) {#
  print('No relevant processing option entered. Returning raw values') #
  specs#
  }#
wl_index <- which(names(specs)=='wl')#
if (length(wl_index > 0)){#
  wl <- specs[, wl_index]#
  specs <- specs[, -wl_index]#
    } else {#
    specs <- specs#
    }#
#
if(fixneg=='min'){#
  makenegzero<-function(x) {#
  	if(min(x) < 0) {#
  		x <- x + abs(min(x, na.rm=T))#
  		}#
  	x}#
  specs <- apply(specs, 2, makenegzero)#
  applied <- c(applied, 'Negative value correction: added min to all reflectance\n')#
 }#
#
makenegzero<-function(x) {x[x<0] = 0; x}#
if(fixneg=='zero'){#
  specs <- sapply(specs, function(z) makenegzero(specs[,z]))#
  applied <- c(applied, 'Negative value correction: set to zero\n')#
}#
#
if (any(opt=='smooth')){#
  specs <- sapply(names(specs), function(z){loess.smooth(x = wl, y = specs[, z], #
           span = span, degree = 2, family = "gaussian", #
           evaluation = length(wl))$y})#
  applied <- c(applied, paste('smoothing spectra with a span of',span,'\n'))#
  }#
#
# if (any(opt=='smooth')&method=='spline')#
  # specs <- sapply(names(specs), function(z){smooth.spline(x = wl, y = specs[, z], #
           # spar = spar)$y})#
#
# if (any(opt=='smooth')&method=='loess')#
  # specs <- sapply(names(specs), function(z){loess.smooth(x = wl, y = specs[, z], #
           # span = span, degree = 2, family = "gaussian", #
           # evaluation = length(wl))$y})#
#
if (any(opt=='minimum')){#
  specs <- sapply(1:ncol(specs), function(z)specs[, z] - min(specs[, z]))#
   applied <- c(applied, 'Scaling spectra to a minimum value of zero\n')#
  }#
#
if (any(opt=='maximum')){#
  specs <- sapply(1:ncol(specs), function(z)specs[, z] / max(specs[, z]))#
   applied <- c(applied, 'Scaling spectra to a maximum value of 1\n')#
  }#
#
if (any(opt=='sum')){#
  specs <- sapply(1:ncol(specs), function(z)specs[, z] / sum(specs[, z]))#
   applied <- c(applied, 'Scaling spectra to a total area of 1\n')#
  }#
#
if (any(opt=='center')){#
  specs <- sapply(1:ncol(specs), function(z)specs[, z] - mean(specs[, z]))#
   applied <- c(applied, 'Centering spectra to a mean of zero\n')#
  }#
#
#	if (any(opt=='fix'))#
#		specs <- ...#
		# option 1 = set all negatives to zero#
		# option 2 = add absolute val of most neg value to all spectra#
		# option 3 = set negatives to NAs, then smooth?#
#
	# Calculate medians according to # of bins specified for use in PCA#
	# Method follows Cuthill et al. (1999)#
if (any(opt=='bin')) {#
  bw <- floor(length(wl)/bins)#
  wl_bin <- seq(head(wl,1), tail(wl,1), by=bw)#
  wl_ind <- match(wl_bin, wl)#
  specs <- sapply(1:(length(wl_ind)-1), function(z) #
                  apply(specs[wl_ind[z]:(wl_ind[z]+bw), ], 2, median))#
#
  specs <- as.data.frame(cbind(wl_bin[-length(wl_bin)], t(specs)))#
   applied <- c(applied, paste('binned spectra to ',bw,'-nm intervals\n',sep=''))#
  }else {#
    specs <- as.data.frame(cbind(wl, specs))#
    }#
class(specs) <- c('rspec', 'data.frame')#
#
cat(applied)#
specs#
}#
#
# testing zone#
#tmp <- procspec(rspecs)#
#tmp <- procspec(rspecs, f="stretch")#
#plot(tmp, p=8:15, type='h')
a=procspec(sicalis,opt=c('smooth','max'), fixneg='zero')
input an rspec object or data frame w/spectra in columns and wavelengths in rows#
# options = min, max, stretch, sum, bin, center (subtract avg. from all specs)#
#
# TODO#
# 1. add way to handle negatives#
#
procspec <- function(specs, opt = c('none', 'smooth', 'maximum', 'minimum', 'stretch', #
										 'bin', 'fix', 'sum', 'center'), #
										 fixneg = c('none', 'min', 'zero'),#
										 # method = c('loess', 'spline'), spar = .65, #
										 span = .15, bins = 20) {#
#
opt <- match.arg(opt, several.ok = TRUE)  	# 'fix' = how to handle negative values#
# method <- match.arg(method)#
#
fixneg <- match.arg(fixneg)#
#
applied <- 'processing options applied:\n'#
#
if (any(opt=='none')) {#
  print('No relevant processing option entered. Returning raw values') #
  specs#
  }#
wl_index <- which(names(specs)=='wl')#
if (length(wl_index > 0)){#
  wl <- specs[, wl_index]#
  specs <- specs[, -wl_index]#
    } else {#
    specs <- specs#
    }#
#
if(fixneg=='min'){#
  specs <- sapply(specs, function(z) specs[,z] + abs(min(specs[,z], na.rm=T))#
  applied <- c(applied, 'Negative value correction: added min to all reflectance\n')#
 }#
#
makenegzero<-function(x) {x[x<0] = 0; x}#
if(fixneg=='zero'){#
  specs <- sapply(specs, function(z) specs[,z])#
  applied <- c(applied, 'Negative value correction: set to zero\n')#
}#
#
if (any(opt=='smooth')){#
  specs <- sapply(names(specs), function(z){loess.smooth(x = wl, y = specs[, z], #
           span = span, degree = 2, family = "gaussian", #
           evaluation = length(wl))$y})#
  applied <- c(applied, paste('smoothing spectra with a span of',span,'\n'))#
  }#
#
# if (any(opt=='smooth')&method=='spline')#
  # specs <- sapply(names(specs), function(z){smooth.spline(x = wl, y = specs[, z], #
           # spar = spar)$y})#
#
# if (any(opt=='smooth')&method=='loess')#
  # specs <- sapply(names(specs), function(z){loess.smooth(x = wl, y = specs[, z], #
           # span = span, degree = 2, family = "gaussian", #
           # evaluation = length(wl))$y})#
#
if (any(opt=='minimum')){#
  specs <- sapply(1:ncol(specs), function(z)specs[, z] - min(specs[, z]))#
   applied <- c(applied, 'Scaling spectra to a minimum value of zero\n')#
  }#
#
if (any(opt=='maximum')){#
  specs <- sapply(1:ncol(specs), function(z)specs[, z] / max(specs[, z]))#
   applied <- c(applied, 'Scaling spectra to a maximum value of 1\n')#
  }#
#
if (any(opt=='sum')){#
  specs <- sapply(1:ncol(specs), function(z)specs[, z] / sum(specs[, z]))#
   applied <- c(applied, 'Scaling spectra to a total area of 1\n')#
  }#
#
if (any(opt=='center')){#
  specs <- sapply(1:ncol(specs), function(z)specs[, z] - mean(specs[, z]))#
   applied <- c(applied, 'Centering spectra to a mean of zero\n')#
  }#
#
#	if (any(opt=='fix'))#
#		specs <- ...#
		# option 1 = set all negatives to zero#
		# option 2 = add absolute val of most neg value to all spectra#
		# option 3 = set negatives to NAs, then smooth?#
#
	# Calculate medians according to # of bins specified for use in PCA#
	# Method follows Cuthill et al. (1999)#
if (any(opt=='bin')) {#
  bw <- floor(length(wl)/bins)#
  wl_bin <- seq(head(wl,1), tail(wl,1), by=bw)#
  wl_ind <- match(wl_bin, wl)#
  specs <- sapply(1:(length(wl_ind)-1), function(z) #
                  apply(specs[wl_ind[z]:(wl_ind[z]+bw), ], 2, median))#
#
  specs <- as.data.frame(cbind(wl_bin[-length(wl_bin)], t(specs)))#
   applied <- c(applied, paste('binned spectra to ',bw,'-nm intervals\n',sep=''))#
  }else {#
    specs <- as.data.frame(cbind(wl, specs))#
    }#
class(specs) <- c('rspec', 'data.frame')#
#
cat(applied)#
specs#
}#
#
# testing zone#
#tmp <- procspec(rspecs)#
#tmp <- procspec(rspecs, f="stretch")#
#plot(tmp, p=8:15, type='h')
input an rspec object or data frame w/spectra in columns and wavelengths in rows#
# options = min, max, stretch, sum, bin, center (subtract avg. from all specs)#
#
# TODO#
# 1. add way to handle negatives#
#
procspec <- function(specs, opt = c('none', 'smooth', 'maximum', 'minimum', 'stretch', #
										 'bin', 'fix', 'sum', 'center'), #
										 fixneg = c('none', 'min', 'zero'),#
										 # method = c('loess', 'spline'), spar = .65, #
										 span = .15, bins = 20) {#
#
opt <- match.arg(opt, several.ok = TRUE)  	# 'fix' = how to handle negative values#
# method <- match.arg(method)#
#
fixneg <- match.arg(fixneg)#
#
applied <- 'processing options applied:\n'#
#
if (any(opt=='none')) {#
  print('No relevant processing option entered. Returning raw values') #
  specs#
  }#
wl_index <- which(names(specs)=='wl')#
if (length(wl_index > 0)){#
  wl <- specs[, wl_index]#
  specs <- specs[, -wl_index]#
    } else {#
    specs <- specs#
    }#
#
if(fixneg=='min'){#
  specs <- sapply(specs, function(z) specs[,z] + abs(min(specs[,z], na.rm=T)))#
  applied <- c(applied, 'Negative value correction: added min to all reflectance\n')#
 }#
#
makenegzero<-function(x) {x[x<0] = 0; x}#
if(fixneg=='zero'){#
  specs <- sapply(specs, function(z) specs[,z])#
  applied <- c(applied, 'Negative value correction: set to zero\n')#
}#
#
if (any(opt=='smooth')){#
  specs <- sapply(names(specs), function(z){loess.smooth(x = wl, y = specs[, z], #
           span = span, degree = 2, family = "gaussian", #
           evaluation = length(wl))$y})#
  applied <- c(applied, paste('smoothing spectra with a span of',span,'\n'))#
  }#
#
# if (any(opt=='smooth')&method=='spline')#
  # specs <- sapply(names(specs), function(z){smooth.spline(x = wl, y = specs[, z], #
           # spar = spar)$y})#
#
# if (any(opt=='smooth')&method=='loess')#
  # specs <- sapply(names(specs), function(z){loess.smooth(x = wl, y = specs[, z], #
           # span = span, degree = 2, family = "gaussian", #
           # evaluation = length(wl))$y})#
#
if (any(opt=='minimum')){#
  specs <- sapply(1:ncol(specs), function(z)specs[, z] - min(specs[, z]))#
   applied <- c(applied, 'Scaling spectra to a minimum value of zero\n')#
  }#
#
if (any(opt=='maximum')){#
  specs <- sapply(1:ncol(specs), function(z)specs[, z] / max(specs[, z]))#
   applied <- c(applied, 'Scaling spectra to a maximum value of 1\n')#
  }#
#
if (any(opt=='sum')){#
  specs <- sapply(1:ncol(specs), function(z)specs[, z] / sum(specs[, z]))#
   applied <- c(applied, 'Scaling spectra to a total area of 1\n')#
  }#
#
if (any(opt=='center')){#
  specs <- sapply(1:ncol(specs), function(z)specs[, z] - mean(specs[, z]))#
   applied <- c(applied, 'Centering spectra to a mean of zero\n')#
  }#
#
#	if (any(opt=='fix'))#
#		specs <- ...#
		# option 1 = set all negatives to zero#
		# option 2 = add absolute val of most neg value to all spectra#
		# option 3 = set negatives to NAs, then smooth?#
#
	# Calculate medians according to # of bins specified for use in PCA#
	# Method follows Cuthill et al. (1999)#
if (any(opt=='bin')) {#
  bw <- floor(length(wl)/bins)#
  wl_bin <- seq(head(wl,1), tail(wl,1), by=bw)#
  wl_ind <- match(wl_bin, wl)#
  specs <- sapply(1:(length(wl_ind)-1), function(z) #
                  apply(specs[wl_ind[z]:(wl_ind[z]+bw), ], 2, median))#
#
  specs <- as.data.frame(cbind(wl_bin[-length(wl_bin)], t(specs)))#
   applied <- c(applied, paste('binned spectra to ',bw,'-nm intervals\n',sep=''))#
  }else {#
    specs <- as.data.frame(cbind(wl, specs))#
    }#
class(specs) <- c('rspec', 'data.frame')#
#
cat(applied)#
specs#
}#
#
# testing zone#
#tmp <- procspec(rspecs)#
#tmp <- procspec(rspecs, f="stretch")#
#plot(tmp, p=8:15, type='h')
a=procspec(sicalis,opt=c('smooth','max'), fixneg='zero')
a=procspec(sicalis,opt=c('smooth','max'), fixneg='min')
input an rspec object or data frame w/spectra in columns and wavelengths in rows#
# options = min, max, stretch, sum, bin, center (subtract avg. from all specs)#
#
# TODO#
# 1. add way to handle negatives#
#
procspec <- function(specs, opt = c('none', 'smooth', 'maximum', 'minimum', 'stretch', #
										 'bin', 'fix', 'sum', 'center'), #
										 fixneg = c('none', 'min', 'zero'),#
										 # method = c('loess', 'spline'), spar = .65, #
										 span = .15, bins = 20) {#
#
opt <- match.arg(opt, several.ok = TRUE)  	# 'fix' = how to handle negative values#
# method <- match.arg(method)#
#
fixneg <- match.arg(fixneg)#
#
applied <- 'processing options applied:\n'#
#
if (any(opt=='none')) {#
  print('No relevant processing option entered. Returning raw values') #
  specs#
  }#
wl_index <- which(names(specs)=='wl')#
if (length(wl_index > 0)){#
  wl <- specs[, wl_index]#
  specs <- specs[, -wl_index]#
    } else {#
    specs <- specs#
    }#
#
if(fixneg=='min'){#
  specs <- sapply(specs, function(z) specs[,z] + abs(min(specs[,z], na.rm=T)))#
  applied <- c(applied, 'Negative value correction: added min to all reflectance\n')#
 }#
#
makenegzero<-function(x) {x[x<0] = 0; x}#
if(fixneg=='zero'){#
  specs <- sapply(1:ncol(specs), function(z) specs[,z])#
  applied <- c(applied, 'Negative value correction: set to zero\n')#
}#
#
if (any(opt=='smooth')){#
  specs <- sapply(names(specs), function(z){loess.smooth(x = wl, y = specs[, z], #
           span = span, degree = 2, family = "gaussian", #
           evaluation = length(wl))$y})#
  applied <- c(applied, paste('smoothing spectra with a span of',span,'\n'))#
  }#
#
# if (any(opt=='smooth')&method=='spline')#
  # specs <- sapply(names(specs), function(z){smooth.spline(x = wl, y = specs[, z], #
           # spar = spar)$y})#
#
# if (any(opt=='smooth')&method=='loess')#
  # specs <- sapply(names(specs), function(z){loess.smooth(x = wl, y = specs[, z], #
           # span = span, degree = 2, family = "gaussian", #
           # evaluation = length(wl))$y})#
#
if (any(opt=='minimum')){#
  specs <- sapply(1:ncol(specs), function(z)specs[, z] - min(specs[, z]))#
   applied <- c(applied, 'Scaling spectra to a minimum value of zero\n')#
  }#
#
if (any(opt=='maximum')){#
  specs <- sapply(1:ncol(specs), function(z)specs[, z] / max(specs[, z]))#
   applied <- c(applied, 'Scaling spectra to a maximum value of 1\n')#
  }#
#
if (any(opt=='sum')){#
  specs <- sapply(1:ncol(specs), function(z)specs[, z] / sum(specs[, z]))#
   applied <- c(applied, 'Scaling spectra to a total area of 1\n')#
  }#
#
if (any(opt=='center')){#
  specs <- sapply(1:ncol(specs), function(z)specs[, z] - mean(specs[, z]))#
   applied <- c(applied, 'Centering spectra to a mean of zero\n')#
  }#
#
#	if (any(opt=='fix'))#
#		specs <- ...#
		# option 1 = set all negatives to zero#
		# option 2 = add absolute val of most neg value to all spectra#
		# option 3 = set negatives to NAs, then smooth?#
#
	# Calculate medians according to # of bins specified for use in PCA#
	# Method follows Cuthill et al. (1999)#
if (any(opt=='bin')) {#
  bw <- floor(length(wl)/bins)#
  wl_bin <- seq(head(wl,1), tail(wl,1), by=bw)#
  wl_ind <- match(wl_bin, wl)#
  specs <- sapply(1:(length(wl_ind)-1), function(z) #
                  apply(specs[wl_ind[z]:(wl_ind[z]+bw), ], 2, median))#
#
  specs <- as.data.frame(cbind(wl_bin[-length(wl_bin)], t(specs)))#
   applied <- c(applied, paste('binned spectra to ',bw,'-nm intervals\n',sep=''))#
  }else {#
    specs <- as.data.frame(cbind(wl, specs))#
    }#
class(specs) <- c('rspec', 'data.frame')#
#
cat(applied)#
specs#
}#
#
# testing zone#
#tmp <- procspec(rspecs)#
#tmp <- procspec(rspecs, f="stretch")#
#plot(tmp, p=8:15, type='h')
a=procspec(sicalis,opt=c('smooth','max'), fixneg='zero')
a=procspec(sicalis,opt=c('smooth','max'), fixneg='min')
input an rspec object or data frame w/spectra in columns and wavelengths in rows#
# options = min, max, stretch, sum, bin, center (subtract avg. from all specs)#
#
# TODO#
# 1. add way to handle negatives#
#
procspec <- function(specs, opt = c('none', 'smooth', 'maximum', 'minimum', 'stretch', #
										 'bin', 'fix', 'sum', 'center'), #
										 fixneg = c('none', 'min', 'zero'),#
										 # method = c('loess', 'spline'), spar = .65, #
										 span = .15, bins = 20) {#
#
opt <- match.arg(opt, several.ok = TRUE)  	# 'fix' = how to handle negative values#
# method <- match.arg(method)#
#
fixneg <- match.arg(fixneg)#
#
applied <- 'processing options applied:\n'#
#
if (any(opt=='none')) {#
  print('No relevant processing option entered. Returning raw values') #
  specs#
  }#
wl_index <- which(names(specs)=='wl')#
if (length(wl_index > 0)){#
  wl <- specs[, wl_index]#
  specs <- specs[, -wl_index]#
    } else {#
    specs <- specs#
    }#
#
if(fixneg=='min'){#
  specs <- sapply(1:ncol(specs), function(z) specs[,z] + abs(min(specs[,z], na.rm=T)))#
  applied <- c(applied, 'Negative value correction: added min to all reflectance\n')#
 }#
#
makenegzero<-function(x) {x[x<0] = 0; x}#
if(fixneg=='zero'){#
  specs <- sapply(1:ncol(specs), function(z) specs[,z])#
  applied <- c(applied, 'Negative value correction: set to zero\n')#
}#
#
if (any(opt=='smooth')){#
  specs <- sapply(names(specs), function(z){loess.smooth(x = wl, y = specs[, z], #
           span = span, degree = 2, family = "gaussian", #
           evaluation = length(wl))$y})#
  applied <- c(applied, paste('smoothing spectra with a span of',span,'\n'))#
  }#
#
# if (any(opt=='smooth')&method=='spline')#
  # specs <- sapply(names(specs), function(z){smooth.spline(x = wl, y = specs[, z], #
           # spar = spar)$y})#
#
# if (any(opt=='smooth')&method=='loess')#
  # specs <- sapply(names(specs), function(z){loess.smooth(x = wl, y = specs[, z], #
           # span = span, degree = 2, family = "gaussian", #
           # evaluation = length(wl))$y})#
#
if (any(opt=='minimum')){#
  specs <- sapply(1:ncol(specs), function(z)specs[, z] - min(specs[, z]))#
   applied <- c(applied, 'Scaling spectra to a minimum value of zero\n')#
  }#
#
if (any(opt=='maximum')){#
  specs <- sapply(1:ncol(specs), function(z)specs[, z] / max(specs[, z]))#
   applied <- c(applied, 'Scaling spectra to a maximum value of 1\n')#
  }#
#
if (any(opt=='sum')){#
  specs <- sapply(1:ncol(specs), function(z)specs[, z] / sum(specs[, z]))#
   applied <- c(applied, 'Scaling spectra to a total area of 1\n')#
  }#
#
if (any(opt=='center')){#
  specs <- sapply(1:ncol(specs), function(z)specs[, z] - mean(specs[, z]))#
   applied <- c(applied, 'Centering spectra to a mean of zero\n')#
  }#
#
#	if (any(opt=='fix'))#
#		specs <- ...#
		# option 1 = set all negatives to zero#
		# option 2 = add absolute val of most neg value to all spectra#
		# option 3 = set negatives to NAs, then smooth?#
#
	# Calculate medians according to # of bins specified for use in PCA#
	# Method follows Cuthill et al. (1999)#
if (any(opt=='bin')) {#
  bw <- floor(length(wl)/bins)#
  wl_bin <- seq(head(wl,1), tail(wl,1), by=bw)#
  wl_ind <- match(wl_bin, wl)#
  specs <- sapply(1:(length(wl_ind)-1), function(z) #
                  apply(specs[wl_ind[z]:(wl_ind[z]+bw), ], 2, median))#
#
  specs <- as.data.frame(cbind(wl_bin[-length(wl_bin)], t(specs)))#
   applied <- c(applied, paste('binned spectra to ',bw,'-nm intervals\n',sep=''))#
  }else {#
    specs <- as.data.frame(cbind(wl, specs))#
    }#
class(specs) <- c('rspec', 'data.frame')#
#
cat(applied)#
specs#
}#
#
# testing zone#
#tmp <- procspec(rspecs)#
#tmp <- procspec(rspecs, f="stretch")#
#plot(tmp, p=8:15, type='h')
a=procspec(sicalis,opt=c('smooth','max'), fixneg='min')
specs = sicalis
sicalis
specs <- sapply(1:ncol(specs), function(z) specs[,z] + abs(min(specs[,z], na.rm=T)))
specs
procspec(sicalis,fixneg='min')
input an rspec object or data frame w/spectra in columns and wavelengths in rows#
# options = min, max, stretch, sum, bin, center (subtract avg. from all specs)#
#
# TODO#
# 1. add way to handle negatives#
#
procspec <- function(specs, opt = c('none', 'smooth', 'maximum', 'minimum', 'stretch', #
										 'bin', 'fix', 'sum', 'center'), #
										 fixneg = c('none', 'minimum', 'zero'),#
										 # method = c('loess', 'spline'), spar = .65, #
										 span = .15, bins = 20) {#
#
opt <- match.arg(opt, several.ok = TRUE)  	# 'fix' = how to handle negative values#
# method <- match.arg(method)#
#
fixneg <- match.arg(fixneg)#
#
applied <- 'processing options applied:\n'#
#
if (any(opt=='none')) {#
  print('No relevant processing option entered. Returning raw values') #
  specs#
  }#
wl_index <- which(names(specs)=='wl')#
if (length(wl_index > 0)){#
  wl <- specs[, wl_index]#
  specs <- specs[, -wl_index]#
    } else {#
    specs <- specs#
    }#
#
if(fixneg=='min'){#
  specs <- sapply(1:ncol(specs), function(z) specs[,z] + abs(min(specs[,z], na.rm=T)))#
  applied <- c(applied, 'Negative value correction: added min to all reflectance\n')#
 }#
if(fixneg=='zero'){#
  specs <- sapply(1:ncol(specs), function(z) specs[,z])#
  applied <- c(applied, 'Negative value correction: set to zero\n')#
}#
#
if (any(opt=='smooth')){#
  specs <- sapply(names(specs), function(z){loess.smooth(x = wl, y = specs[, z], #
           span = span, degree = 2, family = "gaussian", #
           evaluation = length(wl))$y})#
  applied <- c(applied, paste('smoothing spectra with a span of',span,'\n'))#
  }#
#
# if (any(opt=='smooth')&method=='spline')#
  # specs <- sapply(names(specs), function(z){smooth.spline(x = wl, y = specs[, z], #
           # spar = spar)$y})#
#
# if (any(opt=='smooth')&method=='loess')#
  # specs <- sapply(names(specs), function(z){loess.smooth(x = wl, y = specs[, z], #
           # span = span, degree = 2, family = "gaussian", #
           # evaluation = length(wl))$y})#
#
if (any(opt=='minimum')){#
  specs <- sapply(1:ncol(specs), function(z)specs[, z] - min(specs[, z]))#
   applied <- c(applied, 'Scaling spectra to a minimum value of zero\n')#
  }#
#
if (any(opt=='maximum')){#
  specs <- sapply(1:ncol(specs), function(z)specs[, z] / max(specs[, z]))#
   applied <- c(applied, 'Scaling spectra to a maximum value of 1\n')#
  }#
#
if (any(opt=='sum')){#
  specs <- sapply(1:ncol(specs), function(z)specs[, z] / sum(specs[, z]))#
   applied <- c(applied, 'Scaling spectra to a total area of 1\n')#
  }#
#
if (any(opt=='center')){#
  specs <- sapply(1:ncol(specs), function(z)specs[, z] - mean(specs[, z]))#
   applied <- c(applied, 'Centering spectra to a mean of zero\n')#
  }#
#
#	if (any(opt=='fix'))#
#		specs <- ...#
		# option 1 = set all negatives to zero#
		# option 2 = add absolute val of most neg value to all spectra#
		# option 3 = set negatives to NAs, then smooth?#
#
	# Calculate medians according to # of bins specified for use in PCA#
	# Method follows Cuthill et al. (1999)#
if (any(opt=='bin')) {#
  bw <- floor(length(wl)/bins)#
  wl_bin <- seq(head(wl,1), tail(wl,1), by=bw)#
  wl_ind <- match(wl_bin, wl)#
  specs <- sapply(1:(length(wl_ind)-1), function(z) #
                  apply(specs[wl_ind[z]:(wl_ind[z]+bw), ], 2, median))#
#
  specs <- as.data.frame(cbind(wl_bin[-length(wl_bin)], t(specs)))#
   applied <- c(applied, paste('binned spectra to ',bw,'-nm intervals\n',sep=''))#
  }else {#
    specs <- as.data.frame(cbind(wl, specs))#
    }#
class(specs) <- c('rspec', 'data.frame')#
#
cat(applied)#
specs#
}#
#
# testing zone#
#tmp <- procspec(rspecs)#
#tmp <- procspec(rspecs, f="stretch")#
#plot(tmp, p=8:15, type='h')
procspec(sicalis,fixneg='min')
procspec(sicalis,fixneg='min')
procspec(sicalis,opt='none',fixneg='min')
procspec(sicalis,opt='none',fixneg='min')
apply(procspec(sic,opt='none',fixneg='min'),2,min)
apply(procspec(sic,opt='smooth',fixneg='min'),2,min)
apply(procspec(sic,opt='smooth',fixneg='minimum'),2,min)
input an rspec object or data frame w/spectra in columns and wavelengths in rows#
# options = min, max, stretch, sum, bin, center (subtract avg. from all specs)#
#
# TODO#
# 1. add way to handle negatives#
#
procspec <- function(specs, opt = c('none', 'smooth', 'maximum', 'minimum', 'stretch', #
										 'bin', 'fix', 'sum', 'center'), #
										 fixneg = c('none', 'minimum', 'zero'),#
										 # method = c('loess', 'spline'), spar = .65, #
										 span = .15, bins = 20) {#
#
opt <- match.arg(opt, several.ok = TRUE)  	# 'fix' = how to handle negative values#
# method <- match.arg(method)#
#
fixneg <- match.arg(fixneg)#
#
applied <- 'processing options applied:\n'#
#
if (any(opt=='none')) {#
  print('No relevant processing option entered. Returning raw values') #
  specs#
  }#
wl_index <- which(names(specs)=='wl')#
if (length(wl_index > 0)){#
  wl <- specs[, wl_index]#
  specs <- specs[, -wl_index]#
    } else {#
    specs <- specs#
    }#
#
if(fixneg=='min'){#
  specs <- sapply(1:ncol(specs), function(z) specs[,z] - min(specs[, z]))#
  applied <- c(applied, 'Negative value correction: added min to all reflectance\n')#
 }#
if(fixneg=='zero'){#
  specs <- sapply(1:ncol(specs), function(z) specs[,z])#
  applied <- c(applied, 'Negative value correction: set to zero\n')#
}#
#
if (any(opt=='smooth')){#
  specs <- sapply(names(specs), function(z){loess.smooth(x = wl, y = specs[, z], #
           span = span, degree = 2, family = "gaussian", #
           evaluation = length(wl))$y})#
  applied <- c(applied, paste('smoothing spectra with a span of',span,'\n'))#
  }#
#
# if (any(opt=='smooth')&method=='spline')#
  # specs <- sapply(names(specs), function(z){smooth.spline(x = wl, y = specs[, z], #
           # spar = spar)$y})#
#
# if (any(opt=='smooth')&method=='loess')#
  # specs <- sapply(names(specs), function(z){loess.smooth(x = wl, y = specs[, z], #
           # span = span, degree = 2, family = "gaussian", #
           # evaluation = length(wl))$y})#
#
if (any(opt=='minimum')){#
  specs <- sapply(1:ncol(specs), function(z)specs[, z] - min(specs[, z]))#
   applied <- c(applied, 'Scaling spectra to a minimum value of zero\n')#
  }#
#
if (any(opt=='maximum')){#
  specs <- sapply(1:ncol(specs), function(z)specs[, z] / max(specs[, z]))#
   applied <- c(applied, 'Scaling spectra to a maximum value of 1\n')#
  }#
#
if (any(opt=='sum')){#
  specs <- sapply(1:ncol(specs), function(z)specs[, z] / sum(specs[, z]))#
   applied <- c(applied, 'Scaling spectra to a total area of 1\n')#
  }#
#
if (any(opt=='center')){#
  specs <- sapply(1:ncol(specs), function(z)specs[, z] - mean(specs[, z]))#
   applied <- c(applied, 'Centering spectra to a mean of zero\n')#
  }#
#
#	if (any(opt=='fix'))#
#		specs <- ...#
		# option 1 = set all negatives to zero#
		# option 2 = add absolute val of most neg value to all spectra#
		# option 3 = set negatives to NAs, then smooth?#
#
	# Calculate medians according to # of bins specified for use in PCA#
	# Method follows Cuthill et al. (1999)#
if (any(opt=='bin')) {#
  bw <- floor(length(wl)/bins)#
  wl_bin <- seq(head(wl,1), tail(wl,1), by=bw)#
  wl_ind <- match(wl_bin, wl)#
  specs <- sapply(1:(length(wl_ind)-1), function(z) #
                  apply(specs[wl_ind[z]:(wl_ind[z]+bw), ], 2, median))#
#
  specs <- as.data.frame(cbind(wl_bin[-length(wl_bin)], t(specs)))#
   applied <- c(applied, paste('binned spectra to ',bw,'-nm intervals\n',sep=''))#
  }else {#
    specs <- as.data.frame(cbind(wl, specs))#
    }#
class(specs) <- c('rspec', 'data.frame')#
#
cat(applied)#
specs#
}#
#
# testing zone#
#tmp <- procspec(rspecs)#
#tmp <- procspec(rspecs, f="stretch")#
#plot(tmp, p=8:15, type='h')
apply(procspec(sic,opt='smooth',fixneg='minimum'),2,min)
input an rspec object or data frame w/spectra in columns and wavelengths in rows#
# options = min, max, stretch, sum, bin, center (subtract avg. from all specs)#
#
# TODO#
# 1. add way to handle negatives#
#
procspec <- function(specs, opt = c('none', 'smooth', 'maximum', 'minimum', 'stretch', #
										 'bin', 'fix', 'sum', 'center'), #
										 fixneg = c('none', 'minimum', 'zero'),#
										 # method = c('loess', 'spline'), spar = .65, #
										 span = .15, bins = 20) {#
#
opt <- match.arg(opt, several.ok = TRUE)  	# 'fix' = how to handle negative values#
# method <- match.arg(method)#
#
fixneg <- match.arg(fixneg)#
#
applied <- 'processing options applied:\n'#
#
if (any(opt=='none')) {#
  print('No relevant processing option entered. Returning raw values') #
  specs#
  }#
wl_index <- which(names(specs)=='wl')#
if (length(wl_index > 0)){#
  wl <- specs[, wl_index]#
  specs <- specs[, -wl_index]#
    } else {#
    specs <- specs#
    }#
#
if(fixneg=='minimum'){#
  specs <- sapply(1:ncol(specs), function(z) specs[,z] - min(specs[, z]))#
  applied <- c(applied, 'Negative value correction: added min to all reflectance\n')#
 }#
if(fixneg=='zero'){#
  specs <- sapply(1:ncol(specs), function(z) specs[,z])#
  applied <- c(applied, 'Negative value correction: set to zero\n')#
}#
#
if (any(opt=='smooth')){#
  specs <- sapply(names(specs), function(z){loess.smooth(x = wl, y = specs[, z], #
           span = span, degree = 2, family = "gaussian", #
           evaluation = length(wl))$y})#
  applied <- c(applied, paste('smoothing spectra with a span of',span,'\n'))#
  }#
#
# if (any(opt=='smooth')&method=='spline')#
  # specs <- sapply(names(specs), function(z){smooth.spline(x = wl, y = specs[, z], #
           # spar = spar)$y})#
#
# if (any(opt=='smooth')&method=='loess')#
  # specs <- sapply(names(specs), function(z){loess.smooth(x = wl, y = specs[, z], #
           # span = span, degree = 2, family = "gaussian", #
           # evaluation = length(wl))$y})#
#
if (any(opt=='minimum')){#
  specs <- sapply(1:ncol(specs), function(z)specs[, z] - min(specs[, z]))#
   applied <- c(applied, 'Scaling spectra to a minimum value of zero\n')#
  }#
#
if (any(opt=='maximum')){#
  specs <- sapply(1:ncol(specs), function(z)specs[, z] / max(specs[, z]))#
   applied <- c(applied, 'Scaling spectra to a maximum value of 1\n')#
  }#
#
if (any(opt=='sum')){#
  specs <- sapply(1:ncol(specs), function(z)specs[, z] / sum(specs[, z]))#
   applied <- c(applied, 'Scaling spectra to a total area of 1\n')#
  }#
#
if (any(opt=='center')){#
  specs <- sapply(1:ncol(specs), function(z)specs[, z] - mean(specs[, z]))#
   applied <- c(applied, 'Centering spectra to a mean of zero\n')#
  }#
#
#	if (any(opt=='fix'))#
#		specs <- ...#
		# option 1 = set all negatives to zero#
		# option 2 = add absolute val of most neg value to all spectra#
		# option 3 = set negatives to NAs, then smooth?#
#
	# Calculate medians according to # of bins specified for use in PCA#
	# Method follows Cuthill et al. (1999)#
if (any(opt=='bin')) {#
  bw <- floor(length(wl)/bins)#
  wl_bin <- seq(head(wl,1), tail(wl,1), by=bw)#
  wl_ind <- match(wl_bin, wl)#
  specs <- sapply(1:(length(wl_ind)-1), function(z) #
                  apply(specs[wl_ind[z]:(wl_ind[z]+bw), ], 2, median))#
#
  specs <- as.data.frame(cbind(wl_bin[-length(wl_bin)], t(specs)))#
   applied <- c(applied, paste('binned spectra to ',bw,'-nm intervals\n',sep=''))#
  }else {#
    specs <- as.data.frame(cbind(wl, specs))#
    }#
class(specs) <- c('rspec', 'data.frame')#
#
cat(applied)#
specs#
}#
#
# testing zone#
#tmp <- procspec(rspecs)#
#tmp <- procspec(rspecs, f="stretch")#
#plot(tmp, p=8:15, type='h')
apply(procspec(sic,opt='smooth',fixneg='minimum'),2,min)
input an rspec object or data frame w/spectra in columns and wavelengths in rows#
# options = min, max, stretch, sum, bin, center (subtract avg. from all specs)#
#
# TODO#
# 1. add way to handle negatives#
#
procspec <- function(specs, opt = c('none', 'smooth', 'maximum', 'minimum', 'stretch', #
										 'bin', 'fix', 'sum', 'center'), #
										 fixneg = c('none', 'minimum', 'zero'),#
										 # method = c('loess', 'spline'), spar = .65, #
										 span = .15, bins = 20) {#
#
opt <- match.arg(opt, several.ok = TRUE)  	# 'fix' = how to handle negative values#
# method <- match.arg(method)#
#
fixneg <- match.arg(fixneg)#
#
applied <- 'processing options applied:\n'#
#
if (any(opt=='none')) {#
  print('No relevant processing option entered. Returning raw values') #
  specs#
  }#
wl_index <- which(names(specs)=='wl')#
if (length(wl_index > 0)){#
  wl <- specs[, wl_index]#
  specs <- specs[, -wl_index]#
    } else {#
    specs <- specs#
    }#
#
if(fixneg=='minimum'){#
  specs <- sapply(1:ncol(specs), function(z)specs[, z] - min(specs[, z]))#
  applied <- c(applied, 'Negative value correction: added min to all reflectance\n')#
 }#
if(fixneg=='zero'){#
  specs <- sapply(1:ncol(specs), function(z) specs[,z])#
  applied <- c(applied, 'Negative value correction: set to zero\n')#
}#
#
if (any(opt=='smooth')){#
  specs <- sapply(names(specs), function(z){loess.smooth(x = wl, y = specs[, z], #
           span = span, degree = 2, family = "gaussian", #
           evaluation = length(wl))$y})#
  applied <- c(applied, paste('smoothing spectra with a span of',span,'\n'))#
  }#
#
# if (any(opt=='smooth')&method=='spline')#
  # specs <- sapply(names(specs), function(z){smooth.spline(x = wl, y = specs[, z], #
           # spar = spar)$y})#
#
# if (any(opt=='smooth')&method=='loess')#
  # specs <- sapply(names(specs), function(z){loess.smooth(x = wl, y = specs[, z], #
           # span = span, degree = 2, family = "gaussian", #
           # evaluation = length(wl))$y})#
#
if (any(opt=='minimum')){#
  specs <- sapply(1:ncol(specs), function(z)specs[, z] - min(specs[, z]))#
   applied <- c(applied, 'Scaling spectra to a minimum value of zero\n')#
  }#
#
if (any(opt=='maximum')){#
  specs <- sapply(1:ncol(specs), function(z)specs[, z] / max(specs[, z]))#
   applied <- c(applied, 'Scaling spectra to a maximum value of 1\n')#
  }#
#
if (any(opt=='sum')){#
  specs <- sapply(1:ncol(specs), function(z)specs[, z] / sum(specs[, z]))#
   applied <- c(applied, 'Scaling spectra to a total area of 1\n')#
  }#
#
if (any(opt=='center')){#
  specs <- sapply(1:ncol(specs), function(z)specs[, z] - mean(specs[, z]))#
   applied <- c(applied, 'Centering spectra to a mean of zero\n')#
  }#
#
#	if (any(opt=='fix'))#
#		specs <- ...#
		# option 1 = set all negatives to zero#
		# option 2 = add absolute val of most neg value to all spectra#
		# option 3 = set negatives to NAs, then smooth?#
#
	# Calculate medians according to # of bins specified for use in PCA#
	# Method follows Cuthill et al. (1999)#
if (any(opt=='bin')) {#
  bw <- floor(length(wl)/bins)#
  wl_bin <- seq(head(wl,1), tail(wl,1), by=bw)#
  wl_ind <- match(wl_bin, wl)#
  specs <- sapply(1:(length(wl_ind)-1), function(z) #
                  apply(specs[wl_ind[z]:(wl_ind[z]+bw), ], 2, median))#
#
  specs <- as.data.frame(cbind(wl_bin[-length(wl_bin)], t(specs)))#
   applied <- c(applied, paste('binned spectra to ',bw,'-nm intervals\n',sep=''))#
  }else {#
    specs <- as.data.frame(cbind(wl, specs))#
    }#
class(specs) <- c('rspec', 'data.frame')#
#
cat(applied)#
specs#
}#
#
# testing zone#
#tmp <- procspec(rspecs)#
#tmp <- procspec(rspecs, f="stretch")#
#plot(tmp, p=8:15, type='h')
apply(procspec(sic,opt='smooth',fixneg='minimum'),2,min)
procspec(sic,opt='smooth',fixneg='minimum'),2,min
procspec(sic,opt='smooth',fixneg='minimum')
class(procspec(sic,opt='smooth',fixneg='minimum')()
class(procspec(sic,opt='smooth',fixneg='minimum'))
apply(procspec(sic,opt='smooth',fixneg='minimum'),2,min)
colMax(procspec(sic,opt='smooth',fixneg='minimum'))
apply(procspec(sic,opt='smooth',fixneg='minimum'),2,sum)
procspec(sic,opt='smooth',fixneg='minimum')
procspec(sic,opt='minimum')
input an rspec object or data frame w/spectra in columns and wavelengths in rows#
# options = min, max, stretch, sum, bin, center (subtract avg. from all specs)#
#
# TODO#
# 1. add way to handle negatives#
#
procspec <- function(specs, opt = c('none', 'smooth', 'maximum', 'minimum', 'stretch', #
										 'bin', 'fix', 'sum', 'center'), #
										 fixneg = c('none', 'A', 'zero'),#
										 # method = c('loess', 'spline'), spar = .65, #
										 span = .15, bins = 20) {#
#
opt <- match.arg(opt, several.ok = TRUE)  	# 'fix' = how to handle negative values#
# method <- match.arg(method)#
#
fixneg <- match.arg(fixneg)#
#
applied <- 'processing options applied:\n'#
#
if (any(opt=='none')) {#
  print('No relevant processing option entered. Returning raw values') #
  specs#
  }#
wl_index <- which(names(specs)=='wl')#
if (length(wl_index > 0)){#
  wl <- specs[, wl_index]#
  specs <- specs[, -wl_index]#
    } else {#
    specs <- specs#
    }#
#
if(fixneg=='A'){#
  specs <- sapply(1:ncol(specs), function(z)specs[, z] - min(specs[, z]))#
  applied <- c(applied, 'Negative value correction: added min to all reflectance\n')#
 }#
if(fixneg=='zero'){#
  specs <- sapply(1:ncol(specs), function(z) specs[,z])#
  applied <- c(applied, 'Negative value correction: set to zero\n')#
}#
#
if (any(opt=='smooth')){#
  specs <- sapply(names(specs), function(z){loess.smooth(x = wl, y = specs[, z], #
           span = span, degree = 2, family = "gaussian", #
           evaluation = length(wl))$y})#
  applied <- c(applied, paste('smoothing spectra with a span of',span,'\n'))#
  }#
#
# if (any(opt=='smooth')&method=='spline')#
  # specs <- sapply(names(specs), function(z){smooth.spline(x = wl, y = specs[, z], #
           # spar = spar)$y})#
#
# if (any(opt=='smooth')&method=='loess')#
  # specs <- sapply(names(specs), function(z){loess.smooth(x = wl, y = specs[, z], #
           # span = span, degree = 2, family = "gaussian", #
           # evaluation = length(wl))$y})#
#
if (any(opt=='minimum')){#
  specs <- sapply(1:ncol(specs), function(z)specs[, z] - min(specs[, z]))#
   applied <- c(applied, 'Scaling spectra to a minimum value of zero\n')#
  }#
#
if (any(opt=='maximum')){#
  specs <- sapply(1:ncol(specs), function(z)specs[, z] / max(specs[, z]))#
   applied <- c(applied, 'Scaling spectra to a maximum value of 1\n')#
  }#
#
if (any(opt=='sum')){#
  specs <- sapply(1:ncol(specs), function(z)specs[, z] / sum(specs[, z]))#
   applied <- c(applied, 'Scaling spectra to a total area of 1\n')#
  }#
#
if (any(opt=='center')){#
  specs <- sapply(1:ncol(specs), function(z)specs[, z] - mean(specs[, z]))#
   applied <- c(applied, 'Centering spectra to a mean of zero\n')#
  }#
#
#	if (any(opt=='fix'))#
#		specs <- ...#
		# option 1 = set all negatives to zero#
		# option 2 = add absolute val of most neg value to all spectra#
		# option 3 = set negatives to NAs, then smooth?#
#
	# Calculate medians according to # of bins specified for use in PCA#
	# Method follows Cuthill et al. (1999)#
if (any(opt=='bin')) {#
  bw <- floor(length(wl)/bins)#
  wl_bin <- seq(head(wl,1), tail(wl,1), by=bw)#
  wl_ind <- match(wl_bin, wl)#
  specs <- sapply(1:(length(wl_ind)-1), function(z) #
                  apply(specs[wl_ind[z]:(wl_ind[z]+bw), ], 2, median))#
#
  specs <- as.data.frame(cbind(wl_bin[-length(wl_bin)], t(specs)))#
   applied <- c(applied, paste('binned spectra to ',bw,'-nm intervals\n',sep=''))#
  }else {#
    specs <- as.data.frame(cbind(wl, specs))#
    }#
class(specs) <- c('rspec', 'data.frame')#
#
cat(applied)#
specs#
}#
#
# testing zone#
#tmp <- procspec(rspecs)#
#tmp <- procspec(rspecs, f="stretch")#
#plot(tmp, p=8:15, type='h')
procspec(sic,opt='minimum', fixneg='A')
aa=procspec(sic,opt='minimum', fixneg='A')
input an rspec object or data frame w/spectra in columns and wavelengths in rows#
# options = min, max, stretch, sum, bin, center (subtract avg. from all specs)#
#
# TODO#
# 1. add way to handle negatives#
#
procspec <- function(specs, opt = c('none', 'smooth', 'maximum', 'minimum', 'stretch', #
										 'bin', 'fix', 'sum', 'center'), #
										 fixneg = c('none', 'addmin', 'zero'),#
										 # method = c('loess', 'spline'), spar = .65, #
										 span = .15, bins = 20) {#
#
opt <- match.arg(opt, several.ok = TRUE)  	# 'fix' = how to handle negative values#
# method <- match.arg(method)#
#
fixneg <- match.arg(fixneg)#
#
applied <- 'processing options applied:\n'#
#
if (any(opt=='none')) {#
  print('No relevant processing option entered. Returning raw values') #
  specs#
  }#
wl_index <- which(names(specs)=='wl')#
if (length(wl_index > 0)){#
  wl <- specs[, wl_index]#
  specs <- specs[, -wl_index]#
    } else {#
    specs <- specs#
    }#
#
if(fixneg=='addmin'){#
  specs <- sapply(1:ncol(specs), function(z)specs[, z] - min(specs[, z]))#
  applied <- c(applied, 'Negative value correction: added min to all reflectance\n')#
 }#
if(fixneg=='zero'){#
  specs <- sapply(1:ncol(specs), function(z) specs[,z])#
  applied <- c(applied, 'Negative value correction: set to zero\n')#
}#
#
if (any(opt=='smooth')){#
  specs <- sapply(names(specs), function(z){loess.smooth(x = wl, y = specs[, z], #
           span = span, degree = 2, family = "gaussian", #
           evaluation = length(wl))$y})#
  applied <- c(applied, paste('smoothing spectra with a span of',span,'\n'))#
  }#
#
# if (any(opt=='smooth')&method=='spline')#
  # specs <- sapply(names(specs), function(z){smooth.spline(x = wl, y = specs[, z], #
           # spar = spar)$y})#
#
# if (any(opt=='smooth')&method=='loess')#
  # specs <- sapply(names(specs), function(z){loess.smooth(x = wl, y = specs[, z], #
           # span = span, degree = 2, family = "gaussian", #
           # evaluation = length(wl))$y})#
#
if (any(opt=='minimum')){#
  specs <- sapply(1:ncol(specs), function(z)specs[, z] - min(specs[, z]))#
   applied <- c(applied, 'Scaling spectra to a minimum value of zero\n')#
  }#
#
if (any(opt=='maximum')){#
  specs <- sapply(1:ncol(specs), function(z)specs[, z] / max(specs[, z]))#
   applied <- c(applied, 'Scaling spectra to a maximum value of 1\n')#
  }#
#
if (any(opt=='sum')){#
  specs <- sapply(1:ncol(specs), function(z)specs[, z] / sum(specs[, z]))#
   applied <- c(applied, 'Scaling spectra to a total area of 1\n')#
  }#
#
if (any(opt=='center')){#
  specs <- sapply(1:ncol(specs), function(z)specs[, z] - mean(specs[, z]))#
   applied <- c(applied, 'Centering spectra to a mean of zero\n')#
  }#
#
#	if (any(opt=='fix'))#
#		specs <- ...#
		# option 1 = set all negatives to zero#
		# option 2 = add absolute val of most neg value to all spectra#
		# option 3 = set negatives to NAs, then smooth?#
#
	# Calculate medians according to # of bins specified for use in PCA#
	# Method follows Cuthill et al. (1999)#
if (any(opt=='bin')) {#
  bw <- floor(length(wl)/bins)#
  wl_bin <- seq(head(wl,1), tail(wl,1), by=bw)#
  wl_ind <- match(wl_bin, wl)#
  specs <- sapply(1:(length(wl_ind)-1), function(z) #
                  apply(specs[wl_ind[z]:(wl_ind[z]+bw), ], 2, median))#
#
  specs <- as.data.frame(cbind(wl_bin[-length(wl_bin)], t(specs)))#
   applied <- c(applied, paste('binned spectra to ',bw,'-nm intervals\n',sep=''))#
  }else {#
    specs <- as.data.frame(cbind(wl, specs))#
    }#
class(specs) <- c('rspec', 'data.frame')#
#
cat(applied)#
specs#
}#
#
# testing zone#
#tmp <- procspec(rspecs)#
#tmp <- procspec(rspecs, f="stretch")#
#plot(tmp, p=8:15, type='h')
aa=procspec(sic,opt='minimum', fixneg='addmin')
aa=procspec(sic,opt='minimum', fixneg='zero')
aa
aa=procspec(sic,opt='minimum', fixneg='addmin')
aa
input an rspec object or data frame w/spectra in columns and wavelengths in rows#
# options = min, max, stretch, sum, bin, center (subtract avg. from all specs)#
#
# TODO#
# 1. add way to handle negatives#
#
procspec <- function(specs, opt = c('none', 'smooth', 'maximum', 'minimum', 'stretch', #
										 'bin', 'fix', 'sum', 'center'), #
										 fixneg = c('none', 'addmin', 'zero'),#
										 # method = c('loess', 'spline'), spar = .65, #
										 span = .15, bins = 20) {#
#
opt <- match.arg(opt, several.ok = TRUE)  	# 'fix' = how to handle negative values#
# method <- match.arg(method)#
#
fixneg <- match.arg(fixneg)#
#
applied <- 'processing options applied:\n'#
#
if (any(opt=='none')) {#
  cat('No relevant processing option entered. Returning raw values\n') #
  specs#
  }#
wl_index <- which(names(specs)=='wl')#
if (length(wl_index > 0)){#
  wl <- specs[, wl_index]#
  specs <- specs[, -wl_index]#
    } else {#
    specs <- specs#
    }#
#
if(fixneg=='addmin'){#
  specs <- sapply(1:ncol(specs), function(z)#
           ifelse(min(specs[,z] < 0, specs[, z] + abs(min(specs[, z])), specs[,z]) )#
  applied <- c(applied, 'Negative value correction: added min to all reflectance\n')#
 }#
if(fixneg=='zero'){#
  specs <- sapply(1:ncol(specs), function(z) specs[,z])#
  applied <- c(applied, 'Negative value correction: set to zero\n')#
}#
#
if (any(opt=='smooth')){#
  specs <- sapply(names(specs), function(z){loess.smooth(x = wl, y = specs[, z], #
           span = span, degree = 2, family = "gaussian", #
           evaluation = length(wl))$y})#
  applied <- c(applied, paste('smoothing spectra with a span of',span,'\n'))#
  }#
#
# if (any(opt=='smooth')&method=='spline')#
  # specs <- sapply(names(specs), function(z){smooth.spline(x = wl, y = specs[, z], #
           # spar = spar)$y})#
#
# if (any(opt=='smooth')&method=='loess')#
  # specs <- sapply(names(specs), function(z){loess.smooth(x = wl, y = specs[, z], #
           # span = span, degree = 2, family = "gaussian", #
           # evaluation = length(wl))$y})#
#
if (any(opt=='minimum')){#
  specs <- sapply(1:ncol(specs), function(z)specs[, z] - min(specs[, z]))#
   applied <- c(applied, 'Scaling spectra to a minimum value of zero\n')#
  }#
#
if (any(opt=='maximum')){#
  specs <- sapply(1:ncol(specs), function(z)specs[, z] / max(specs[, z]))#
   applied <- c(applied, 'Scaling spectra to a maximum value of 1\n')#
  }#
#
if (any(opt=='sum')){#
  specs <- sapply(1:ncol(specs), function(z)specs[, z] / sum(specs[, z]))#
   applied <- c(applied, 'Scaling spectra to a total area of 1\n')#
  }#
#
if (any(opt=='center')){#
  specs <- sapply(1:ncol(specs), function(z)specs[, z] - mean(specs[, z]))#
   applied <- c(applied, 'Centering spectra to a mean of zero\n')#
  }#
#
#	if (any(opt=='fix'))#
#		specs <- ...#
		# option 1 = set all negatives to zero#
		# option 2 = add absolute val of most neg value to all spectra#
		# option 3 = set negatives to NAs, then smooth?#
#
	# Calculate medians according to # of bins specified for use in PCA#
	# Method follows Cuthill et al. (1999)#
if (any(opt=='bin')) {#
  bw <- floor(length(wl)/bins)#
  wl_bin <- seq(head(wl,1), tail(wl,1), by=bw)#
  wl_ind <- match(wl_bin, wl)#
  specs <- sapply(1:(length(wl_ind)-1), function(z) #
                  apply(specs[wl_ind[z]:(wl_ind[z]+bw), ], 2, median))#
#
  specs <- as.data.frame(cbind(wl_bin[-length(wl_bin)], t(specs)))#
   applied <- c(applied, paste('binned spectra to ',bw,'-nm intervals\n',sep=''))#
  }else {#
    specs <- as.data.frame(cbind(wl, specs))#
    }#
class(specs) <- c('rspec', 'data.frame')#
#
cat(applied)#
specs#
}#
#
# testing zone#
#tmp <- procspec(rspecs)#
#tmp <- procspec(rspecs, f="stretch")#
#plot(tmp, p=8:15, type='h')
input an rspec object or data frame w/spectra in columns and wavelengths in rows#
# options = min, max, stretch, sum, bin, center (subtract avg. from all specs)#
#
# TODO#
# 1. add way to handle negatives#
#
procspec <- function(specs, opt = c('none', 'smooth', 'maximum', 'minimum', 'stretch', #
										 'bin', 'fix', 'sum', 'center'), #
										 fixneg = c('none', 'addmin', 'zero'),#
										 # method = c('loess', 'spline'), spar = .65, #
										 span = .15, bins = 20) {#
#
opt <- match.arg(opt, several.ok = TRUE)  	# 'fix' = how to handle negative values#
# method <- match.arg(method)#
#
fixneg <- match.arg(fixneg)#
#
applied <- 'processing options applied:\n'#
#
if (any(opt=='none')) {#
  cat('No relevant processing option entered. Returning raw values\n') #
  specs#
  }#
wl_index <- which(names(specs)=='wl')#
if (length(wl_index > 0)){#
  wl <- specs[, wl_index]#
  specs <- specs[, -wl_index]#
    } else {#
    specs <- specs#
    }#
#
if(fixneg=='addmin'){#
  specs <- sapply(1:ncol(specs), function(z)#
           ifelse(min(specs[,z] < 0), specs[, z] + abs(min(specs[, z])), specs[,z]) )#
  applied <- c(applied, 'Negative value correction: added min to all reflectance\n')#
 }#
if(fixneg=='zero'){#
  specs <- sapply(1:ncol(specs), function(z) specs[,z])#
  applied <- c(applied, 'Negative value correction: set to zero\n')#
}#
#
if (any(opt=='smooth')){#
  specs <- sapply(names(specs), function(z){loess.smooth(x = wl, y = specs[, z], #
           span = span, degree = 2, family = "gaussian", #
           evaluation = length(wl))$y})#
  applied <- c(applied, paste('smoothing spectra with a span of',span,'\n'))#
  }#
#
# if (any(opt=='smooth')&method=='spline')#
  # specs <- sapply(names(specs), function(z){smooth.spline(x = wl, y = specs[, z], #
           # spar = spar)$y})#
#
# if (any(opt=='smooth')&method=='loess')#
  # specs <- sapply(names(specs), function(z){loess.smooth(x = wl, y = specs[, z], #
           # span = span, degree = 2, family = "gaussian", #
           # evaluation = length(wl))$y})#
#
if (any(opt=='minimum')){#
  specs <- sapply(1:ncol(specs), function(z)specs[, z] - min(specs[, z]))#
   applied <- c(applied, 'Scaling spectra to a minimum value of zero\n')#
  }#
#
if (any(opt=='maximum')){#
  specs <- sapply(1:ncol(specs), function(z)specs[, z] / max(specs[, z]))#
   applied <- c(applied, 'Scaling spectra to a maximum value of 1\n')#
  }#
#
if (any(opt=='sum')){#
  specs <- sapply(1:ncol(specs), function(z)specs[, z] / sum(specs[, z]))#
   applied <- c(applied, 'Scaling spectra to a total area of 1\n')#
  }#
#
if (any(opt=='center')){#
  specs <- sapply(1:ncol(specs), function(z)specs[, z] - mean(specs[, z]))#
   applied <- c(applied, 'Centering spectra to a mean of zero\n')#
  }#
#
#	if (any(opt=='fix'))#
#		specs <- ...#
		# option 1 = set all negatives to zero#
		# option 2 = add absolute val of most neg value to all spectra#
		# option 3 = set negatives to NAs, then smooth?#
#
	# Calculate medians according to # of bins specified for use in PCA#
	# Method follows Cuthill et al. (1999)#
if (any(opt=='bin')) {#
  bw <- floor(length(wl)/bins)#
  wl_bin <- seq(head(wl,1), tail(wl,1), by=bw)#
  wl_ind <- match(wl_bin, wl)#
  specs <- sapply(1:(length(wl_ind)-1), function(z) #
                  apply(specs[wl_ind[z]:(wl_ind[z]+bw), ], 2, median))#
#
  specs <- as.data.frame(cbind(wl_bin[-length(wl_bin)], t(specs)))#
   applied <- c(applied, paste('binned spectra to ',bw,'-nm intervals\n',sep=''))#
  }else {#
    specs <- as.data.frame(cbind(wl, specs))#
    }#
class(specs) <- c('rspec', 'data.frame')#
#
cat(applied)#
specs#
}#
#
# testing zone#
#tmp <- procspec(rspecs)#
#tmp <- procspec(rspecs, f="stretch")#
#plot(tmp, p=8:15, type='h')
ls()
rm(list=ls())
data(sicalis)
input an rspec object or data frame w/spectra in columns and wavelengths in rows#
# options = min, max, stretch, sum, bin, center (subtract avg. from all specs)#
#
# TODO#
# 1. add way to handle negatives#
#
procspec <- function(specs, opt = c('none', 'smooth', 'maximum', 'minimum', 'stretch', #
										 'bin', 'fix', 'sum', 'center'), #
										 fixneg = c('none', 'addmin', 'zero'),#
										 # method = c('loess', 'spline'), spar = .65, #
										 span = .15, bins = 20) {#
#
opt <- match.arg(opt, several.ok = TRUE)  	# 'fix' = how to handle negative values#
# method <- match.arg(method)#
#
fixneg <- match.arg(fixneg)#
#
applied <- 'processing options applied:\n'#
#
if (any(opt=='none')) {#
  cat('No relevant processing option entered. Returning raw values\n') #
  specs#
  }#
wl_index <- which(names(specs)=='wl')#
if (length(wl_index > 0)){#
  wl <- specs[, wl_index]#
  specs <- specs[, -wl_index]#
    } else {#
    specs <- specs#
    }#
#
if(fixneg=='addmin'){#
  specs <- sapply(1:ncol(specs), function(z)#
           ifelse(min(specs[,z] < 0), specs[, z] + abs(min(specs[, z])), specs[,z]) )#
  applied <- c(applied, 'Negative value correction: added min to all reflectance\n')#
 }#
if(fixneg=='zero'){#
  specs <- sapply(1:ncol(specs), function(z) specs[,z])#
  applied <- c(applied, 'Negative value correction: set to zero\n')#
}#
#
if (any(opt=='smooth')){#
  specs <- sapply(names(specs), function(z){loess.smooth(x = wl, y = specs[, z], #
           span = span, degree = 2, family = "gaussian", #
           evaluation = length(wl))$y})#
  applied <- c(applied, paste('smoothing spectra with a span of',span,'\n'))#
  }#
#
# if (any(opt=='smooth')&method=='spline')#
  # specs <- sapply(names(specs), function(z){smooth.spline(x = wl, y = specs[, z], #
           # spar = spar)$y})#
#
# if (any(opt=='smooth')&method=='loess')#
  # specs <- sapply(names(specs), function(z){loess.smooth(x = wl, y = specs[, z], #
           # span = span, degree = 2, family = "gaussian", #
           # evaluation = length(wl))$y})#
#
if (any(opt=='minimum')){#
  specs <- sapply(1:ncol(specs), function(z)specs[, z] - min(specs[, z]))#
   applied <- c(applied, 'Scaling spectra to a minimum value of zero\n')#
  }#
#
if (any(opt=='maximum')){#
  specs <- sapply(1:ncol(specs), function(z)specs[, z] / max(specs[, z]))#
   applied <- c(applied, 'Scaling spectra to a maximum value of 1\n')#
  }#
#
if (any(opt=='sum')){#
  specs <- sapply(1:ncol(specs), function(z)specs[, z] / sum(specs[, z]))#
   applied <- c(applied, 'Scaling spectra to a total area of 1\n')#
  }#
#
if (any(opt=='center')){#
  specs <- sapply(1:ncol(specs), function(z)specs[, z] - mean(specs[, z]))#
   applied <- c(applied, 'Centering spectra to a mean of zero\n')#
  }#
#
#	if (any(opt=='fix'))#
#		specs <- ...#
		# option 1 = set all negatives to zero#
		# option 2 = add absolute val of most neg value to all spectra#
		# option 3 = set negatives to NAs, then smooth?#
#
	# Calculate medians according to # of bins specified for use in PCA#
	# Method follows Cuthill et al. (1999)#
if (any(opt=='bin')) {#
  bw <- floor(length(wl)/bins)#
  wl_bin <- seq(head(wl,1), tail(wl,1), by=bw)#
  wl_ind <- match(wl_bin, wl)#
  specs <- sapply(1:(length(wl_ind)-1), function(z) #
                  apply(specs[wl_ind[z]:(wl_ind[z]+bw), ], 2, median))#
#
  specs <- as.data.frame(cbind(wl_bin[-length(wl_bin)], t(specs)))#
   applied <- c(applied, paste('binned spectra to ',bw,'-nm intervals\n',sep=''))#
  }else {#
    specs <- as.data.frame(cbind(wl, specs))#
    }#
class(specs) <- c('rspec', 'data.frame')#
#
cat(applied)#
specs#
}#
#
# testing zone#
#tmp <- procspec(rspecs)#
#tmp <- procspec(rspecs, f="stretch")#
#plot(tmp, p=8:15, type='h')
aa = procspec(sicalis,opt='smooth',fixneg='addmin')
apply(sicalis,2,min)
sicalis = sicalis - 0.7
apply(sicalis,2,min)
aa = procspec(sicalis,opt='smooth',fixneg='addmin')
apply(aa,2,min)
aa
specs = sicalis
specs <- sapply(1:ncol(specs), function(z)#
           ifelse(min(specs[,z] < 0), specs[, z] + abs(min(specs[, z])), specs[,z]) )
specs
adm = function(x){
if(min(x) < 0){
x + abs(min(x))
}else{
x
}
}
sapply(1:ncol(sicalis), function(z) adm(sicalis[,z]))
apply(sapply(1:ncol(sicalis), function(z) adm(sicalis[,z])),2,min)
input an rspec object or data frame w/spectra in columns and wavelengths in rows#
# options = min, max, stretch, sum, bin, center (subtract avg. from all specs)#
#
# TODO#
# 1. add way to handle negatives#
#
procspec <- function(specs, opt = c('none', 'smooth', 'maximum', 'minimum', 'stretch', #
										 'bin', 'fix', 'sum', 'center'), #
										 fixneg = c('none', 'addmin', 'zero'),#
										 # method = c('loess', 'spline'), spar = .65, #
										 span = .15, bins = 20) {#
#
opt <- match.arg(opt, several.ok = TRUE)  	# 'fix' = how to handle negative values#
# method <- match.arg(method)#
#
fixneg <- match.arg(fixneg)#
#
applied <- 'processing options applied:\n'#
#
if (any(opt=='none')) {#
  cat('No relevant processing option entered. Returning raw values\n') #
  specs#
  }#
wl_index <- which(names(specs)=='wl')#
if (length(wl_index > 0)){#
  wl <- specs[, wl_index]#
  specs <- specs[, -wl_index]#
    } else {#
    specs <- specs#
    }#
#
if(fixneg=='addmin'){#
  adm = function(x){#
    if(min(x) < 0){ x + abs(min(x))#
    }else{#
    x #
    }#
  }#
  specs <- sapply(1:ncol(specs), function(z) adm(specs[, z]) )#
  applied <- c(applied, 'Negative value correction: added min to all reflectance\n')#
 }#
if(fixneg=='zero'){#
  specs <- sapply(1:ncol(specs), function(z) specs[,z])#
  applied <- c(applied, 'Negative value correction: set to zero\n')#
}#
#
if (any(opt=='smooth')){#
  specs <- sapply(names(specs), function(z){loess.smooth(x = wl, y = specs[, z], #
           span = span, degree = 2, family = "gaussian", #
           evaluation = length(wl))$y})#
  applied <- c(applied, paste('smoothing spectra with a span of',span,'\n'))#
  }#
#
# if (any(opt=='smooth')&method=='spline')#
  # specs <- sapply(names(specs), function(z){smooth.spline(x = wl, y = specs[, z], #
           # spar = spar)$y})#
#
# if (any(opt=='smooth')&method=='loess')#
  # specs <- sapply(names(specs), function(z){loess.smooth(x = wl, y = specs[, z], #
           # span = span, degree = 2, family = "gaussian", #
           # evaluation = length(wl))$y})#
#
if (any(opt=='minimum')){#
  specs <- sapply(1:ncol(specs), function(z)specs[, z] - min(specs[, z]))#
   applied <- c(applied, 'Scaling spectra to a minimum value of zero\n')#
  }#
#
if (any(opt=='maximum')){#
  specs <- sapply(1:ncol(specs), function(z)specs[, z] / max(specs[, z]))#
   applied <- c(applied, 'Scaling spectra to a maximum value of 1\n')#
  }#
#
if (any(opt=='sum')){#
  specs <- sapply(1:ncol(specs), function(z)specs[, z] / sum(specs[, z]))#
   applied <- c(applied, 'Scaling spectra to a total area of 1\n')#
  }#
#
if (any(opt=='center')){#
  specs <- sapply(1:ncol(specs), function(z)specs[, z] - mean(specs[, z]))#
   applied <- c(applied, 'Centering spectra to a mean of zero\n')#
  }#
#
#	if (any(opt=='fix'))#
#		specs <- ...#
		# option 1 = set all negatives to zero#
		# option 2 = add absolute val of most neg value to all spectra#
		# option 3 = set negatives to NAs, then smooth?#
#
	# Calculate medians according to # of bins specified for use in PCA#
	# Method follows Cuthill et al. (1999)#
if (any(opt=='bin')) {#
  bw <- floor(length(wl)/bins)#
  wl_bin <- seq(head(wl,1), tail(wl,1), by=bw)#
  wl_ind <- match(wl_bin, wl)#
  specs <- sapply(1:(length(wl_ind)-1), function(z) #
                  apply(specs[wl_ind[z]:(wl_ind[z]+bw), ], 2, median))#
#
  specs <- as.data.frame(cbind(wl_bin[-length(wl_bin)], t(specs)))#
   applied <- c(applied, paste('binned spectra to ',bw,'-nm intervals\n',sep=''))#
  }else {#
    specs <- as.data.frame(cbind(wl, specs))#
    }#
class(specs) <- c('rspec', 'data.frame')#
#
cat(applied)#
specs#
}#
#
# testing zone#
#tmp <- procspec(rspecs)#
#tmp <- procspec(rspecs, f="stretch")#
#plot(tmp, p=8:15, type='h')
rm(sicalis)
data(sicalis)
aa = procspec(sicalis,opt='smooth',fixneg='addmin')
aa
input an rspec object or data frame w/spectra in columns and wavelengths in rows#
# options = min, max, stretch, sum, bin, center (subtract avg. from all specs)#
#
# TODO#
# 1. add way to handle negatives#
#
procspec <- function(specs, opt = c('none', 'smooth', 'maximum', 'minimum', 'stretch', #
										 'bin', 'fix', 'sum', 'center'), #
										 fixneg = c('none', 'addmin', 'zero'),#
										 # method = c('loess', 'spline'), spar = .65, #
										 span = .15, bins = 20) {#
#
opt <- match.arg(opt, several.ok = TRUE)  	# 'fix' = how to handle negative values#
# method <- match.arg(method)#
#
fixneg <- match.arg(fixneg)#
#
applied <- 'processing options applied:\n'#
#
if (any(opt=='none')) {#
  cat('No relevant processing option entered. Returning raw values\n') #
  specs#
  }#
wl_index <- which(names(specs)=='wl')#
if (length(wl_index > 0)){#
  wl <- specs[, wl_index]#
  specs <- specs[, -wl_index]#
    } else {#
    specs <- specs#
    }#
#
if(fixneg=='addmin'){#
  adm = function(x){#
    if(min(x) < 0){ x + abs(min(x))#
    }else{#
    x #
    }#
  }#
  specs <- data.frame( sapply(1:ncol(specs), function(z) adm(specs[, z]) ) )#
  applied <- c(applied, 'Negative value correction: added min to all reflectance\n')#
 }#
if(fixneg=='zero'){#
  specs <- sapply(1:ncol(specs), function(z) specs[,z])#
  applied <- c(applied, 'Negative value correction: set to zero\n')#
}#
#
if (any(opt=='smooth')){#
  specs <- sapply(names(specs), function(z){loess.smooth(x = wl, y = specs[, z], #
           span = span, degree = 2, family = "gaussian", #
           evaluation = length(wl))$y})#
  applied <- c(applied, paste('smoothing spectra with a span of',span,'\n'))#
  }#
#
# if (any(opt=='smooth')&method=='spline')#
  # specs <- sapply(names(specs), function(z){smooth.spline(x = wl, y = specs[, z], #
           # spar = spar)$y})#
#
# if (any(opt=='smooth')&method=='loess')#
  # specs <- sapply(names(specs), function(z){loess.smooth(x = wl, y = specs[, z], #
           # span = span, degree = 2, family = "gaussian", #
           # evaluation = length(wl))$y})#
#
if (any(opt=='minimum')){#
  specs <- sapply(1:ncol(specs), function(z)specs[, z] - min(specs[, z]))#
   applied <- c(applied, 'Scaling spectra to a minimum value of zero\n')#
  }#
#
if (any(opt=='maximum')){#
  specs <- sapply(1:ncol(specs), function(z)specs[, z] / max(specs[, z]))#
   applied <- c(applied, 'Scaling spectra to a maximum value of 1\n')#
  }#
#
if (any(opt=='sum')){#
  specs <- sapply(1:ncol(specs), function(z)specs[, z] / sum(specs[, z]))#
   applied <- c(applied, 'Scaling spectra to a total area of 1\n')#
  }#
#
if (any(opt=='center')){#
  specs <- sapply(1:ncol(specs), function(z)specs[, z] - mean(specs[, z]))#
   applied <- c(applied, 'Centering spectra to a mean of zero\n')#
  }#
#
#	if (any(opt=='fix'))#
#		specs <- ...#
		# option 1 = set all negatives to zero#
		# option 2 = add absolute val of most neg value to all spectra#
		# option 3 = set negatives to NAs, then smooth?#
#
	# Calculate medians according to # of bins specified for use in PCA#
	# Method follows Cuthill et al. (1999)#
if (any(opt=='bin')) {#
  bw <- floor(length(wl)/bins)#
  wl_bin <- seq(head(wl,1), tail(wl,1), by=bw)#
  wl_ind <- match(wl_bin, wl)#
  specs <- sapply(1:(length(wl_ind)-1), function(z) #
                  apply(specs[wl_ind[z]:(wl_ind[z]+bw), ], 2, median))#
#
  specs <- as.data.frame(cbind(wl_bin[-length(wl_bin)], t(specs)))#
   applied <- c(applied, paste('binned spectra to ',bw,'-nm intervals\n',sep=''))#
  }else {#
    specs <- as.data.frame(cbind(wl, specs))#
    }#
class(specs) <- c('rspec', 'data.frame')#
#
cat(applied)#
specs#
}#
#
# testing zone#
#tmp <- procspec(rspecs)#
#tmp <- procspec(rspecs, f="stretch")#
#plot(tmp, p=8:15, type='h')
aa = procspec(sicalis,opt='smooth',fixneg='addmin')
aa
min(aa)
apply(aa,2,min)
apply(sicalis,2,min)
input an rspec object or data frame w/spectra in columns and wavelengths in rows#
# options = min, max, stretch, sum, bin, center (subtract avg. from all specs)#
#
# TODO#
# 1. add way to handle negatives#
#
procspec <- function(specs, opt = c('none', 'smooth', 'maximum', 'minimum', 'stretch', #
										 'bin', 'fix', 'sum', 'center'), #
										 fixneg = c('none', 'addmin', 'zero'),#
										 # method = c('loess', 'spline'), spar = .65, #
										 span = .15, bins = 20) {#
#
opt <- match.arg(opt, several.ok = TRUE)  	# 'fix' = how to handle negative values#
# method <- match.arg(method)#
#
fixneg <- match.arg(fixneg)#
#
applied <- 'processing options applied:\n'#
#
if (any(opt=='none')) {#
  cat('No relevant processing option entered. Returning raw values\n') #
  specs <- specs#
  }#
wl_index <- which(names(specs)=='wl')#
if (length(wl_index > 0)){#
  wl <- specs[, wl_index]#
  specs <- specs[, -wl_index]#
    } else {#
    specs <- specs#
    }#
#
if(fixneg=='addmin'){#
  adm = function(x){#
    if(min(x) < 0){ x + abs(min(x))#
    }else{#
    x #
    }#
  }#
  specs <- data.frame( sapply(1:ncol(specs), function(z) adm(specs[, z]) ) )#
  applied <- c(applied, 'Negative value correction: added min to all reflectance\n')#
 }#
if(fixneg=='zero'){#
  specs <- sapply(1:ncol(specs), function(z) specs[,z])#
  applied <- c(applied, 'Negative value correction: set to zero\n')#
}#
#
if (any(opt=='smooth')){#
  specs <- sapply(names(specs), function(z){loess.smooth(x = wl, y = specs[, z], #
           span = span, degree = 2, family = "gaussian", #
           evaluation = length(wl))$y})#
  applied <- c(applied, paste('smoothing spectra with a span of',span,'\n'))#
  }#
#
# if (any(opt=='smooth')&method=='spline')#
  # specs <- sapply(names(specs), function(z){smooth.spline(x = wl, y = specs[, z], #
           # spar = spar)$y})#
#
# if (any(opt=='smooth')&method=='loess')#
  # specs <- sapply(names(specs), function(z){loess.smooth(x = wl, y = specs[, z], #
           # span = span, degree = 2, family = "gaussian", #
           # evaluation = length(wl))$y})#
#
if (any(opt=='minimum')){#
  specs <- sapply(1:ncol(specs), function(z)specs[, z] - min(specs[, z]))#
   applied <- c(applied, 'Scaling spectra to a minimum value of zero\n')#
  }#
#
if (any(opt=='maximum')){#
  specs <- sapply(1:ncol(specs), function(z)specs[, z] / max(specs[, z]))#
   applied <- c(applied, 'Scaling spectra to a maximum value of 1\n')#
  }#
#
if (any(opt=='sum')){#
  specs <- sapply(1:ncol(specs), function(z)specs[, z] / sum(specs[, z]))#
   applied <- c(applied, 'Scaling spectra to a total area of 1\n')#
  }#
#
if (any(opt=='center')){#
  specs <- sapply(1:ncol(specs), function(z)specs[, z] - mean(specs[, z]))#
   applied <- c(applied, 'Centering spectra to a mean of zero\n')#
  }#
#
#	if (any(opt=='fix'))#
#		specs <- ...#
		# option 1 = set all negatives to zero#
		# option 2 = add absolute val of most neg value to all spectra#
		# option 3 = set negatives to NAs, then smooth?#
#
	# Calculate medians according to # of bins specified for use in PCA#
	# Method follows Cuthill et al. (1999)#
if (any(opt=='bin')) {#
  bw <- floor(length(wl)/bins)#
  wl_bin <- seq(head(wl,1), tail(wl,1), by=bw)#
  wl_ind <- match(wl_bin, wl)#
  specs <- sapply(1:(length(wl_ind)-1), function(z) #
                  apply(specs[wl_ind[z]:(wl_ind[z]+bw), ], 2, median))#
#
  specs <- as.data.frame(cbind(wl_bin[-length(wl_bin)], t(specs)))#
   applied <- c(applied, paste('binned spectra to ',bw,'-nm intervals\n',sep=''))#
  }else {#
    specs <- as.data.frame(cbind(wl, specs))#
    }#
class(specs) <- c('rspec', 'data.frame')#
#
cat(applied)#
specs#
}#
#
# testing zone#
#tmp <- procspec(rspecs)#
#tmp <- procspec(rspecs, f="stretch")#
#plot(tmp, p=8:15, type='h')
aa = procspec(sicalis,opt='none',fixneg='addmin')
apply(sicalis,2,min)
apply(aa,2,min)
sic = sicalis - 0.7
apply(sic,2,min)
aa = procspec(sic,opt='none',fixneg='addmin')
apply(sic,2,min)
apply(aa,2,min)
input an rspec object or data frame w/spectra in columns and wavelengths in rows#
# options = min, max, stretch, sum, bin, center (subtract avg. from all specs)#
#
# TODO#
# 1. add way to handle negatives#
#
procspec <- function(specs, opt = c('none', 'smooth', 'maximum', 'minimum', 'stretch', #
										 'bin', 'fix', 'sum', 'center'), #
										 fixneg = c('none', 'addmin', 'zero'),#
										 # method = c('loess', 'spline'), spar = .65, #
										 span = .15, bins = 20) {#
#
opt <- match.arg(opt, several.ok = TRUE)  	# 'fix' = how to handle negative values#
# method <- match.arg(method)#
#
fixneg <- match.arg(fixneg)#
#
applied <- 'processing options applied:\n'#
#
if (any(opt=='none')) {#
  cat('No relevant processing option entered. Returning raw values\n') #
  specs <- specs#
  }#
wl_index <- which(names(specs)=='wl')#
if (length(wl_index > 0)){#
  wl <- specs[, wl_index]#
  specs <- specs[, -wl_index]#
    } else {#
    specs <- specs#
    }#
#
if(fixneg=='addmin'){#
  adm = function(x){#
    if(min(x) < 0){ x + abs(min(x))#
    }else{#
    x #
    }#
  }#
  tempspc <- data.frame( sapply(1:ncol(specs), function(z) adm(specs[, z]) ) )#
  names(tempspc) <- names(specs)#
  specs <- tempspc#
  applied <- c(applied, 'Negative value correction: added min to all reflectance\n')#
 }#
if(fixneg=='zero'){#
  specs <- sapply(1:ncol(specs), function(z) specs[,z])#
  applied <- c(applied, 'Negative value correction: set to zero\n')#
}#
#
if (any(opt=='smooth')){#
  specs <- sapply(names(specs), function(z){loess.smooth(x = wl, y = specs[, z], #
           span = span, degree = 2, family = "gaussian", #
           evaluation = length(wl))$y})#
  applied <- c(applied, paste('smoothing spectra with a span of',span,'\n'))#
  }#
#
# if (any(opt=='smooth')&method=='spline')#
  # specs <- sapply(names(specs), function(z){smooth.spline(x = wl, y = specs[, z], #
           # spar = spar)$y})#
#
# if (any(opt=='smooth')&method=='loess')#
  # specs <- sapply(names(specs), function(z){loess.smooth(x = wl, y = specs[, z], #
           # span = span, degree = 2, family = "gaussian", #
           # evaluation = length(wl))$y})#
#
if (any(opt=='minimum')){#
  specs <- sapply(1:ncol(specs), function(z)specs[, z] - min(specs[, z]))#
   applied <- c(applied, 'Scaling spectra to a minimum value of zero\n')#
  }#
#
if (any(opt=='maximum')){#
  specs <- sapply(1:ncol(specs), function(z)specs[, z] / max(specs[, z]))#
   applied <- c(applied, 'Scaling spectra to a maximum value of 1\n')#
  }#
#
if (any(opt=='sum')){#
  specs <- sapply(1:ncol(specs), function(z)specs[, z] / sum(specs[, z]))#
   applied <- c(applied, 'Scaling spectra to a total area of 1\n')#
  }#
#
if (any(opt=='center')){#
  specs <- sapply(1:ncol(specs), function(z)specs[, z] - mean(specs[, z]))#
   applied <- c(applied, 'Centering spectra to a mean of zero\n')#
  }#
#
#	if (any(opt=='fix'))#
#		specs <- ...#
		# option 1 = set all negatives to zero#
		# option 2 = add absolute val of most neg value to all spectra#
		# option 3 = set negatives to NAs, then smooth?#
#
	# Calculate medians according to # of bins specified for use in PCA#
	# Method follows Cuthill et al. (1999)#
if (any(opt=='bin')) {#
  bw <- floor(length(wl)/bins)#
  wl_bin <- seq(head(wl,1), tail(wl,1), by=bw)#
  wl_ind <- match(wl_bin, wl)#
  specs <- sapply(1:(length(wl_ind)-1), function(z) #
                  apply(specs[wl_ind[z]:(wl_ind[z]+bw), ], 2, median))#
#
  specs <- as.data.frame(cbind(wl_bin[-length(wl_bin)], t(specs)))#
   applied <- c(applied, paste('binned spectra to ',bw,'-nm intervals\n',sep=''))#
  }else {#
    specs <- as.data.frame(cbind(wl, specs))#
    }#
class(specs) <- c('rspec', 'data.frame')#
#
cat(applied)#
specs#
}#
#
# testing zone#
#tmp <- procspec(rspecs)#
#tmp <- procspec(rspecs, f="stretch")#
#plot(tmp, p=8:15, type='h')
aa = procspec(sic,opt='none',fixneg='addmin')
apply(aa,2,min)
apply(sic,2,min)
round(aa,9)
input an rspec object or data frame w/spectra in columns and wavelengths in rows#
# options = min, max, stretch, sum, bin, center (subtract avg. from all specs)#
#
# TODO#
# 1. add way to handle negatives#
#
procspec <- function(specs, opt = c('none', 'smooth', 'maximum', 'minimum', 'stretch', #
										 'bin', 'fix', 'sum', 'center'), #
										 fixneg = c('none', 'addmin', 'zero'),#
										 # method = c('loess', 'spline'), spar = .65, #
										 span = .15, bins = 20) {#
#
opt <- match.arg(opt, several.ok = TRUE)  	# 'fix' = how to handle negative values#
# method <- match.arg(method)#
#
fixneg <- match.arg(fixneg)#
#
applied <- 'processing options applied:\n'#
#
if (any(opt=='none')) {#
  cat('No relevant processing option entered. Returning raw values\n') #
  specs <- specs#
  }#
wl_index <- which(names(specs)=='wl')#
if (length(wl_index > 0)){#
  wl <- specs[, wl_index]#
  specs <- specs[, -wl_index]#
    } else {#
    specs <- specs#
    }#
#
if(fixneg=='addmin'){#
  adm = function(x){#
    if(min(x) < 0){ x + abs(min(x))#
    }else{#
    x #
    }#
  }#
  tempspc <- data.frame( sapply(1:ncol(specs), function(z) adm(specs[, z]) ) )#
  names(tempspc) <- names(specs)#
  specs <- round(tempspc,9)#
  applied <- c(applied, 'Negative value correction: added min to all reflectance\n')#
 }#
#
if(fixneg=='zero'){#
  adz = function(x){#
    if(min(x) < 0){ x[x < 0] <- 0#
    }else{#
    x #
    }#
  }#
  tempspc <- data.frame( sapply(1:ncol(specs), function(z) adz(specs[, z]) ) )#
  names(tempspc) <- names(specs)#
  specs <- round(tempspc,9)#
  applied <- c(applied, 'Negative value correction: added min to all reflectance\n')#
 }#
if (any(opt=='smooth')){#
  specs <- sapply(names(specs), function(z){loess.smooth(x = wl, y = specs[, z], #
           span = span, degree = 2, family = "gaussian", #
           evaluation = length(wl))$y})#
  applied <- c(applied, paste('smoothing spectra with a span of',span,'\n'))#
  }#
#
# if (any(opt=='smooth')&method=='spline')#
  # specs <- sapply(names(specs), function(z){smooth.spline(x = wl, y = specs[, z], #
           # spar = spar)$y})#
#
# if (any(opt=='smooth')&method=='loess')#
  # specs <- sapply(names(specs), function(z){loess.smooth(x = wl, y = specs[, z], #
           # span = span, degree = 2, family = "gaussian", #
           # evaluation = length(wl))$y})#
#
if (any(opt=='minimum')){#
  specs <- sapply(1:ncol(specs), function(z)specs[, z] - min(specs[, z]))#
   applied <- c(applied, 'Scaling spectra to a minimum value of zero\n')#
  }#
#
if (any(opt=='maximum')){#
  specs <- sapply(1:ncol(specs), function(z)specs[, z] / max(specs[, z]))#
   applied <- c(applied, 'Scaling spectra to a maximum value of 1\n')#
  }#
#
if (any(opt=='sum')){#
  specs <- sapply(1:ncol(specs), function(z)specs[, z] / sum(specs[, z]))#
   applied <- c(applied, 'Scaling spectra to a total area of 1\n')#
  }#
#
if (any(opt=='center')){#
  specs <- sapply(1:ncol(specs), function(z)specs[, z] - mean(specs[, z]))#
   applied <- c(applied, 'Centering spectra to a mean of zero\n')#
  }#
#
#	if (any(opt=='fix'))#
#		specs <- ...#
		# option 1 = set all negatives to zero#
		# option 2 = add absolute val of most neg value to all spectra#
		# option 3 = set negatives to NAs, then smooth?#
#
	# Calculate medians according to # of bins specified for use in PCA#
	# Method follows Cuthill et al. (1999)#
if (any(opt=='bin')) {#
  bw <- floor(length(wl)/bins)#
  wl_bin <- seq(head(wl,1), tail(wl,1), by=bw)#
  wl_ind <- match(wl_bin, wl)#
  specs <- sapply(1:(length(wl_ind)-1), function(z) #
                  apply(specs[wl_ind[z]:(wl_ind[z]+bw), ], 2, median))#
#
  specs <- as.data.frame(cbind(wl_bin[-length(wl_bin)], t(specs)))#
   applied <- c(applied, paste('binned spectra to ',bw,'-nm intervals\n',sep=''))#
  }else {#
    specs <- as.data.frame(cbind(wl, specs))#
    }#
class(specs) <- c('rspec', 'data.frame')#
#
cat(applied)#
specs#
}#
#
# testing zone#
#tmp <- procspec(rspecs)#
#tmp <- procspec(rspecs, f="stretch")#
#plot(tmp, p=8:15, type='h')
aa = procspec(sic,opt='none',fixneg='zero')
apply(sic,2,min)
apply(aa,2,min)
input an rspec object or data frame w/spectra in columns and wavelengths in rows#
# options = min, max, stretch, sum, bin, center (subtract avg. from all specs)#
#
# TODO#
# 1. add way to handle negatives#
#
procspec <- function(specs, opt = c('none', 'smooth', 'maximum', 'minimum', 'stretch', #
										 'bin', 'fix', 'sum', 'center'), #
										 fixneg = c('none', 'addmin', 'zero'),#
										 # method = c('loess', 'spline'), spar = .65, #
										 span = .15, bins = 20) {#
#
opt <- match.arg(opt, several.ok = TRUE)  	# 'fix' = how to handle negative values#
# method <- match.arg(method)#
#
fixneg <- match.arg(fixneg)#
#
applied <- 'processing options applied:\n'#
#
if (any(opt=='none')) {#
  cat('No relevant processing option entered. Returning raw values\n') #
  specs <- specs#
  }#
wl_index <- which(names(specs)=='wl')#
if (length(wl_index > 0)){#
  wl <- specs[, wl_index]#
  specs <- specs[, -wl_index]#
    } else {#
    specs <- specs#
    }#
#
if(fixneg=='addmin'){#
  adm = function(x){#
    if(min(x) < 0){ x + abs(min(x))#
    }else{#
    x #
    }#
  }#
  tempspc <- data.frame( sapply(1:ncol(specs), function(z) adm(specs[, z]) ) )#
  names(tempspc) <- names(specs)#
  specs <- round(tempspc,6)#
  applied <- c(applied, 'Negative value correction: added min to all reflectance\n')#
 }#
#
if(fixneg=='zero'){#
  adz = function(x){#
    if(min(x) < 0){ x[x < 0] <- 0#
    }else{#
    x #
    }#
  }#
  tempspc <- data.frame( sapply(1:ncol(specs), function(z) adz(specs[, z]) ) )#
  names(tempspc) <- names(specs)#
  specs <- round(tempspc,6)#
  applied <- c(applied, 'Negative value correction: added min to all reflectance\n')#
 }#
if (any(opt=='smooth')){#
  specs <- sapply(names(specs), function(z){loess.smooth(x = wl, y = specs[, z], #
           span = span, degree = 2, family = "gaussian", #
           evaluation = length(wl))$y})#
  applied <- c(applied, paste('smoothing spectra with a span of',span,'\n'))#
  }#
#
# if (any(opt=='smooth')&method=='spline')#
  # specs <- sapply(names(specs), function(z){smooth.spline(x = wl, y = specs[, z], #
           # spar = spar)$y})#
#
# if (any(opt=='smooth')&method=='loess')#
  # specs <- sapply(names(specs), function(z){loess.smooth(x = wl, y = specs[, z], #
           # span = span, degree = 2, family = "gaussian", #
           # evaluation = length(wl))$y})#
#
if (any(opt=='minimum')){#
  specs <- sapply(1:ncol(specs), function(z)specs[, z] - min(specs[, z]))#
   applied <- c(applied, 'Scaling spectra to a minimum value of zero\n')#
  }#
#
if (any(opt=='maximum')){#
  specs <- sapply(1:ncol(specs), function(z)specs[, z] / max(specs[, z]))#
   applied <- c(applied, 'Scaling spectra to a maximum value of 1\n')#
  }#
#
if (any(opt=='sum')){#
  specs <- sapply(1:ncol(specs), function(z)specs[, z] / sum(specs[, z]))#
   applied <- c(applied, 'Scaling spectra to a total area of 1\n')#
  }#
#
if (any(opt=='center')){#
  specs <- sapply(1:ncol(specs), function(z)specs[, z] - mean(specs[, z]))#
   applied <- c(applied, 'Centering spectra to a mean of zero\n')#
  }#
#
#	if (any(opt=='fix'))#
#		specs <- ...#
		# option 1 = set all negatives to zero#
		# option 2 = add absolute val of most neg value to all spectra#
		# option 3 = set negatives to NAs, then smooth?#
#
	# Calculate medians according to # of bins specified for use in PCA#
	# Method follows Cuthill et al. (1999)#
if (any(opt=='bin')) {#
  bw <- floor(length(wl)/bins)#
  wl_bin <- seq(head(wl,1), tail(wl,1), by=bw)#
  wl_ind <- match(wl_bin, wl)#
  specs <- sapply(1:(length(wl_ind)-1), function(z) #
                  apply(specs[wl_ind[z]:(wl_ind[z]+bw), ], 2, median))#
#
  specs <- as.data.frame(cbind(wl_bin[-length(wl_bin)], t(specs)))#
   applied <- c(applied, paste('binned spectra to ',bw,'-nm intervals\n',sep=''))#
  }else {#
    specs <- as.data.frame(cbind(wl, specs))#
    }#
class(specs) <- c('rspec', 'data.frame')#
#
cat(applied)#
specs#
}#
#
# testing zone#
#tmp <- procspec(rspecs)#
#tmp <- procspec(rspecs, f="stretch")#
#plot(tmp, p=8:15, type='h')
aa = procspec(sic,opt='none',fixneg='zero')
aa
aa = procspec(sic,opt='none',fixneg='addmin')
aa
plot{aa,2
plot(aa[,2])
sic
input an rspec object or data frame w/spectra in columns and wavelengths in rows#
# options = min, max, stretch, sum, bin, center (subtract avg. from all specs)#
#
# TODO#
# 1. add way to handle negatives#
#
procspec <- function(specs, opt = c('none', 'smooth', 'maximum', 'minimum', 'stretch', #
										 'bin', 'fix', 'sum', 'center'), #
										 fixneg = c('none', 'addmin', 'zero'),#
										 # method = c('loess', 'spline'), spar = .65, #
										 span = .15, bins = 20) {#
#
opt <- match.arg(opt, several.ok = TRUE)  	# 'fix' = how to handle negative values#
# method <- match.arg(method)#
#
fixneg <- match.arg(fixneg)#
#
applied <- 'processing options applied:\n'#
#
if (any(opt=='none')) {#
  cat('No relevant processing option entered. Returning raw values\n') #
  specs <- specs#
  }#
wl_index <- which(names(specs)=='wl')#
if (length(wl_index > 0)){#
  wl <- specs[, wl_index]#
  specs <- specs[, -wl_index]#
    } else {#
    specs <- specs#
    }#
#
if(fixneg=='addmin'){#
  adm = function(x){#
    if(min(x) < 0){ x + abs(min(x))#
    }else{#
    x #
    }#
  }#
  tempspc <- data.frame( sapply(1:ncol(specs), function(z) adm(specs[, z]) ) )#
  names(tempspc) <- names(specs)#
  specs <- round(tempspc,6)#
  applied <- c(applied, 'Negative value correction: added min to all reflectance\n')#
 }#
#
if(fixneg=='zero'){#
  specs[specs < 0 ] <- 0#
  applied <- c(applied, 'Negative value correction: added min to all reflectance\n')#
 }#
if (any(opt=='smooth')){#
  specs <- sapply(names(specs), function(z){loess.smooth(x = wl, y = specs[, z], #
           span = span, degree = 2, family = "gaussian", #
           evaluation = length(wl))$y})#
  applied <- c(applied, paste('smoothing spectra with a span of',span,'\n'))#
  }#
#
# if (any(opt=='smooth')&method=='spline')#
  # specs <- sapply(names(specs), function(z){smooth.spline(x = wl, y = specs[, z], #
           # spar = spar)$y})#
#
# if (any(opt=='smooth')&method=='loess')#
  # specs <- sapply(names(specs), function(z){loess.smooth(x = wl, y = specs[, z], #
           # span = span, degree = 2, family = "gaussian", #
           # evaluation = length(wl))$y})#
#
if (any(opt=='minimum')){#
  specs <- sapply(1:ncol(specs), function(z)specs[, z] - min(specs[, z]))#
   applied <- c(applied, 'Scaling spectra to a minimum value of zero\n')#
  }#
#
if (any(opt=='maximum')){#
  specs <- sapply(1:ncol(specs), function(z)specs[, z] / max(specs[, z]))#
   applied <- c(applied, 'Scaling spectra to a maximum value of 1\n')#
  }#
#
if (any(opt=='sum')){#
  specs <- sapply(1:ncol(specs), function(z)specs[, z] / sum(specs[, z]))#
   applied <- c(applied, 'Scaling spectra to a total area of 1\n')#
  }#
#
if (any(opt=='center')){#
  specs <- sapply(1:ncol(specs), function(z)specs[, z] - mean(specs[, z]))#
   applied <- c(applied, 'Centering spectra to a mean of zero\n')#
  }#
#
#	if (any(opt=='fix'))#
#		specs <- ...#
		# option 1 = set all negatives to zero#
		# option 2 = add absolute val of most neg value to all spectra#
		# option 3 = set negatives to NAs, then smooth?#
#
	# Calculate medians according to # of bins specified for use in PCA#
	# Method follows Cuthill et al. (1999)#
if (any(opt=='bin')) {#
  bw <- floor(length(wl)/bins)#
  wl_bin <- seq(head(wl,1), tail(wl,1), by=bw)#
  wl_ind <- match(wl_bin, wl)#
  specs <- sapply(1:(length(wl_ind)-1), function(z) #
                  apply(specs[wl_ind[z]:(wl_ind[z]+bw), ], 2, median))#
#
  specs <- as.data.frame(cbind(wl_bin[-length(wl_bin)], t(specs)))#
   applied <- c(applied, paste('binned spectra to ',bw,'-nm intervals\n',sep=''))#
  }else {#
    specs <- as.data.frame(cbind(wl, specs))#
    }#
class(specs) <- c('rspec', 'data.frame')#
#
cat(applied)#
specs#
}#
#
# testing zone#
#tmp <- procspec(rspecs)#
#tmp <- procspec(rspecs, f="stretch")#
#plot(tmp, p=8:15, type='h')
aa = procspec(sic,opt='none',fixneg='addmin')
aa = procspec(sic,opt='none',fixneg='zero')
aa
apply(aa,2,min)
apply(sic,2,min)
plot(aa[,2])
load("/Users/rmaia/Desktop/MCC-tree-data.RData")
